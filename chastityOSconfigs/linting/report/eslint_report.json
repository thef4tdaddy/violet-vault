[
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/postcss.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/tailwind.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/vite.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/deployment/vercel.build.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/linting/commitlint.config.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/App.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/Root.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/Navigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementDashboard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'UnreadNotification' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 33,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 33,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Achievement Dashboard Component\n * Overview of user's achievement progress and recent unlocks\n */\n\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n  FaTrophy,\n  FaFire,\n  FaBullseye,\n  FaClock,\n  FaStar,\n  FaArrowRight,\n} from \"../../utils/iconImport\";\nimport { useAchievements } from \"../../hooks/useAchievements\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  AchievementCategory,\n  DBUserAchievement,\n  DBAchievement,\n  DBAchievementNotification,\n} from \"../../types\";\n\n// Types\ninterface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<string, number>;\n}\n\ninterface UnreadNotification {\n  id: string;\n  [key: string]: unknown;\n}\n\ninterface CategoryProgressItem {\n  category: AchievementCategory;\n  earned: number;\n  total: number;\n  percentage: number;\n  name: string;\n  icon: React.ReactElement;\n}\n\n// Loading State Component\nconst LoadingState: React.FC = () => (\n  <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n    <div className=\"animate-pulse\">\n      <div className=\"h-6 bg-gray-300 rounded w-1/3 mb-4\"></div>\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        {[...Array(4)].map((_, i) => (\n          <div key={i} className=\"h-20 bg-gray-300 rounded\"></div>\n        ))}\n      </div>\n    </div>\n  </div>\n);\n\n// Stats Cards Component\nconst StatsCards: React.FC<{\n  achievementStats: AchievementStats;\n  unreadNotifications: DBAchievementNotification[];\n}> = ({ achievementStats, unreadNotifications }) => (\n  <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n    <div className=\"bg-gradient-to-br from-nightly-aquamarine/20 to-nightly-aquamarine/10 rounded-lg p-4 border border-nightly-aquamarine/30\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <p className=\"text-sm text-nightly-celadon\">Total Earned</p>\n          <p className=\"text-2xl font-bold text-nightly-honeydew\">\n            {achievementStats.totalEarned}\n          </p>\n        </div>\n        <FaTrophy className=\"text-2xl text-nightly-aquamarine\" />\n      </div>\n    </div>\n\n    <div className=\"bg-gradient-to-br from-nightly-lavender-floral/20 to-nightly-lavender-floral/10 rounded-lg p-4 border border-nightly-lavender-floral/30\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <p className=\"text-sm text-nightly-celadon\">Total Points</p>\n          <p className=\"text-2xl font-bold text-nightly-honeydew\">\n            {achievementStats.totalPoints}\n          </p>\n        </div>\n        <FaStar className=\"text-2xl text-nightly-lavender-floral\" />\n      </div>\n    </div>\n\n    <div className=\"bg-gradient-to-br from-nightly-spring-green/20 to-nightly-spring-green/10 rounded-lg p-4 border border-nightly-spring-green/30\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <p className=\"text-sm text-nightly-celadon\">Completion</p>\n          <p className=\"text-2xl font-bold text-nightly-honeydew\">\n            {achievementStats.completionPercentage.toFixed(0)}%\n          </p>\n        </div>\n        <FaBullseye className=\"text-2xl text-nightly-spring-green\" />\n      </div>\n    </div>\n\n    <div className=\"bg-gradient-to-br from-red-500/20 to-red-500/10 rounded-lg p-4 border border-red-500/30\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <p className=\"text-sm text-nightly-celadon\">New Unlocks</p>\n          <p className=\"text-2xl font-bold text-nightly-honeydew\">\n            {unreadNotifications.length}\n          </p>\n        </div>\n        <FaFire className=\"text-2xl text-red-400\" />\n      </div>\n    </div>\n  </div>\n);\n\n// Recent Achievements Component\nconst RecentAchievements: React.FC<{\n  recentAchievements: DBUserAchievement[];\n  allAchievements: DBAchievement[];\n}> = ({ recentAchievements, allAchievements }) => {\n  if (recentAchievements.length === 0) return null;\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-4\">\n        Recent Achievements\n      </h3>\n      <div className=\"space-y-3\">\n        {recentAchievements.map((userAchievement: DBUserAchievement) => {\n          const achievement = allAchievements.find(\n            (a: DBAchievement) => a.id === userAchievement.achievementId,\n          );\n          if (!achievement) return null;\n\n          return (\n            <div\n              key={userAchievement.id}\n              className=\"flex items-center space-x-3 p-3 bg-white/5 rounded-lg\"\n            >\n              <div className=\"text-2xl\">{achievement.icon}</div>\n              <div className=\"flex-1\">\n                <h4 className=\"font-semibold text-nightly-honeydew\">\n                  {achievement.name}\n                </h4>\n                <p className=\"text-sm text-nightly-celadon\">\n                  {achievement.description}\n                </p>\n                <div className=\"flex items-center space-x-2 mt-1\">\n                  <span className=\"text-xs bg-yellow-500/20 text-yellow-300 px-2 py-1 rounded\">\n                    +{achievement.points} points\n                  </span>\n                  <span className=\"text-xs text-nightly-celadon\">\n                    {formatDate(userAchievement.earnedAt.toDate())}\n                  </span>\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\n// Category Progress Component\nconst CategoryProgress: React.FC<{\n  categoryProgress: CategoryProgressItem[];\n}> = ({ categoryProgress }) => (\n  <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n    <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-4\">\n      Progress by Category\n    </h3>\n    <div className=\"space-y-4\">\n      {categoryProgress.map((category) => (\n        <div key={category.category} className=\"space-y-2\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-2\">\n              {category.icon}\n              <span className=\"text-nightly-celadon\">{category.name}</span>\n            </div>\n            <span className=\"text-sm text-nightly-celadon\">\n              {category.earned} / {category.total}\n            </span>\n          </div>\n          <div className=\"w-full bg-gray-700 rounded-full h-2\">\n            <div\n              className=\"bg-gradient-to-r from-nightly-aquamarine to-nightly-lavender-floral h-2 rounded-full transition-all duration-300\"\n              style={{ width: `${category.percentage}%` }}\n            />\n          </div>\n        </div>\n      ))}\n    </div>\n  </div>\n);\n\nexport const AchievementDashboard: React.FC = () => {\n  const { user } = useAuthState();\n  const {\n    achievementStats,\n    userAchievements,\n    unreadNotifications,\n    allAchievements,\n    getAchievementsByCategory,\n    isLoading,\n  } = useAchievements(user?.uid);\n\n  if (isLoading || !achievementStats) {\n    return <LoadingState />;\n  }\n\n  const recentAchievements = userAchievements\n    .sort(\n      (a: DBUserAchievement, b: DBUserAchievement) =>\n        b.earnedAt.toDate().getTime() - a.earnedAt.toDate().getTime(),\n    )\n    .slice(0, 3);\n\n  const categories: AchievementCategory[] = [\n    AchievementCategory.SESSION_MILESTONES,\n    AchievementCategory.CONSISTENCY_BADGES,\n    AchievementCategory.STREAK_ACHIEVEMENTS,\n    AchievementCategory.GOAL_BASED,\n    AchievementCategory.TASK_COMPLETION,\n    AchievementCategory.SPECIAL_ACHIEVEMENTS,\n  ];\n\n  const categoryProgress = categories.map((category) => {\n    const categoryAchievements = getAchievementsByCategory(category);\n    const earned = achievementStats.categoryCounts[category] || 0;\n    const total = categoryAchievements.length;\n    const percentage = total > 0 ? (earned / total) * 100 : 0;\n\n    return {\n      category,\n      earned,\n      total,\n      percentage,\n      name: getCategoryDisplayName(category),\n      icon: getCategoryIcon(category),\n    };\n  });\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-end\">\n        <Link\n          to=\"/achievements\"\n          className=\"flex items-center space-x-2 text-nightly-aquamarine hover:text-nightly-lavender-floral transition-colors\"\n        >\n          <span>View All Achievements</span>\n          <FaArrowRight />\n        </Link>\n      </div>\n\n      <StatsCards\n        achievementStats={achievementStats}\n        unreadNotifications={unreadNotifications}\n      />\n\n      <RecentAchievements\n        recentAchievements={recentAchievements}\n        allAchievements={allAchievements}\n      />\n\n      <CategoryProgress categoryProgress={categoryProgress} />\n    </div>\n  );\n};\n\nfunction getCategoryDisplayName(category: AchievementCategory): string {\n  switch (category) {\n    case \"session_milestones\":\n      return \"Session Milestones\";\n    case \"consistency_badges\":\n      return \"Consistency\";\n    case \"streak_achievements\":\n      return \"Streaks\";\n    case \"goal_based\":\n      return \"Goals\";\n    case \"task_completion\":\n      return \"Tasks\";\n    case \"special_achievements\":\n      return \"Special\";\n    default:\n      return \"Unknown\";\n  }\n}\n\nfunction getCategoryIcon(category: AchievementCategory) {\n  switch (category) {\n    case \"session_milestones\":\n      return <FaClock className=\"text-nightly-aquamarine\" />;\n    case \"consistency_badges\":\n      return <FaBullseye className=\"text-nightly-lavender-floral\" />;\n    case \"streak_achievements\":\n      return <FaFire className=\"text-red-400\" />;\n    case \"goal_based\":\n      return <FaTrophy className=\"text-yellow-400\" />;\n    case \"task_completion\":\n      return <FaStar className=\"text-green-400\" />;\n    case \"special_achievements\":\n      return <FaStar className=\"text-purple-400\" />;\n    default:\n      return <FaTrophy className=\"text-gray-400\" />;\n  }\n}\n\nfunction formatDate(date: Date): string {\n  const now = new Date();\n  const diffInMs = now.getTime() - date.getTime();\n  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n\n  if (diffInDays === 0) {\n    return \"Today\";\n  } else if (diffInDays === 1) {\n    return \"Yesterday\";\n  } else if (diffInDays < 7) {\n    return `${diffInDays} days ago`;\n  } else {\n    return date.toLocaleDateString();\n  }\n}\n\nexport default AchievementDashboard;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallery.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallerySubComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPageStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPrivacySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementViewToggle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/LeaderboardView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/ConflictResolutionModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/DexieDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/SyncStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardLayouts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardMain.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/FeatureCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/database/DatabaseDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/demo/SessionPersistenceDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/examples/IntegratedTaskManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackFAB.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/CurrentStatusSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/SessionHistorySection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/StatisticsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/goals/SpecialChallengeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AcceptInviteCodeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinking.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemoComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingLoading.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingPreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveInviteCodesDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveKeyholderDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AdminDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/InviteCodeCreationSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/KeyholderPasswordUnlock.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/LinkingMessageDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/RelationshipSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SessionControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SubmissiveRelationshipsDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TaskManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TypedKeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AchievementNotifications.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AppLayout.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setPageTitle'. Either include it or remove the dependency array. Outer scope values like 'navItems' aren't valid dependencies because mutating them doesn't re-render the component.",
        "line": 66,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 66,
        "endColumn": 35,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [location.pathname, setPageTitle]",
            "fix": { "range": [2108, 2137], "text": "[location.pathname, setPageTitle]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'closeMobileMenu'. Either include it or remove the dependency array.",
        "line": 72,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 72,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [closeMobileMenu, location.pathname]",
            "fix": { "range": [2350, 2369], "text": "[closeMobileMenu, location.pathname]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/Header.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/MobileMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/NavigationData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/EventList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/LogEventForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomSheet.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/PullToRefresh.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/SwipeableCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/TouchTarget.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/VirtualList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/PrivacyPolicyModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/privacy/PrivacyPolicyContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/notifications/NotificationToast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileErrorStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileRecentAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileStatistics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/PublicProfileHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/ErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/MigrationBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/PendingRequestsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipRequestForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/LogItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/ManualEntryForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardPunishmentStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/AccountSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DataControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DisplaySettingsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PersonalGoalSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PublicProfileSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ResetModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SecuritySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SessionEditSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ToggleSwitch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/system/OfflineStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/CountdownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/TaskItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/CooldownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/DenialCooldown.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/GoalDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/KeyholderRequirement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseCooldownMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseResumeButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ReasonModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/RestoreSessionPrompt.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionLoader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionRecoveryModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/stats/CageOffStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/stats/CageOnStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/stats/PauseStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/stats/index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/ui/NotificationContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/consistency-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/goal-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/milestone-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/special-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/streak-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/task-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/challengeAchievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/session-goals-templates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AppContext.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.",
        "line": 158,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 158,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setState]",
            "fix": { "range": [4486, 4488], "text": "[setState]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AuthContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/SyncContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/ToastProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useAccountLinkingDemo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useDexieSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useOfflineDemo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/firebase.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/useAccountLinking.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (270). Maximum allowed is 150.",
        "line": 30,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 349,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Account Linking Hook\n * React hook for managing keyholder-wearer account linking\n */\nimport { useState, useCallback, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AccountLinkingService } from \"../../services/auth/account-linking\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  AccountLinkingState,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useAccountLinking\");\n\n// Query keys\nconst QUERY_KEYS = {\n  relationships: (userId: string) => [\"adminRelationships\", userId],\n  validation: (code: string) => [\"linkCodeValidation\", code],\n  adminSession: (relationshipId: string) => [\"adminSession\", relationshipId],\n} as const;\n\nexport const useAccountLinking = () => {\n  const { user } = useAuthState();\n  const queryClient = useQueryClient();\n\n  // Local state\n  const [state, setState] = useState<AccountLinkingState>({\n    isGeneratingCode: false,\n    currentLinkCode: null,\n    linkCodeError: null,\n    isUsingCode: false,\n    codeUsageError: null,\n    adminRelationships: [],\n    selectedWearerId: null,\n    currentAdminSession: null,\n    isAdminSessionActive: false,\n    showQRCode: false,\n    showDisconnectionDialog: false,\n    showPermissionEditor: false,\n  });\n\n  // ==================== QUERIES ====================\n\n  // Get admin relationships for current user\n  const {\n    data: relationships = [],\n    isLoading: isLoadingRelationships,\n    error: relationshipsError,\n  } = useQuery({\n    queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n    queryFn: () => AccountLinkingService.getAdminRelationships(user!.uid),\n    enabled: !!user,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Update local state when relationships change\n  useEffect(() => {\n    setState((prev) => ({ ...prev, adminRelationships: relationships }));\n  }, [relationships]);\n\n  // ==================== MUTATIONS ====================\n\n  // Generate link code\n  const generateLinkCodeMutation = useMutation({\n    mutationFn: (request: GenerateLinkCodeRequest) =>\n      AccountLinkingService.generateLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isGeneratingCode: true,\n        linkCodeError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<LinkCodeResponse>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentLinkCode: response.data!,\n          isGeneratingCode: false,\n        }));\n        logger.info(\"Link code generated successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: response.error || \"Failed to generate link code\",\n          isGeneratingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        linkCodeError: error.message,\n        isGeneratingCode: false,\n      }));\n      logger.error(\"Failed to generate link code\", { error });\n    },\n  });\n\n  // Use link code\n  const useLinkCodeMutation = useMutation({\n    mutationFn: (request: UseLinkCodeRequest) =>\n      AccountLinkingService.redeemLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isUsingCode: true,\n        codeUsageError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          isUsingCode: false,\n        }));\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Link code used successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: response.error || \"Failed to use link code\",\n          isUsingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        codeUsageError: error.message,\n        isUsingCode: false,\n      }));\n      logger.error(\"Failed to use link code\", { error });\n    },\n  });\n\n  // Update relationship\n  const updateRelationshipMutation = useMutation({\n    mutationFn: (request: UpdateRelationshipRequest) =>\n      AccountLinkingService.updateRelationship(request),\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success) {\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Relationship updated successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to update relationship\", { error });\n    },\n  });\n\n  // Start admin session\n  const startAdminSessionMutation = useMutation({\n    mutationFn: (relationshipId: string) =>\n      AccountLinkingService.startAdminSession(relationshipId),\n    onSuccess: (response: ApiResponse<AdminSession>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentAdminSession: response.data!,\n          isAdminSessionActive: true,\n        }));\n        logger.info(\"Admin session started successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to start admin session\", { error });\n    },\n  });\n\n  // ==================== CALLBACK FUNCTIONS ====================\n\n  const generateLinkCode = useCallback(\n    (request: GenerateLinkCodeRequest = {}) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: \"Authentication required\",\n        }));\n        return;\n      }\n      generateLinkCodeMutation.mutate(request);\n    },\n    [user, generateLinkCodeMutation],\n  );\n\n  const redeemLinkCode = useCallback(\n    (request: UseLinkCodeRequest) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: \"Authentication required\",\n        }));\n        return;\n      }\n      useLinkCodeMutation.mutate(request);\n    },\n    [user, useLinkCodeMutation],\n  );\n\n  const updateRelationship = useCallback(\n    (request: UpdateRelationshipRequest) => {\n      updateRelationshipMutation.mutate(request);\n    },\n    [updateRelationshipMutation],\n  );\n\n  const startAdminSession = useCallback(\n    (relationshipId: string) => {\n      startAdminSessionMutation.mutate(relationshipId);\n    },\n    [startAdminSessionMutation],\n  );\n\n  const disconnectKeyholder = useCallback(\n    (relationshipId: string, reason?: string) => {\n      updateRelationship({\n        relationshipId,\n        status: \"terminated\",\n        terminationReason: reason,\n      });\n    },\n    [updateRelationship],\n  );\n\n  const clearLinkCode = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n    }));\n  }, []);\n\n  const clearAllErrors = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n      codeUsageError: null,\n    }));\n  }, []);\n\n  const setSelectedWearer = useCallback((wearerId: string | null) => {\n    setState((prev) => ({ ...prev, selectedWearerId: wearerId }));\n  }, []);\n\n  // Combined toggle function for boolean state properties\n  const toggleStateProperty = useCallback(\n    (\n      property: keyof Pick<\n        AccountLinkingState,\n        \"showQRCode\" | \"showDisconnectionDialog\" | \"showPermissionEditor\"\n      >,\n    ) => {\n      setState((prev) => ({ ...prev, [property]: !prev[property] }));\n    },\n    [],\n  );\n\n  const toggleQRCode = useCallback(\n    () => toggleStateProperty(\"showQRCode\"),\n    [toggleStateProperty],\n  );\n  const toggleDisconnectionDialog = useCallback(\n    () => toggleStateProperty(\"showDisconnectionDialog\"),\n    [toggleStateProperty],\n  );\n  const togglePermissionEditor = useCallback(\n    () => toggleStateProperty(\"showPermissionEditor\"),\n    [toggleStateProperty],\n  );\n\n  // ==================== DERIVED STATE ====================\n\n  // User role calculations\n  const userRoles = useMemo(\n    () => ({\n      isKeyholder: relationships.some((r) => r.keyholderId === user?.uid),\n      isWearer: relationships.some((r) => r.wearerId === user?.uid),\n      hasActiveRelationships: relationships.some((r) => r.status === \"active\"),\n    }),\n    [relationships, user?.uid],\n  );\n\n  // Relationship filtering\n  const relationshipsByRole = useMemo(\n    () => ({\n      keyholderRelationships: relationships.filter(\n        (r) => r.keyholderId === user?.uid,\n      ),\n      wearerRelationships: relationships.filter(\n        (r) => r.wearerId === user?.uid,\n      ),\n    }),\n    [relationships, user?.uid],\n  );\n\n  const selectedRelationship = state.selectedWearerId\n    ? relationships.find((r) => r.wearerId === state.selectedWearerId)\n    : null;\n\n  // ==================== RETURN OBJECT ====================\n\n  return {\n    // State\n    ...state,\n    relationships,\n    isLoadingRelationships,\n    relationshipsError,\n\n    // Derived state\n    ...userRoles,\n    selectedRelationship,\n    ...relationshipsByRole,\n\n    // Actions\n    generateLinkCode,\n    redeemLinkCode,\n    updateRelationship,\n    startAdminSession,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearAllErrors,\n    setSelectedWearer,\n    toggleQRCode,\n    toggleDisconnectionDialog,\n    togglePermissionEditor,\n\n    // Loading states\n    isGeneratingCode: generateLinkCodeMutation.isPending,\n    isUsingCode: useLinkCodeMutation.isPending,\n    isUpdatingRelationship: updateRelationshipMutation.isPending,\n    isStartingSession: startAdminSessionMutation.isPending,\n  };\n};\n\n// ==================== ADDITIONAL HOOKS ====================\n\n/**\n * Hook for validating link codes\n */\nexport const useLinkCodeValidation = (code: string) => {\n  return useQuery({\n    queryKey: QUERY_KEYS.validation(code),\n    queryFn: () => AccountLinkingService.validateLinkCode(code),\n    enabled: code.length > 0,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n};\n\n/**\n * Hook for admin access validation\n */\nexport const useAdminAccess = (wearerId: string) => {\n  const { user } = useAuthState();\n  const { relationships } = useAccountLinking();\n\n  const adminRelationship = relationships.find(\n    (r) =>\n      r.keyholderId === user?.uid &&\n      r.wearerId === wearerId &&\n      r.status === \"active\",\n  );\n\n  const hasAccess = !!adminRelationship;\n  const permissions = adminRelationship?.permissions || null;\n  const security = adminRelationship?.security || null;\n\n  const canPerformAction = useCallback(\n    (action: keyof typeof permissions) => {\n      return hasAccess && permissions?.[action] === true;\n    },\n    [hasAccess, permissions],\n  );\n\n  return {\n    hasAccess,\n    adminRelationship,\n    permissions,\n    security,\n    canPerformAction,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/useLeaderboardActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/usePrivacySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/queryClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useAuth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEmergency.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEventQueries.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useEventMutations' has too many lines (184). Maximum allowed is 150.",
        "line": 89,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 307,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Events TanStack Query Hooks\n * Manages event log data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { eventDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBEvent, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useEventsQuery\");\n\n/**\n * Query for getting all events for a user\n */\nexport function useEventsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"events\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const events = await eventDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(userId).catch((error) => {\n          logger.warn(\"Background events sync failed\", { error });\n        });\n      }\n\n      return events;\n    },\n    ...cacheConfig.events, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting recent events (last 30 days)\n */\nexport function useRecentEventsQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"recent\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents\n        .filter((event) => event.timestamp >= thirtyDaysAgo)\n        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Query for getting events by type\n */\nexport function useEventsByTypeQuery(\n  userId: string | undefined,\n  eventType: EventType,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"type\", userId, eventType],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents.filter((event) => event.type === eventType);\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for event operations\n */\nexport function useEventMutations() {\n  const queryClient = useQueryClient();\n\n  const createEvent = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      type: EventType;\n      timestamp: Date;\n      notes?: string;\n      duration?: number;\n      isPrivate?: boolean;\n      sessionId?: string;\n      metadata?: Record<string, unknown>;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const { notes, duration, ...restParams } = params;\n      const eventData = {\n        ...restParams,\n        isPrivate: restParams.isPrivate ?? false, // Ensure isPrivate is always defined\n        details: {\n          notes,\n          duration,\n        },\n      };\n      const event = await eventDBService.createEvent(eventData);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event creation sync failed\", { error });\n        });\n      }\n\n      return event;\n    },\n    onSuccess: (data, variables) => {\n      // Add event to the cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return [data];\n          return [data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create event\", { error });\n    },\n  });\n\n  const updateEvent = useMutation({\n    mutationFn: async (params: {\n      eventId: string;\n      userId: string;\n      updates: Partial<DBEvent>;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedEvent = await eventDBService.updateEvent(\n        params.eventId,\n        params.updates,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event update sync failed\", { error });\n        });\n      }\n\n      return updatedEvent;\n    },\n    onSuccess: (data, variables) => {\n      // Update event in cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.map((event) =>\n            event.id === variables.eventId\n              ? { ...event, ...(data as Partial<DBEvent>) }\n              : event,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update event\", { error });\n    },\n  });\n\n  const deleteEvent = useMutation({\n    mutationFn: async (params: { eventId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await eventDBService.deleteEvent(params.eventId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event deletion sync failed\", { error });\n        });\n      }\n\n      return params.eventId;\n    },\n    onSuccess: (eventId, variables) => {\n      // Remove event from cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.filter((event) => event.id !== eventId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete event\", { error });\n    },\n  });\n\n  const bulkCreateEvents = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      events: Array<{\n        type: EventType;\n        timestamp: Date;\n        notes?: string;\n        duration?: number;\n        isPrivate?: boolean;\n        sessionId?: string;\n        metadata?: Record<string, unknown>;\n      }>;\n    }) => {\n      // 1. Create all events in local Dexie\n      const createdEvents = await Promise.all(\n        params.events.map((eventData) => {\n          const { notes, duration, ...restEventData } = eventData;\n          return eventDBService.createEvent({\n            ...restEventData,\n            userId: params.userId,\n            isPrivate: restEventData.isPrivate ?? false, // Ensure isPrivate is always defined\n            details: {\n              notes,\n              duration,\n            },\n          });\n        }),\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Bulk event creation sync failed\", { error });\n        });\n      }\n\n      return createdEvents;\n    },\n    onSuccess: (data, variables) => {\n      // Add all events to cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return data;\n          return [...data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to bulk create events\", { error });\n    },\n  });\n\n  return {\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    bulkCreateEvents,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useOfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSessionQuery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettingsQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTaskQuery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/dataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useConflictResolution.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (333). Maximum allowed is 150.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (31). Maximum allowed is 25.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeRealTimeSync', 'loadPendingConflicts', 'loadRelationshipSyncStatus', 'loadSyncHistory', and 'loadSyncPermissions'. Either include them or remove the dependency array.",
        "line": 151,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 151,
        "endColumn": 49,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]",
            "fix": {
              "range": [4192, 4235],
              "text": "[userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'performBackgroundSync'. Either include it or remove the dependency array.",
        "line": 167,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 167,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [performBackgroundSync, realTimeSyncEnabled, syncPermissions]",
            "fix": {
              "range": [4812, 4850],
              "text": "[performBackgroundSync, realTimeSyncEnabled, syncPermissions]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Data Synchronization Hook\n * Handles multi-user data sync, relationship data, and conflict resolution\n * with proper privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { SyncResult } from \"../../types/database\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateOverallSyncQuality,\n  getLastSuccessfulSync,\n  getSyncInterval,\n} from \"../../utils/dataSyncHelpers\";\nimport { useConflictResolution } from \"./useConflictResolution\";\nimport { useSyncBackup } from \"./useSyncBackup\";\nimport { useSyncMonitoring } from \"./useSyncMonitoring\";\n\nconst logger = serviceLogger(\"useDataSync\");\n\n// ==================== INTERFACES ====================\n\nimport type {\n  SyncStatus,\n  RelationshipSyncStatus,\n  DataConflict,\n  SyncPermissions,\n  SyncMetrics,\n  SyncScope,\n  DataEntityType,\n  RelationshipSyncResult,\n} from \"./types/dataSync\";\nimport type * as _Types from \"./types/dataSync\";\nexport type * from \"./types/dataSync\";\n\n// Complex sync orchestration hook requires many statements for proper state management\n// eslint-disable-next-line max-statements\nexport const useDataSync = (userId: string) => {\n  // ==================== STATE ====================\n\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    state: \"idle\",\n    lastSync: null,\n    progress: 0,\n    message: \"Ready to sync\",\n    error: null,\n  });\n\n  const [relationshipSync, setRelationshipSync] = useState<\n    RelationshipSyncStatus[]\n  >([]);\n\n  const [conflicts, setConflicts] = useState<DataConflict[]>([]);\n\n  const [syncPermissions, setSyncPermissions] = useState<SyncPermissions>({\n    allowDataSharing: true,\n    shareSessionData: true,\n    shareGoalData: true,\n    shareTaskData: true,\n    shareEventData: false,\n    allowRealTimeSync: false,\n    syncFrequency: \"moderate\",\n    privacyLevel: \"relationship_only\",\n  });\n\n  const [syncMetrics, setSyncMetrics] = useState<SyncMetrics>({\n    totalSyncs: 0,\n    successfulSyncs: 0,\n    failedSyncs: 0,\n    averageSyncTime: 0,\n    dataTransferred: 0,\n    conflictsResolved: 0,\n    lastSuccessfulSync: null,\n    reliabilityScore: 100,\n  });\n\n  const [realTimeSyncEnabled, setRealTimeSyncEnabled] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== SUB-HOOKS ====================\n\n  const conflictResolution = useConflictResolution({\n    conflicts,\n    setConflicts,\n    setSyncMetrics,\n  });\n\n  const syncBackup = useSyncBackup({ userId });\n\n  const syncMonitoring = useSyncMonitoring({ conflicts, syncMetrics });\n\n  // ==================== COMPUTED VALUES ====================\n\n  const isSyncing = useMemo(\n    () => syncStatus.state === \"syncing\",\n    [syncStatus.state],\n  );\n\n  const hasConflicts = useMemo(() => conflicts.length > 0, [conflicts.length]);\n\n  const syncQuality = useMemo(\n    () => calculateOverallSyncQuality(relationshipSync),\n    [relationshipSync],\n  );\n\n  const lastSuccessfulSync = useMemo(\n    () => getLastSuccessfulSync(syncMetrics),\n    [syncMetrics],\n  );\n\n  const needsAttention = useMemo(\n    () =>\n      conflicts.some((c) => c.priority === \"high\" || c.priority === \"critical\"),\n    [conflicts],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSync = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load sync state and configuration\n        await Promise.all([\n          loadSyncPermissions(),\n          loadSyncHistory(),\n          loadPendingConflicts(),\n          loadRelationshipSyncStatus(),\n        ]);\n\n        // Initialize real-time sync if enabled\n        if (syncPermissions.allowRealTimeSync) {\n          await initializeRealTimeSync();\n        }\n      } catch (err) {\n        logger.error(\"Failed to initialize data sync\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize sync\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSync();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, syncPermissions.allowRealTimeSync]);\n\n  // ==================== REAL-TIME SYNC ====================\n\n  useEffect(() => {\n    if (!realTimeSyncEnabled || !syncPermissions.allowRealTimeSync) return;\n\n    const syncInterval = getSyncInterval(syncPermissions.syncFrequency);\n    const interval = setInterval(() => {\n      performBackgroundSync();\n    }, syncInterval);\n\n    return () => clearInterval(interval);\n    // performBackgroundSync is stable (no deps)\n    // realTimeSyncEnabled and syncPermissions trigger re-setup of interval when changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [realTimeSyncEnabled, syncPermissions]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSyncPermissions = useCallback(async () => {\n    try {\n      // Load user's sync preferences from database\n      logger.debug(\"Loading sync permissions\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync permissions\", { error });\n    }\n  }, [userId]);\n\n  const loadSyncHistory = useCallback(async () => {\n    try {\n      // Load sync metrics and history\n      logger.debug(\"Loading sync history\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync history\", { error });\n    }\n  }, [userId]);\n\n  const loadPendingConflicts = useCallback(async () => {\n    try {\n      // Load unresolved conflicts\n      setConflicts([]);\n      logger.debug(\"Loading pending conflicts\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load pending conflicts\", { error });\n    }\n  }, [userId]);\n\n  const loadRelationshipSyncStatus = useCallback(async () => {\n    try {\n      // Load sync status for all relationships\n      setRelationshipSync([]);\n      logger.debug(\"Loading relationship sync status\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load relationship sync status\", { error });\n    }\n  }, [userId]);\n\n  // ==================== MANUAL SYNC OPERATIONS ====================\n\n  const forceSyncAll = useCallback(async (): Promise<SyncResult> => {\n    try {\n      logger.debug(\"Starting force sync all\", { userId });\n\n      setSyncStatus({\n        state: \"syncing\",\n        lastSync: null,\n        progress: 0,\n        message: \"Starting synchronization...\",\n        error: null,\n      });\n\n      // Simulate sync process\n      for (let i = 0; i <= 100; i += 20) {\n        setSyncStatus((prev) => ({\n          ...prev,\n          progress: i,\n          message: `Syncing... ${i}%`,\n        }));\n        await new Promise((resolve) => setTimeout(resolve, 200));\n      }\n\n      const result: SyncResult = {\n        success: true,\n        operations: {\n          uploaded: 15,\n          downloaded: 8,\n          conflicts: 2,\n        },\n        conflicts: [],\n        timestamp: new Date(),\n      };\n\n      setSyncStatus({\n        state: \"completed\",\n        lastSync: new Date(),\n        progress: 100,\n        message: \"Sync completed successfully\",\n        error: null,\n      });\n\n      // Update metrics\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        successfulSyncs: prev.successfulSyncs + 1,\n        lastSuccessfulSync: new Date(),\n      }));\n\n      logger.info(\"Force sync completed successfully\", { result });\n      return result;\n    } catch (error) {\n      logger.error(\"Force sync failed\", { error });\n\n      setSyncStatus({\n        state: \"error\",\n        lastSync: null,\n        progress: 0,\n        message: \"Sync failed\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        failedSyncs: prev.failedSyncs + 1,\n      }));\n\n      throw error;\n    }\n  }, [userId]);\n\n  const syncRelationshipData = useCallback(\n    async (relationshipId: string): Promise<RelationshipSyncResult> => {\n      try {\n        logger.debug(\"Syncing relationship data\", { relationshipId });\n\n        const startTime = Date.now();\n\n        // Find relationship sync status\n        const relationshipStatus = relationshipSync.find(\n          (rs) => rs.relationshipId === relationshipId,\n        );\n        if (!relationshipStatus) {\n          throw new Error(\"Relationship not found\");\n        }\n\n        // Perform relationship-specific sync\n        const result: RelationshipSyncResult = {\n          relationshipId,\n          success: true,\n          syncedCollections: [\"sessions\", \"goals\", \"tasks\"],\n          conflictsFound: 1,\n          conflictsResolved: 0,\n          metrics: {\n            duration: Date.now() - startTime,\n            itemsSynced: 12,\n            bytesTransferred: 4096,\n          },\n        };\n\n        // Update relationship sync status\n        setRelationshipSync((prev) =>\n          prev.map((rs) =>\n            rs.relationshipId === relationshipId\n              ? { ...rs, lastSync: new Date() }\n              : rs,\n          ),\n        );\n\n        logger.info(\"Relationship sync completed\", { relationshipId, result });\n        return result;\n      } catch (error) {\n        logger.error(\"Relationship sync failed\", { error, relationshipId });\n\n        return {\n          relationshipId,\n          success: false,\n          syncedCollections: [],\n          conflictsFound: 0,\n          conflictsResolved: 0,\n          error: error instanceof Error ? error.message : \"Unknown error\",\n          metrics: {\n            duration: 0,\n            itemsSynced: 0,\n            bytesTransferred: 0,\n          },\n        };\n      }\n    },\n    [relationshipSync],\n  );\n\n  // ==================== PRIVACY AND PERMISSIONS ====================\n\n  const updateSyncPermissions = useCallback(\n    async (permissions: Partial<SyncPermissions>): Promise<void> => {\n      try {\n        logger.debug(\"Updating sync permissions\", { permissions });\n\n        const updatedPermissions = { ...syncPermissions, ...permissions };\n        setSyncPermissions(updatedPermissions);\n\n        // Update real-time sync based on new permissions\n        if (\n          updatedPermissions.allowRealTimeSync !==\n          syncPermissions.allowRealTimeSync\n        ) {\n          if (updatedPermissions.allowRealTimeSync) {\n            await initializeRealTimeSync();\n          } else {\n            setRealTimeSyncEnabled(false);\n          }\n        }\n\n        logger.info(\"Sync permissions updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update sync permissions\", { error });\n        throw error;\n      }\n    },\n    [syncPermissions, initializeRealTimeSync],\n  );\n\n  const configureSyncScope = useCallback(\n    async (scope: SyncScope): Promise<void> => {\n      try {\n        logger.debug(\"Configuring sync scope\", { scope });\n        // Configure what data gets synced\n        logger.info(\"Sync scope configured successfully\");\n      } catch (error) {\n        logger.error(\"Failed to configure sync scope\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== REAL-TIME SYNC ====================\n\n  const enableRealtimeSync = useCallback(\n    (entityTypes: DataEntityType[]): void => {\n      try {\n        logger.debug(\"Enabling realtime sync\", { entityTypes });\n        setRealTimeSyncEnabled(true);\n        // Set up WebSocket connections or other real-time mechanisms\n        logger.info(\"Realtime sync enabled successfully\");\n      } catch (error) {\n        logger.error(\"Failed to enable realtime sync\", { error });\n      }\n    },\n    [],\n  );\n\n  const disableRealtimeSync = useCallback((): void => {\n    try {\n      logger.debug(\"Disabling realtime sync\");\n      setRealTimeSyncEnabled(false);\n      // Clean up real-time connections\n      logger.info(\"Realtime sync disabled successfully\");\n    } catch (error) {\n      logger.error(\"Failed to disable realtime sync\", { error });\n    }\n  }, []);\n\n  // ==================== PRIVATE HELPER FUNCTIONS ====================\n\n  const initializeRealTimeSync = useCallback(async (): Promise<void> => {\n    try {\n      logger.debug(\"Initializing real-time sync\");\n      setRealTimeSyncEnabled(true);\n      // Set up WebSocket connections, event listeners, etc.\n    } catch (error) {\n      logger.error(\"Failed to initialize real-time sync\", { error });\n    }\n  }, []);\n\n  const performBackgroundSync = useCallback(async (): Promise<void> => {\n    try {\n      // Perform lightweight background sync\n      logger.debug(\"Performing background sync\");\n    } catch (error) {\n      logger.error(\"Background sync failed\", { error });\n    }\n  }, []);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Sync state\n    syncStatus,\n    relationshipSync,\n    conflicts,\n    syncMetrics,\n\n    // Manual sync operations\n    forceSyncAll,\n    syncRelationshipData,\n\n    // Conflict resolution (from useConflictResolution hook)\n    resolveConflict: conflictResolution.resolveConflict,\n    resolveAllConflicts: conflictResolution.resolveAllConflicts,\n\n    // Privacy and permissions\n    updateSyncPermissions,\n    configureSyncScope,\n\n    // Real-time sync\n    enableRealtimeSync,\n    disableRealtimeSync,\n\n    // Backup and recovery (from useSyncBackup hook)\n    createBackup: syncBackup.createBackup,\n    restoreFromBackup: syncBackup.restoreFromBackup,\n\n    // Monitoring (from useSyncMonitoring hook)\n    getSyncHealth: syncMonitoring.getSyncHealth,\n    getSyncHistory: syncMonitoring.getSyncHistory,\n\n    // Computed values\n    isSyncing,\n    hasConflicts,\n    syncQuality,\n    lastSuccessfulSync,\n    needsAttention,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (394). Maximum allowed is 150.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 546,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (33). Maximum allowed is 25.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 546,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievementStatistics', 'loadComparativeStatistics', 'loadGoalStatistics', 'loadPredictiveAnalytics', 'loadRecommendations', 'loadSessionStatistics', and 'loadSharedStatistics'. Either include them or remove the dependency array.",
        "line": 245,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 245,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]",
            "fix": {
              "range": [6726, 6750],
              "text": "[userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Comprehensive Statistics Hook\n * Provides analytics and insights for both users and keyholders\n * with appropriate privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateImprovementScore,\n  calculateConsistencyRating,\n  calculateOverallProgress,\n  calculateKeyholderSatisfaction,\n} from \"../../utils/statisticsHelpers\";\nimport {\n  getStatsForPeriod as calculateStatsForPeriod,\n  getMonthlyTrends as calculateMonthlyTrends,\n  getWeeklyBreakdown as calculateWeeklyBreakdown,\n  compareWithPrevious as compareMetricsWithPrevious,\n  getBenchmarkComparisons as calculateBenchmarkComparisons,\n} from \"../../utils/statistics/calculations\";\nimport {\n  generateKeyholderDashboard,\n  generateRelationshipComparison,\n} from \"../../utils/statistics/keyholder\";\nimport {\n  generatePredictiveInsights,\n  generateRecommendations,\n} from \"../../utils/statistics/predictions\";\n\nconst logger = serviceLogger(\"useStatistics\");\n\n// ==================== INTERFACES ====================\n\n// Re-export all types from the types file\nexport type * from \"./types/statistics\";\n\nimport type {\n  SessionStatistics,\n  GoalStatistics,\n  AchievementStatistics,\n  ComparativeStatistics,\n  SharedStatistics,\n  PredictiveAnalytics,\n  RecommendationEngine,\n  TimePeriod,\n  PeriodStatistics as _PeriodStatistics,\n  MonthlyTrends as _MonthlyTrends,\n  WeeklyBreakdown as _WeeklyBreakdown,\n  ComparisonResult as _ComparisonResult,\n  BenchmarkData as _BenchmarkData,\n  KeyholderDashboardStats as _KeyholderDashboardStats,\n  KeyholderStatisticsView,\n  RelationshipComparisonStats as _RelationshipComparisonStats,\n  PredictiveInsights as _PredictiveInsights,\n  Recommendation as _Recommendation,\n  StatisticsExport,\n  StatisticType,\n  ExportFormat,\n} from \"./types/statistics\";\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex statistics aggregation hook requires many statements for comprehensive metrics\n// eslint-disable-next-line max-statements\nexport const useStatistics = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessionStats, setSessionStats] = useState<SessionStatistics>({\n    totalSessionTime: 0,\n    averageSessionLength: 0,\n    longestSession: 0,\n    shortestSession: 0,\n    sessionsThisWeek: 0,\n    sessionsThisMonth: 0,\n    sessionFrequency: {\n      daily: 0,\n      weekly: 0,\n      monthly: 0,\n      trend: \"stable\",\n    },\n    completionRate: 0,\n    goalAchievementRate: 0,\n    satisfactionRating: 0,\n    trends: [],\n    streaks: {\n      current: 0,\n      longest: 0,\n      type: \"session_consistency\",\n    },\n  });\n\n  const [goalStats, setGoalStats] = useState<GoalStatistics>({\n    totalGoals: 0,\n    completedGoals: 0,\n    activeGoals: 0,\n    completionRate: 0,\n    averageCompletionTime: 0,\n    mostCommonGoalTypes: [],\n    hardestGoalTypes: [],\n    goalStreaks: {\n      current: 0,\n      longest: 0,\n      type: \"goal_completion\",\n    },\n  });\n\n  const [achievementStats, setAchievementStats] =\n    useState<AchievementStatistics>({\n      totalAchievements: 0,\n      recentAchievements: [],\n      achievementsByCategory: [],\n      rareAchievements: [],\n      achievementPoints: 0,\n      percentileRank: 0,\n    });\n\n  const [comparativeStats, setComparativeStats] =\n    useState<ComparativeStatistics>({\n      userPercentile: 50,\n      averageUserStats: sessionStats,\n      personalBest: {\n        longestSession: 0,\n        mostGoalsInSession: 0,\n        longestStreak: 0,\n        highestSatisfactionRating: 0,\n        bestMonth: {\n          month: \"\",\n          year: 0,\n          totalTime: 0,\n          sessionCount: 0,\n        },\n      },\n      improvements: {\n        sessionLength: { improvement: 0, timeframe: \"month\" },\n        consistency: { improvement: 0, timeframe: \"month\" },\n        goalCompletion: { improvement: 0, timeframe: \"month\" },\n      },\n    });\n\n  const [sharedStats, setSharedStats] = useState<SharedStatistics>({\n    allowedMetrics: [],\n    keyholderView: {\n      sessionOverview: {\n        totalSessions: 0,\n        averageDuration: 0,\n        lastSessionDate: new Date(),\n      },\n      goalProgress: {\n        activeGoals: 0,\n        completionRate: 0,\n      },\n      behaviorPatterns: {\n        consistency: 0,\n        pauseFrequency: 0,\n        improvementTrend: \"stable\",\n      },\n      allowedInsights: [],\n    },\n    lastSharedAt: new Date(),\n    sharingLevel: \"basic\",\n  });\n\n  const [_predictiveAnalytics, setPredictiveAnalytics] =\n    useState<PredictiveAnalytics>({\n      nextSessionPrediction: {\n        suggestedDuration: 0,\n        successProbability: 0,\n        optimalStartTime: new Date(),\n        riskFactors: [],\n      },\n      goalRecommendations: [],\n      improvementOpportunities: [],\n      trendPredictions: [],\n    });\n\n  const [_recommendations, setRecommendations] = useState<RecommendationEngine>(\n    {\n      sessionRecommendations: [],\n      goalRecommendations: [],\n      behaviorInsights: [],\n      personalizedTips: [],\n    },\n  );\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const improvementScore = useMemo(\n    () => calculateImprovementScore(sessionStats.trends),\n    [sessionStats.trends],\n  );\n\n  const consistencyRating = useMemo(\n    () => calculateConsistencyRating(sessionStats),\n    [sessionStats],\n  );\n\n  const overallProgress = useMemo(\n    () => calculateOverallProgress(goalStats),\n    [goalStats],\n  );\n\n  const keyholderSatisfaction = useMemo(\n    () => calculateKeyholderSatisfaction(sharedStats),\n    [sharedStats],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeStatistics = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load all statistics data\n        await Promise.all([\n          loadSessionStatistics(),\n          loadGoalStatistics(),\n          loadAchievementStatistics(),\n          loadComparativeStatistics(),\n          loadSharedStatistics(),\n          loadPredictiveAnalytics(),\n          loadRecommendations(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize statistics\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize statistics\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeStatistics();\n    // Callback functions are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessionStatistics = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Calculate session statistics from historical data\n      const mockStats: SessionStatistics = {\n        totalSessionTime: 7200, // 2 hours\n        averageSessionLength: 3600, // 1 hour\n        longestSession: 7200,\n        shortestSession: 1800,\n        sessionsThisWeek: 3,\n        sessionsThisMonth: 12,\n        sessionFrequency: {\n          daily: 0.4,\n          weekly: 3,\n          monthly: 12,\n          trend: \"stable\",\n        },\n        completionRate: 85,\n        goalAchievementRate: 75,\n        satisfactionRating: 4.2,\n        trends: [],\n        streaks: {\n          current: 5,\n          longest: 12,\n          type: \"session_consistency\",\n        },\n      };\n\n      setSessionStats(mockStats);\n    } catch (error) {\n      logger.error(\"Failed to load session statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadGoalStatistics = useCallback(async () => {\n    try {\n      // Calculate goal statistics from historical goal data\n      setGoalStats({\n        totalGoals: 25,\n        completedGoals: 20,\n        activeGoals: 3,\n        completionRate: 80,\n        averageCompletionTime: 48, // hours\n        mostCommonGoalTypes: [],\n        hardestGoalTypes: [],\n        goalStreaks: {\n          current: 3,\n          longest: 8,\n          type: \"goal_completion\",\n        },\n      });\n    } catch (error) {\n      logger.error(\"Failed to load goal statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadAchievementStatistics = useCallback(async () => {\n    try {\n      // Load achievement data\n      setAchievementStats({\n        totalAchievements: 15,\n        recentAchievements: [],\n        achievementsByCategory: [],\n        rareAchievements: [],\n        achievementPoints: 1500,\n        percentileRank: 75,\n      });\n    } catch (error) {\n      logger.error(\"Failed to load achievement statistics\", { error });\n    }\n  }, []);\n\n  const loadComparativeStatistics = useCallback(async () => {\n    try {\n      // Load comparative data (anonymized benchmarks)\n      setComparativeStats((prev) => ({\n        ...prev,\n        userPercentile: 72,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load comparative statistics\", { error });\n    }\n  }, []); // sessionStats not actually used for computation\n\n  const loadSharedStatistics = useCallback(async () => {\n    try {\n      if (!relationshipId) return;\n\n      // Load keyholder-specific statistics view\n      const keyholderView: KeyholderStatisticsView = {\n        sessionOverview: {\n          totalSessions: sessionStats.sessionsThisMonth,\n          averageDuration: sessionStats.averageSessionLength,\n          lastSessionDate: new Date(),\n        },\n        goalProgress: {\n          activeGoals: goalStats.activeGoals,\n          completionRate: goalStats.completionRate,\n        },\n        behaviorPatterns: {\n          consistency: consistencyRating,\n          pauseFrequency: 0.2,\n          improvementTrend: \"improving\",\n        },\n        allowedInsights: [\"session_duration\", \"goal_completion\"],\n      };\n\n      setSharedStats((prev) => ({\n        ...prev,\n        keyholderView,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load shared statistics\", { error });\n    }\n  }, [\n    relationshipId,\n    consistencyRating,\n    sessionStats.sessionsThisMonth,\n    sessionStats.averageSessionLength,\n    goalStats.activeGoals,\n    goalStats.completionRate,\n  ]);\n\n  const loadPredictiveAnalytics = useCallback(async () => {\n    try {\n      // Generate predictive insights based on historical data\n      setPredictiveAnalytics({\n        nextSessionPrediction: {\n          suggestedDuration: sessionStats.averageSessionLength * 1.1,\n          successProbability: 85,\n          optimalStartTime: new Date(),\n          riskFactors: [],\n        },\n        goalRecommendations: [],\n        improvementOpportunities: [],\n        trendPredictions: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load predictive analytics\", { error });\n    }\n  }, [sessionStats.averageSessionLength]);\n\n  const loadRecommendations = useCallback(async () => {\n    try {\n      // Generate personalized recommendations\n      setRecommendations({\n        sessionRecommendations: [],\n        goalRecommendations: [],\n        behaviorInsights: [],\n        personalizedTips: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load recommendations\", { error });\n    }\n  }, []); // Static data for recommendations\n\n  // ==================== TIME-BASED QUERIES ====================\n\n  const getStatsForPeriod = useCallback(\n    (period: TimePeriod) => calculateStatsForPeriod(period),\n    [],\n  );\n\n  const getMonthlyTrends = useCallback(\n    (months: number) => calculateMonthlyTrends(months),\n    [],\n  );\n\n  const getWeeklyBreakdown = useCallback(() => calculateWeeklyBreakdown(), []);\n\n  // ==================== COMPARATIVE ANALYSIS ====================\n\n  const compareWithPrevious = useCallback(\n    (period: TimePeriod) => compareMetricsWithPrevious(period, sessionStats),\n    [sessionStats],\n  );\n\n  const getBenchmarkComparisons = useCallback(\n    () => calculateBenchmarkComparisons(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== KEYHOLDER FEATURES ====================\n\n  const getKeyholderDashboard = useCallback(\n    () =>\n      generateKeyholderDashboard(consistencyRating, sessionStats, goalStats),\n    [consistencyRating, sessionStats, goalStats],\n  );\n\n  const getRelationshipComparison = useCallback(\n    () => generateRelationshipComparison(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== PREDICTIVE ANALYTICS ====================\n\n  const getPredictiveInsights = useCallback(\n    () => generatePredictiveInsights(),\n    [],\n  );\n\n  const getRecommendations = useCallback(() => generateRecommendations(), []);\n\n  // ==================== EXPORT AND SHARING ====================\n\n  const exportStatistics = useCallback(\n    async (format: ExportFormat): Promise<StatisticsExport> => {\n      try {\n        logger.debug(\"Exporting statistics\", { format, userId });\n\n        const exportData = {\n          sessionStats,\n          goalStats,\n          achievementStats,\n          exportedAt: new Date(),\n        };\n\n        return {\n          format,\n          data: exportData,\n          generatedAt: new Date(),\n          fileSize: JSON.stringify(exportData).length,\n          downloadUrl: \"https://example.com/download/stats\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to export statistics\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionStats, goalStats, achievementStats],\n  );\n\n  const shareWithKeyholder = useCallback(\n    async (statTypes: StatisticType[]): Promise<void> => {\n      try {\n        if (!relationshipId) {\n          throw new Error(\"No keyholder relationship found\");\n        }\n\n        logger.debug(\"Sharing statistics with keyholder\", { statTypes });\n\n        setSharedStats((prev) => ({\n          ...prev,\n          allowedMetrics: statTypes,\n          lastSharedAt: new Date(),\n        }));\n\n        logger.info(\"Statistics shared with keyholder successfully\");\n      } catch (error) {\n        logger.error(\"Failed to share statistics with keyholder\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Statistics\n    sessionStats,\n    goalStats,\n    achievementStats,\n    comparativeStats,\n\n    // Time-based queries\n    getStatsForPeriod,\n    getMonthlyTrends,\n    getWeeklyBreakdown,\n\n    // Comparative analysis\n    compareWithPrevious,\n    getBenchmarkComparisons,\n\n    // Keyholder features\n    getKeyholderDashboard,\n    getRelationshipComparison,\n\n    // Predictive analytics\n    getPredictiveInsights,\n    getRecommendations,\n\n    // Export and sharing\n    exportStatistics,\n    shareWithKeyholder,\n\n    // Computed values\n    improvementScore,\n    consistencyRating,\n    overallProgress,\n    keyholderSatisfaction,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncBackup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncMonitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/types/Goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useAccountSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useDisplaySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGameification.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (376). Maximum allowed is 150.",
        "line": 46,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 517,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 46,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 517,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGameification Hook - Enhanced Gamification System\n *\n * Comprehensive gamification system beyond basic achievements, including challenges,\n * leaderboards, seasons, and social features.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  PlayerProfile,\n  Challenge,\n  Leaderboard,\n  Season,\n  SocialGameFeatures,\n  Badge as _Badge,\n  ExperienceSource,\n  LevelResult,\n  LevelUpResult,\n  ChallengeCompletion,\n  LeaderboardRank,\n  FriendComparison,\n  SeasonalReward,\n  ExperienceEvent,\n} from \"../../types/gamification\";\nimport { logger } from \"../../utils/logging\";\nimport { GamificationStorageService } from \"../../services/gamificationStorage\";\nimport {\n  DEFAULT_PLAYER_PROFILE,\n  LEVEL_THRESHOLDS,\n  SAMPLE_CHALLENGES,\n} from \"../../constants/gamification\";\nimport {\n  generateSampleLeaderboards,\n  generateSeasonalRewards,\n  createBadgeFromReward,\n  generateLevelRewards,\n  getPlayerTitle,\n  getUnlockedFeatures,\n} from \"@/utils/gamification\";\n\n/**\n * Enhanced Gamification Hook\n * Complex gamification logic with multiple queries, mutations, and game mechanics\n */\nexport const useGameification = (userId: string) => {\n  const queryClient = useQueryClient();\n\n  // Get player profile\n  const { data: playerProfile = DEFAULT_PLAYER_PROFILE } =\n    useQuery<PlayerProfile>({\n      queryKey: [\"gamification\", \"profile\", userId],\n      queryFn: () => {\n        const stored =\n          GamificationStorageService.getPlayerProfile<PlayerProfile>();\n        return stored\n          ? { ...DEFAULT_PLAYER_PROFILE, ...stored }\n          : DEFAULT_PLAYER_PROFILE;\n      },\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000,\n    });\n\n  // Get active challenges\n  const { data: activeChallenges = [] } = useQuery<Challenge[]>({\n    queryKey: [\"gamification\", \"challenges\", userId],\n    queryFn: () => {\n      const userChallenges =\n        GamificationStorageService.getChallenges<Challenge>();\n      return [...SAMPLE_CHALLENGES, ...userChallenges].filter(\n        (c) => !c.isCompleted,\n      );\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get leaderboards\n  const { data: leaderboards = [] } = useQuery<Leaderboard[]>({\n    queryKey: [\"gamification\", \"leaderboards\"],\n    queryFn: async () => {\n      // Simulate leaderboard data\n      return generateSampleLeaderboards();\n    },\n    staleTime: 5 * 60 * 1000,\n    refetchInterval: 10 * 60 * 1000,\n  });\n\n  // Get current season\n  const { data: currentSeason } = useQuery<Season | null>({\n    queryKey: [\"gamification\", \"season\"],\n    queryFn: () => {\n      return {\n        id: \"season-winter-2024\",\n        name: \"Winter Challenge 2024\",\n        description:\n          \"Embrace the cold season with special winter-themed challenges\",\n        theme: \"winter\",\n        startDate: new Date(\"2024-12-01\"),\n        endDate: new Date(\"2024-02-28\"),\n        rewards: generateSeasonalRewards(),\n        challenges: [\"winter-endurance\", \"cold-discipline\"],\n        leaderboards: [\"winter-champions\"],\n        isActive: true,\n      };\n    },\n    staleTime: 60 * 60 * 1000, // 1 hour\n  });\n\n  // Get social features\n  const { data: socialFeatures } = useQuery<SocialGameFeatures>({\n    queryKey: [\"gamification\", \"social\", userId],\n    queryFn: () => {\n      const stored =\n        GamificationStorageService.getSocialFeatures<SocialGameFeatures>();\n      return stored\n        ? stored\n        : {\n            friends: [],\n            pendingRequests: [],\n            recentActivity: [],\n            groups: [],\n            comparisons: [],\n          };\n    },\n    enabled: Boolean(userId) && playerProfile.preferences.allowSocialFeatures,\n    staleTime: 2 * 60 * 1000,\n  });\n\n  // Get experience history\n  const { data: experienceHistory = [] } = useQuery<ExperienceEvent[]>({\n    queryKey: [\"gamification\", \"experience\", userId],\n    queryFn: () => {\n      return GamificationStorageService.getExperienceHistory<ExperienceEvent>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Accept challenge mutation\n  const acceptChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge accepted\", { challengeId, userId });\n\n      // In a real implementation, this would register the user for the challenge\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Complete challenge mutation\n  const completeChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string): Promise<ChallengeCompletion> => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge completed\", { challengeId, userId });\n\n      // Mark challenge as completed\n      const updatedChallenges = activeChallenges.map((c) =>\n        c.id === challengeId\n          ? {\n              ...c,\n              isCompleted: true,\n              progress: { ...c.progress, percentage: 100 },\n            }\n          : c,\n      );\n      GamificationStorageService.setChallenges(updatedChallenges);\n\n      // Calculate rewards\n      const experienceGained = challenge.rewards.reduce(\n        (total, reward) =>\n          reward.type === \"experience\" ? total + reward.value : total,\n        0,\n      );\n\n      // Add experience\n      const levelResult = await addExperienceInternal(\n        experienceGained,\n        ExperienceSource.CHALLENGE_COMPLETE,\n      );\n\n      // Create completion result\n      const completion: ChallengeCompletion = {\n        challengeId,\n        completedAt: new Date(),\n        rewards: challenge.rewards,\n        experience: experienceGained,\n        newBadges: challenge.rewards\n          .filter((r) => r.type === \"badge\")\n          .map((r) => createBadgeFromReward(r)),\n        levelUp: levelResult.leveledUp\n          ? {\n              newLevel: levelResult.newLevel,\n              rewards: [],\n              unlockedFeatures: [],\n            }\n          : undefined,\n      };\n\n      // Update stats\n      const updatedProfile = {\n        ...playerProfile,\n        stats: {\n          ...playerProfile.stats,\n          challengesCompleted: playerProfile.stats.challengesCompleted + 1,\n          totalExperience:\n            playerProfile.stats.totalExperience + experienceGained,\n        },\n      };\n      GamificationStorageService.setPlayerProfile(updatedProfile);\n      queryClient.setQueryData(\n        [\"gamification\", \"profile\", userId],\n        updatedProfile,\n      );\n\n      return completion;\n    },\n  });\n\n  // Add experience mutation\n  const addExperienceMutation = useMutation({\n    mutationFn: async ({\n      amount,\n      source,\n    }: {\n      amount: number;\n      source: ExperienceSource;\n    }): Promise<LevelResult> => {\n      return addExperienceInternal(amount, source);\n    },\n  });\n\n  // Internal add experience function\n  const addExperienceInternal = async (\n    amount: number,\n    source: ExperienceSource,\n  ): Promise<LevelResult> => {\n    const oldLevel = playerProfile.level;\n    const newExperience = playerProfile.experience + amount;\n\n    // Calculate new level\n    let newLevel = oldLevel;\n    for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {\n      if (newExperience >= LEVEL_THRESHOLDS[i]) {\n        newLevel = i + 1;\n      } else {\n        break;\n      }\n    }\n\n    const experienceToNext =\n      newLevel < LEVEL_THRESHOLDS.length\n        ? LEVEL_THRESHOLDS[newLevel] - newExperience\n        : 0;\n\n    // Create experience event\n    const experienceEvent: ExperienceEvent = {\n      id: `exp-${Date.now()}`,\n      source,\n      amount,\n      description: `Gained ${amount} XP from ${source}`,\n      timestamp: new Date(),\n    };\n\n    // Update experience history\n    const updatedHistory = [experienceEvent, ...experienceHistory].slice(\n      0,\n      100,\n    );\n    GamificationStorageService.setExperienceHistory(updatedHistory);\n    queryClient.setQueryData(\n      [\"gamification\", \"experience\", userId],\n      updatedHistory,\n    );\n\n    // Update profile\n    const updatedProfile = {\n      ...playerProfile,\n      level: newLevel,\n      experience: newExperience,\n      experienceToNext,\n      stats: {\n        ...playerProfile.stats,\n        totalExperience: playerProfile.stats.totalExperience + amount,\n      },\n      lastActive: new Date(),\n    };\n\n    GamificationStorageService.setPlayerProfile(updatedProfile);\n    queryClient.setQueryData(\n      [\"gamification\", \"profile\", userId],\n      updatedProfile,\n    );\n\n    logger.info(\"Experience added\", {\n      amount,\n      source,\n      oldLevel,\n      newLevel,\n      userId,\n    });\n\n    return {\n      leveledUp: newLevel > oldLevel,\n      oldLevel,\n      newLevel,\n      experience: amount,\n    };\n  };\n\n  // Check level up\n  const checkLevelUp = useCallback(async (): Promise<LevelUpResult | null> => {\n    const _currentLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level - 1] || 0;\n    const nextLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level] || Infinity;\n\n    if (playerProfile.experience >= nextLevelThreshold) {\n      const newLevel = playerProfile.level + 1;\n      const rewards = generateLevelRewards(newLevel);\n\n      return {\n        newLevel,\n        rewards,\n        newTitle: getPlayerTitle(newLevel),\n        unlockedFeatures: getUnlockedFeatures(newLevel),\n      };\n    }\n\n    return null;\n  }, [playerProfile]);\n\n  // Get leaderboard rank\n  const getLeaderboardRank = useCallback(\n    async (leaderboardId: string): Promise<LeaderboardRank> => {\n      const leaderboard = leaderboards.find((l) => l.id === leaderboardId);\n      if (!leaderboard) throw new Error(\"Leaderboard not found\");\n\n      // Find user's rank (simulated)\n      const userRank =\n        Math.floor(Math.random() * leaderboard.totalParticipants) + 1;\n      const percentile =\n        ((leaderboard.totalParticipants - userRank) /\n          leaderboard.totalParticipants) *\n        100;\n\n      return {\n        category: leaderboard.category,\n        period: leaderboard.period,\n        rank: userRank,\n        totalParticipants: leaderboard.totalParticipants,\n        percentile,\n        value: playerProfile.stats.totalExperience,\n      };\n    },\n    [leaderboards, playerProfile],\n  );\n\n  // Compare with friends\n  const compareWithFriends = useCallback(async (): Promise<\n    FriendComparison[]\n  > => {\n    if (!socialFeatures?.friends) return [];\n\n    return socialFeatures.friends.map((friend) => ({\n      friendId: friend.userId,\n      friendName: friend.displayName,\n      categories: [\n        {\n          category: \"Level\",\n          playerValue: playerProfile.level,\n          friendValue: friend.level,\n          difference: playerProfile.level - friend.level,\n          status:\n            playerProfile.level > friend.level\n              ? \"ahead\"\n              : playerProfile.level < friend.level\n                ? \"behind\"\n                : \"tied\",\n        },\n        {\n          category: \"Experience\",\n          playerValue: playerProfile.experience,\n          friendValue: Math.floor(Math.random() * 10000),\n          difference: 0,\n          status: \"tied\",\n        },\n      ],\n      overallComparison: \"ahead\",\n    }));\n  }, [socialFeatures, playerProfile]);\n\n  // Send challenge to friend\n  const sendChallenge = useCallback(\n    async (friendId: string, challengeId: string) => {\n      logger.info(\"Challenge sent to friend\", {\n        friendId,\n        challengeId,\n        userId,\n      });\n      // In a real implementation, this would create a challenge invitation\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Get seasonal rewards\n  const getSeasonalRewards = useCallback(async (): Promise<\n    SeasonalReward[]\n  > => {\n    return currentSeason?.rewards || [];\n  }, [currentSeason]);\n\n  // Claim seasonal reward\n  const claimSeasonalReward = useCallback(\n    async (rewardId: string) => {\n      logger.info(\"Seasonal reward claimed\", { rewardId, userId });\n      // In a real implementation, this would claim the reward and update user data\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Computed properties\n  const currentLevel = playerProfile.level;\n  const progressToNext =\n    playerProfile.experienceToNext > 0\n      ? ((playerProfile.experience -\n          (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0)) /\n          ((LEVEL_THRESHOLDS[playerProfile.level] ||\n            playerProfile.experienceToNext) -\n            (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0))) *\n        100\n      : 100;\n\n  const activeChallengeCount = activeChallenges.length;\n  const completedChallengesThisWeek = playerProfile.stats.challengesCompleted; // Simplified\n\n  const rank =\n    leaderboards.length > 0\n      ? leaderboards[0].entries.findIndex((e) => e.userId === userId) + 1 || 0\n      : 0;\n\n  const hasUnclaimedRewards =\n    currentSeason?.rewards.some((r) => !r.claimed) || false;\n\n  return {\n    // Player state\n    playerProfile,\n    activeChallenges,\n    leaderboards,\n    currentSeason,\n    socialFeatures,\n    experienceHistory,\n\n    // Challenge management\n    acceptChallenge: acceptChallengeMutation.mutate,\n    completeChallenge: completeChallengeMutation.mutate,\n    getChallengeProgress: (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      return challenge?.progress;\n    },\n\n    // Experience and leveling\n    addExperience: addExperienceMutation.mutate,\n    checkLevelUp,\n\n    // Leaderboard features\n    getLeaderboardRank,\n    joinLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Joined leaderboard\", { leaderboardId, userId });\n    },\n    leaveLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Left leaderboard\", { leaderboardId, userId });\n    },\n\n    // Social features\n    compareWithFriends,\n    sendChallenge,\n\n    // Seasonal events\n    getSeasonalRewards,\n    claimSeasonalReward,\n\n    // Loading states\n    isAcceptingChallenge: acceptChallengeMutation.isPending,\n    isCompletingChallenge: completeChallengeMutation.isPending,\n    isAddingExperience: addExperienceMutation.isPending,\n\n    // Results\n    lastChallengeCompletion: completeChallengeMutation.data,\n    lastLevelResult: addExperienceMutation.data,\n\n    // Computed properties\n    currentLevel,\n    progressToNext,\n    activeChallengeCount,\n    completedChallengesThisWeek,\n    rank,\n    hasUnclaimedRewards,\n\n    // Quick stats\n    totalExperience: playerProfile.stats.totalExperience,\n    totalBadges: playerProfile.badges.length,\n    currentStreak: playerProfile.stats.currentStreak,\n\n    // Errors\n    error:\n      acceptChallengeMutation.error ||\n      completeChallengeMutation.error ||\n      addExperienceMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGoals.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (451). Maximum allowed is 150.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (26). Maximum allowed is 25.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGoals Hook - Enhanced Goal System\n *\n * Advanced goal system with AI recommendations, collaborative goals, and\n * comprehensive progress analytics.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  EnhancedGoal,\n  CollaborativeGoal,\n  GoalRecommendation,\n  GoalAnalytics,\n  GoalTemplate,\n  CreateGoalRequest,\n  GoalUpdate,\n  OptimizedGoalPlan,\n  CollaborationInvite,\n  GoalInsights,\n  GoalPredictions,\n  CompletionTrends,\n  GoalType,\n  GoalCategory,\n  GoalDifficulty,\n  GoalStatus,\n} from \"../../types/goals\";\nimport { logger } from \"../../utils/logging\";\nimport {\n  getGoalInsights,\n  getPredictiveAnalytics as getPredictiveAnalyticsHelper,\n  getCompletionTrends as getCompletionTrendsHelper,\n} from \"../../utils/goalsHelpers\";\nimport { GoalStorageService } from \"../../services/goalStorage\";\n\n// Enhanced goal state\n\nimport type * as _Types from \"./types/Goals\";\nexport type * from \"./types/Goals\";\nimport { DEFAULT_TEMPLATES } from \"@/utils/goals/common\";\n\n// Complex goal management hook with multiple goal types and collaborative features\n// eslint-disable-next-line max-statements\nexport const useGoals = (userId?: string, relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get personal goals\n  const { data: personalGoals = [] } = useQuery<EnhancedGoal[]>({\n    queryKey: [\"goals\", \"personal\", userId],\n    queryFn: () => {\n      return GoalStorageService.getPersonalGoals<EnhancedGoal>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get collaborative goals\n  const { data: collaborativeGoals = [] } = useQuery<CollaborativeGoal[]>({\n    queryKey: [\"goals\", \"collaborative\", userId, relationshipId],\n    queryFn: () => {\n      return GoalStorageService.getCollaborativeGoals<CollaborativeGoal>();\n    },\n    enabled: Boolean(userId) && Boolean(relationshipId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get goal templates\n  const { data: goalTemplates = DEFAULT_TEMPLATES } = useQuery<GoalTemplate[]>({\n    queryKey: [\"goals\", \"templates\"],\n    queryFn: () => {\n      const stored = GoalStorageService.getGoalTemplates<GoalTemplate>();\n      return stored.length > 0\n        ? [...DEFAULT_TEMPLATES, ...stored]\n        : DEFAULT_TEMPLATES;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get AI recommendations\n  const { data: recommendedGoals = [] } = useQuery<GoalRecommendation[]>({\n    queryKey: [\"goals\", \"recommendations\", userId],\n    queryFn: async () => {\n      // Simulate AI recommendation generation\n      await new Promise((resolve) => setTimeout(resolve, 800));\n\n      return generateSmartRecommendations(personalGoals, collaborativeGoals);\n    },\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    refetchInterval: 30 * 60 * 1000, // 30 minutes\n  });\n\n  // Get goal analytics\n  const { data: goalAnalytics } = useQuery<GoalAnalytics>({\n    queryKey: [\"goals\", \"analytics\", userId],\n    queryFn: () => calculateGoalAnalytics(personalGoals, collaborativeGoals),\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Create goal mutation\n  const createGoalMutation = useMutation({\n    mutationFn: async (request: CreateGoalRequest) => {\n      const newGoal: EnhancedGoal = {\n        id: `goal-${Date.now()}`,\n        type: request.type,\n        category: request.category,\n        title: request.title,\n        description: request.description,\n        target: request.target,\n        progress: {\n          current: 0,\n          target: request.target.value,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones:\n            request.milestones?.map((m) => ({\n              ...m,\n              id: `milestone-${Date.now()}-${Math.random()}`,\n              achieved: false,\n            })) || [],\n          lastUpdated: new Date(),\n        },\n        milestones:\n          request.milestones?.map((m) => ({\n            ...m,\n            id: `milestone-${Date.now()}-${Math.random()}`,\n            achieved: false,\n          })) || [],\n        aiGenerated: false,\n        difficulty: request.difficulty,\n        estimatedCompletion: calculateEstimatedCompletion(\n          request.difficulty,\n          request.target,\n        ),\n        createdAt: new Date(),\n        tags: request.tags || [],\n        isPublic: request.isPublic || false,\n      };\n\n      const updated = [...personalGoals, newGoal];\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal created\", { goalId: newGoal.id, title: newGoal.title });\n      return newGoal;\n    },\n  });\n\n  // Update goal mutation\n  const updateGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      updates,\n    }: {\n      goalId: string;\n      updates: GoalUpdate;\n    }) => {\n      const goalIndex = personalGoals.findIndex((g) => g.id === goalId);\n      if (goalIndex === -1) throw new Error(\"Goal not found\");\n\n      const updatedGoal = {\n        ...personalGoals[goalIndex],\n        ...updates,\n      } as EnhancedGoal;\n      const updated = [...personalGoals];\n      updated[goalIndex] = updatedGoal;\n\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal updated\", { goalId, updates });\n      return updatedGoal;\n    },\n  });\n\n  // Delete goal mutation\n  const deleteGoalMutation = useMutation({\n    mutationFn: async (goalId: string) => {\n      const updated = personalGoals.filter((g) => g.id !== goalId);\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal deleted\", { goalId });\n    },\n  });\n\n  // Generate goal from prompt mutation\n  const generateGoalFromPromptMutation = useMutation({\n    mutationFn: async (prompt: string) => {\n      logger.info(\"Generating goal from prompt\", { prompt });\n\n      // Simulate AI processing\n      await new Promise((resolve) => setTimeout(resolve, 1500));\n\n      const aiGoal: EnhancedGoal = {\n        id: `ai-goal-${Date.now()}`,\n        type: GoalType.DURATION,\n        category: GoalCategory.CHASTITY,\n        title: \"AI-Generated Chastity Goal\",\n        description: `Generated from: \"${prompt}\"`,\n        target: {\n          type: \"duration\",\n          value: 14,\n          unit: \"days\",\n          description: \"14 days of commitment\",\n        },\n        progress: {\n          current: 0,\n          target: 14,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones: [],\n          lastUpdated: new Date(),\n        },\n        milestones: [\n          {\n            id: \"ai-milestone-1\",\n            name: \"First Week\",\n            description: \"Complete 7 days\",\n            target: 7,\n            achieved: false,\n          },\n          {\n            id: \"ai-milestone-2\",\n            name: \"Final Goal\",\n            description: \"Complete 14 days\",\n            target: 14,\n            achieved: false,\n          },\n        ],\n        aiGenerated: true,\n        difficulty: GoalDifficulty.MEDIUM,\n        estimatedCompletion: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n        createdAt: new Date(),\n        tags: [\"ai-generated\"],\n        isPublic: false,\n      };\n\n      return aiGoal;\n    },\n  });\n\n  // Optimize goal plan mutation\n  const optimizeGoalPlanMutation = useMutation({\n    mutationFn: async (goalIds: string[]) => {\n      const goalsToOptimize = personalGoals.filter((g) =>\n        goalIds.includes(g.id),\n      );\n\n      // Simulate optimization processing\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      const optimizedPlan: OptimizedGoalPlan = {\n        goals: goalsToOptimize,\n        timeline: generateTimeline(goalsToOptimize),\n        conflicts: detectConflicts(goalsToOptimize),\n        recommendations: generatePlanRecommendations(goalsToOptimize),\n        estimatedCompletion: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days\n      };\n\n      return optimizedPlan;\n    },\n  });\n\n  // Share goal mutation\n  const shareGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      logger.info(\"Sharing goal\", { goalId, targetUserId });\n      // In a real implementation, this would create a sharing record\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Invite collaborator mutation\n  const inviteCollaboratorMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      const invite: CollaborationInvite = {\n        id: `invite-${Date.now()}`,\n        goalId,\n        inviterId: userId!,\n        inviteeId: targetUserId,\n        permissions: {\n          canEdit: false,\n          canDelete: false,\n          canInviteOthers: false,\n          canViewProgress: true,\n          canAddMilestones: false,\n        },\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        status: \"pending\",\n      };\n\n      logger.info(\"Collaboration invite sent\", {\n        inviteId: invite.id,\n        goalId,\n        targetUserId,\n      });\n      return invite;\n    },\n  });\n\n  // Helper functions\n  const generateSmartRecommendations = (\n    personal: EnhancedGoal[],\n    _collaborative: CollaborativeGoal[],\n  ): GoalRecommendation[] => {\n    const recommendations: GoalRecommendation[] = [];\n\n    // Analyze completed goals to suggest similar ones\n    const completedGoals = personal.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const activeCategories = new Set(personal.map((g) => g.category));\n\n    // Suggest goals in successful categories\n    completedGoals.forEach((goal) => {\n      if (Math.random() > 0.7) {\n        // 30% chance to recommend\n        recommendations.push({\n          id: `rec-${Date.now()}-${Math.random()}`,\n          type: goal.type,\n          category: goal.category,\n          title: `Advanced ${goal.category} Challenge`,\n          description: `Based on your success with \"${goal.title}\"`,\n          difficulty:\n            goal.difficulty === GoalDifficulty.EASY\n              ? GoalDifficulty.MEDIUM\n              : GoalDifficulty.HARD,\n          estimatedDuration: 30,\n          reasoning: `You successfully completed similar goals in the ${goal.category} category`,\n          confidence: 0.8,\n          similarGoals: [goal.id],\n          successRate: 0.75,\n        });\n      }\n    });\n\n    // Suggest unexplored categories\n    const allCategories = Object.values(GoalCategory);\n    const unexploredCategories = allCategories.filter(\n      (cat) => !activeCategories.has(cat),\n    );\n\n    unexploredCategories.forEach((category) => {\n      if (Math.random() > 0.8) {\n        // 20% chance\n        recommendations.push({\n          id: `exp-${Date.now()}-${Math.random()}`,\n          type: GoalType.MILESTONE,\n          category,\n          title: `Explore ${category}`,\n          description: `Try something new in the ${category} category`,\n          difficulty: GoalDifficulty.EASY,\n          estimatedDuration: 14,\n          reasoning: `Diversifying goal categories can improve overall success`,\n          confidence: 0.6,\n          similarGoals: [],\n          successRate: 0.65,\n        });\n      }\n    });\n\n    return recommendations.slice(0, 5); // Limit to 5 recommendations\n  };\n\n  const calculateGoalAnalytics = (\n    personal: EnhancedGoal[],\n    collaborative: CollaborativeGoal[],\n  ): GoalAnalytics => {\n    const allGoals = [...personal, ...collaborative];\n    const completed = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const active = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    );\n\n    const categoryDistribution = Object.values(GoalCategory).reduce(\n      (acc, cat) => {\n        acc[cat] = allGoals.filter((g) => g.category === cat).length;\n        return acc;\n      },\n      {} as Record<GoalCategory, number>,\n    );\n\n    const difficultyDistribution = Object.values(GoalDifficulty).reduce(\n      (acc, diff) => {\n        acc[diff] = allGoals.filter((g) => g.difficulty === diff).length;\n        return acc;\n      },\n      {} as Record<GoalDifficulty, number>,\n    );\n\n    return {\n      totalGoals: allGoals.length,\n      completedGoals: completed.length,\n      activeGoals: active.length,\n      completionRate:\n        allGoals.length > 0 ? (completed.length / allGoals.length) * 100 : 0,\n      averageCompletionTime: calculateAverageCompletionTime(completed),\n      categoryDistribution,\n      difficultyDistribution,\n      monthlyProgress: generateMonthlyProgress(allGoals),\n      streaks: calculateStreaks(completed),\n    };\n  };\n\n  const calculateEstimatedCompletion = (\n    difficulty: GoalDifficulty,\n    target: { value?: number; unit?: string },\n  ): Date => {\n    const baseDays = target.value || 30;\n    const multiplier = {\n      [GoalDifficulty.EASY]: 1,\n      [GoalDifficulty.MEDIUM]: 1.5,\n      [GoalDifficulty.HARD]: 2,\n      [GoalDifficulty.EXTREME]: 3,\n    };\n\n    return new Date(\n      Date.now() + baseDays * multiplier[difficulty] * 24 * 60 * 60 * 1000,\n    );\n  };\n\n  const calculateAverageCompletionTime = (\n    completed: EnhancedGoal[],\n  ): number => {\n    if (completed.length === 0) return 0;\n\n    const totalDays = completed.reduce((acc, goal) => {\n      if (goal.completedAt && goal.startedAt) {\n        return (\n          acc +\n          (goal.completedAt.getTime() - goal.startedAt.getTime()) /\n            (24 * 60 * 60 * 1000)\n        );\n      }\n      return acc;\n    }, 0);\n\n    return totalDays / completed.length;\n  };\n\n  const generateMonthlyProgress = (_goals: EnhancedGoal[]) => {\n    // Simplified monthly progress calculation\n    return Array.from({ length: 6 }, (_, i) => ({\n      month: new Date(\n        Date.now() - i * 30 * 24 * 60 * 60 * 1000,\n      ).toLocaleDateString(\"en-US\", { month: \"short\" }),\n      goalsStarted: Math.floor(Math.random() * 5),\n      goalsCompleted: Math.floor(Math.random() * 3),\n      totalProgress: Math.floor(Math.random() * 100),\n    }));\n  };\n\n  const calculateStreaks = (_completed: EnhancedGoal[]) => {\n    return Object.values(GoalCategory).map((category) => ({\n      category,\n      currentStreak: Math.floor(Math.random() * 10),\n      longestStreak: Math.floor(Math.random() * 20),\n      lastGoalCompleted: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n    }));\n  };\n\n  const generateTimeline = (goals: EnhancedGoal[]) => {\n    return goals.map((goal) => ({\n      date: goal.estimatedCompletion,\n      goals: [goal.id],\n      milestones: goal.milestones.map((m) => m.id),\n      estimatedEffort: 4, // hours\n    }));\n  };\n\n  const detectConflicts = (_goals: EnhancedGoal[]) => {\n    // Simplified conflict detection\n    return [];\n  };\n\n  const generatePlanRecommendations = (_goals: EnhancedGoal[]) => {\n    return [\n      {\n        type: \"reorder\" as const,\n        description: \"Consider starting easier goals first to build momentum\",\n        impact: \"Improved success rate\",\n        effort: \"Low\",\n      },\n    ];\n  };\n\n  // Analytics functions using helpers\n  const getGoalInsightsCallback = useCallback(\n    (): GoalInsights => getGoalInsights(),\n    [],\n  );\n\n  const getPredictiveAnalyticsCallback = useCallback(\n    (): GoalPredictions => getPredictiveAnalyticsHelper(personalGoals),\n    [personalGoals],\n  );\n\n  const getCompletionTrendsCallback = useCallback(\n    (): CompletionTrends => getCompletionTrendsHelper(),\n    [],\n  );\n\n  return {\n    // Goal state\n    personalGoals,\n    collaborativeGoals,\n    recommendedGoals,\n    goalAnalytics,\n    goalTemplates,\n\n    // Goal management\n    createGoal: createGoalMutation.mutate,\n    updateGoal: updateGoalMutation.mutate,\n    deleteGoal: deleteGoalMutation.mutate,\n\n    // AI features\n    getSmartRecommendations: () => recommendedGoals,\n    generateGoalFromPrompt: generateGoalFromPromptMutation.mutate,\n    optimizeGoalPlan: optimizeGoalPlanMutation.mutate,\n\n    // Collaboration\n    shareGoal: shareGoalMutation.mutate,\n    inviteCollaborator: inviteCollaboratorMutation.mutate,\n    acceptCollaboration: async (inviteId: string) => {\n      logger.info(\"Collaboration accepted\", { inviteId });\n    },\n\n    // Analytics\n    getGoalInsights: getGoalInsightsCallback,\n    getPredictiveAnalytics: getPredictiveAnalyticsCallback,\n    getCompletionTrends: getCompletionTrendsCallback,\n\n    // Loading states\n    isCreating: createGoalMutation.isPending,\n    isUpdating: updateGoalMutation.isPending,\n    isDeleting: deleteGoalMutation.isPending,\n    isGenerating: generateGoalFromPromptMutation.isPending,\n    isOptimizing: optimizeGoalPlanMutation.isPending,\n\n    // Computed properties\n    activeGoalsCount: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    ).length,\n    completionRate: goalAnalytics ? goalAnalytics.completionRate : 0,\n    averageCompletionTime: goalAnalytics\n      ? goalAnalytics.averageCompletionTime\n      : 0,\n    hasCollaborativeGoals: collaborativeGoals.length > 0,\n    needsAttention: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.BEHIND,\n    ).length,\n\n    // Results\n    lastOptimization: optimizeGoalPlanMutation.data,\n    lastGeneratedGoal: generateGoalFromPromptMutation.data,\n\n    // Errors\n    error:\n      createGoalMutation.error ||\n      updateGoalMutation.error ||\n      deleteGoalMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useLogEventForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useManualEntry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/usePersonalGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useReporting.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (278). Maximum allowed is 150.",
        "line": 214,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 553,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useReporting Hook - Advanced Reporting & Analytics\n *\n * Comprehensive reporting system with custom reports, data visualization,\n * and export capabilities for detailed analysis.\n */\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { ReportStorageService } from \"../../services/reportStorage\";\n\n// Report types\nexport enum ReportType {\n  SUMMARY = \"summary\",\n  DETAILED = \"detailed\",\n  ANALYTICS = \"analytics\",\n  CUSTOM = \"custom\",\n}\n\n// Export formats\nexport enum ExportFormat {\n  JSON = \"json\",\n  CSV = \"csv\",\n  PDF = \"pdf\",\n  XLSX = \"xlsx\",\n}\n\n// Report template\nexport interface ReportTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: ReportType;\n  parameters: ReportParameter[];\n  defaultParameters: Record<string, string | number | boolean | Date>;\n}\n\n// Report parameter\nexport interface ReportParameter {\n  name: string;\n  type: \"string\" | \"number\" | \"date\" | \"boolean\" | \"select\";\n  required: boolean;\n  options?: string[];\n  default?: string | number | boolean | Date;\n}\n\n// Report parameters\nexport interface ReportParameters {\n  dateRange: {\n    start: Date;\n    end: Date;\n  };\n  includeDetails: boolean;\n  groupBy?: string;\n  filters: Record<string, string | number | boolean | Date>;\n}\n\n// Generated report\nexport interface GeneratedReport {\n  id: string;\n  templateId: string;\n  name: string;\n  parameters: ReportParameters;\n  data: Record<string, unknown> | unknown[];\n  generatedAt: Date;\n  generatedBy: string;\n  size: number;\n}\n\n// Custom report definition\nexport interface CustomReportDefinition {\n  name: string;\n  description: string;\n  dataSource: string;\n  fields: string[];\n  filters: ReportFilter[];\n  grouping?: string[];\n  sorting?: ReportSort[];\n}\n\n// Report filter\nexport interface ReportFilter {\n  field: string;\n  operator: \"equals\" | \"contains\" | \"greater\" | \"less\" | \"between\";\n  value: string | number | boolean | Date;\n}\n\n// Report sort\nexport interface ReportSort {\n  field: string;\n  direction: \"asc\" | \"desc\";\n}\n\n// Custom report\nexport interface CustomReport {\n  id: string;\n  definition: CustomReportDefinition;\n  createdAt: Date;\n  lastRun?: Date;\n}\n\n// Report schedule\nexport interface ReportSchedule {\n  frequency: \"daily\" | \"weekly\" | \"monthly\";\n  time: string;\n  recipients: string[];\n  format: ExportFormat;\n  enabled: boolean;\n}\n\n// Scheduled report\nexport interface ScheduledReport {\n  id: string;\n  reportId: string;\n  schedule: ReportSchedule;\n  nextRun: Date;\n  lastRun?: Date;\n}\n\n// Report export\nexport interface ReportExport {\n  id: string;\n  reportId: string;\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data export\nexport interface DataExport {\n  id: string;\n  dataType: string;\n  filters: DataFilter[];\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data filter\nexport interface DataFilter {\n  field: string;\n  value: string | number | boolean | Date;\n}\n\n// Reporting preferences\nexport interface ReportingPreferences {\n  defaultFormat: ExportFormat;\n  autoRefresh: boolean;\n  refreshInterval: number;\n  maxReports: number;\n}\n\n// Default templates\nconst DEFAULT_TEMPLATES: ReportTemplate[] = [\n  {\n    id: \"session-summary\",\n    name: \"Session Summary\",\n    description: \"Summary of chastity sessions over time\",\n    type: ReportType.SUMMARY,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"includeDetails\",\n        type: \"boolean\",\n        required: false,\n        default: false,\n      },\n    ],\n    defaultParameters: {\n      includeDetails: false,\n    },\n  },\n  {\n    id: \"achievement-progress\",\n    name: \"Achievement Progress\",\n    description: \"Progress on achievements and goals\",\n    type: ReportType.ANALYTICS,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"category\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"duration\", \"behavior\", \"goals\"],\n      },\n    ],\n    defaultParameters: {\n      category: \"all\",\n    },\n  },\n  {\n    id: \"behavioral-analysis\",\n    name: \"Behavioral Analysis\",\n    description: \"Analysis of behavioral patterns and events\",\n    type: ReportType.DETAILED,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"eventTypes\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"sessions\", \"events\", \"tasks\"],\n      },\n    ],\n    defaultParameters: {\n      eventTypes: \"all\",\n    },\n  },\n];\n\n/**\n * Advanced Reporting Hook\n */\nexport const useReporting = (userId?: string, _relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get available templates\n  const { data: availableReports = DEFAULT_TEMPLATES } = useQuery<\n    ReportTemplate[]\n  >({\n    queryKey: [\"reports\", \"templates\"],\n    queryFn: () => DEFAULT_TEMPLATES,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get custom reports\n  const { data: customReports = [] } = useQuery<CustomReport[]>({\n    queryKey: [\"reports\", \"custom\", userId],\n    queryFn: () => {\n      return ReportStorageService.getCustomReports<CustomReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get recent reports\n  const { data: recentReports = [] } = useQuery<GeneratedReport[]>({\n    queryKey: [\"reports\", \"recent\", userId],\n    queryFn: () => {\n      return ReportStorageService.getRecentReports<GeneratedReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get preferences\n  const { data: preferences } = useQuery<ReportingPreferences>({\n    queryKey: [\"reports\", \"preferences\", userId],\n    queryFn: () => {\n      const stored =\n        ReportStorageService.getPreferences<ReportingPreferences>();\n      return stored\n        ? stored\n        : {\n            defaultFormat: ExportFormat.JSON,\n            autoRefresh: false,\n            refreshInterval: 300000, // 5 minutes\n            maxReports: 50,\n          };\n    },\n    enabled: Boolean(userId),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Generate report mutation\n  const generateReportMutation = useMutation({\n    mutationFn: async ({\n      templateId,\n      parameters,\n    }: {\n      templateId: string;\n      parameters: ReportParameters;\n    }) => {\n      const template = availableReports.find((t) => t.id === templateId);\n      if (!template) throw new Error(\"Template not found\");\n\n      logger.info(\"Generating report\", { templateId, parameters });\n\n      // Simulate report generation\n      const reportData = await generateReportData(templateId, parameters);\n\n      const report: GeneratedReport = {\n        id: `report-${Date.now()}`,\n        templateId,\n        name: template.name,\n        parameters,\n        data: reportData,\n        generatedAt: new Date(),\n        generatedBy: userId || \"anonymous\",\n        size: JSON.stringify(reportData).length,\n      };\n\n      // Store in recent reports\n      const updated = [report, ...recentReports].slice(\n        0,\n        preferences?.maxReports || 50,\n      );\n      ReportStorageService.setRecentReports(updated);\n      queryClient.setQueryData([\"reports\", \"recent\", userId], updated);\n\n      return report;\n    },\n  });\n\n  // Create custom report mutation\n  const createCustomReportMutation = useMutation({\n    mutationFn: async (definition: CustomReportDefinition) => {\n      const customReport: CustomReport = {\n        id: `custom-${Date.now()}`,\n        definition,\n        createdAt: new Date(),\n      };\n\n      const updated = [...customReports, customReport];\n      ReportStorageService.setCustomReports(updated);\n      queryClient.setQueryData([\"reports\", \"custom\", userId], updated);\n\n      logger.info(\"Custom report created\", { reportId: customReport.id });\n      return customReport;\n    },\n  });\n\n  // Schedule report mutation\n  const scheduleReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      schedule,\n    }: {\n      reportId: string;\n      schedule: ReportSchedule;\n    }) => {\n      const scheduledReport: ScheduledReport = {\n        id: `schedule-${Date.now()}`,\n        reportId,\n        schedule,\n        nextRun: calculateNextRun(schedule),\n      };\n\n      logger.info(\"Report scheduled\", {\n        reportId,\n        schedule: scheduledReport.id,\n      });\n      return scheduledReport;\n    },\n  });\n\n  // Export report mutation\n  const exportReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      format,\n    }: {\n      reportId: string;\n      format: ExportFormat;\n    }) => {\n      const report = recentReports.find((r) => r.id === reportId);\n      if (!report) throw new Error(\"Report not found\");\n\n      const exportData = await exportReportData(report, format);\n\n      const exportResult: ReportExport = {\n        id: `export-${Date.now()}`,\n        reportId,\n        format,\n        url: exportData.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n      };\n\n      logger.info(\"Report exported\", {\n        reportId,\n        format,\n        exportId: exportResult.id,\n      });\n      return exportResult;\n    },\n  });\n\n  // Export raw data mutation\n  const exportRawDataMutation = useMutation({\n    mutationFn: async ({\n      dataType,\n      filters,\n      format,\n    }: {\n      dataType: string;\n      filters: DataFilter[];\n      format: ExportFormat;\n    }) => {\n      const rawData = await getRawData(dataType, filters);\n      const exportResult = await exportData(rawData, format);\n\n      const dataExport: DataExport = {\n        id: `data-export-${Date.now()}`,\n        dataType,\n        filters,\n        format,\n        url: exportResult.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\n      };\n\n      logger.info(\"Raw data exported\", {\n        dataType,\n        format,\n        exportId: dataExport.id,\n      });\n      return dataExport;\n    },\n  });\n\n  // Helper functions\n  const generateReportData = async (\n    templateId: string,\n    parameters: ReportParameters,\n  ) => {\n    // In a real implementation, this would query actual data\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    return {\n      summary: {\n        totalSessions: Math.floor(Math.random() * 100),\n        averageDuration: Math.floor(Math.random() * 72),\n        longestSession: Math.floor(Math.random() * 168),\n      },\n      details: parameters.includeDetails ? generateDetailedData() : null,\n      generatedAt: new Date().toISOString(),\n    };\n  };\n\n  const generateDetailedData = () => ({\n    sessions: Array.from({ length: 10 }, (_, i) => ({\n      id: i + 1,\n      startDate: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n      duration: Math.floor(Math.random() * 72),\n      events: Math.floor(Math.random() * 5),\n    })),\n  });\n\n  const calculateNextRun = (schedule: ReportSchedule): Date => {\n    const now = new Date();\n    const timeParts = schedule.time.split(\":\").map(Number);\n    const hours = timeParts[0] ?? 0;\n    const minutes = timeParts[1] ?? 0;\n\n    const nextRun = new Date(now);\n    nextRun.setHours(hours, minutes, 0, 0);\n\n    if (nextRun <= now) {\n      switch (schedule.frequency) {\n        case \"daily\":\n          nextRun.setDate(nextRun.getDate() + 1);\n          break;\n        case \"weekly\":\n          nextRun.setDate(nextRun.getDate() + 7);\n          break;\n        case \"monthly\":\n          nextRun.setMonth(nextRun.getMonth() + 1);\n          break;\n      }\n    }\n\n    return nextRun;\n  };\n\n  const exportReportData = async (\n    report: GeneratedReport,\n    format: ExportFormat,\n  ) => {\n    // Simulate export processing\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    const blob = new Blob([JSON.stringify(report.data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n\n    return { url };\n  };\n\n  const getRawData = async (dataType: string, filters: DataFilter[]) => {\n    // Simulate data retrieval\n    await new Promise((resolve) => setTimeout(resolve, 800));\n    return { dataType, filters, records: [] };\n  };\n\n  const exportData = async (\n    data: Record<string, unknown> | unknown[],\n    format: ExportFormat,\n  ) => {\n    const blob = new Blob([JSON.stringify(data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n    return { url };\n  };\n\n  const getContentType = (format: ExportFormat): string => {\n    switch (format) {\n      case ExportFormat.JSON:\n        return \"application/json\";\n      case ExportFormat.CSV:\n        return \"text/csv\";\n      case ExportFormat.PDF:\n        return \"application/pdf\";\n      case ExportFormat.XLSX:\n        return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      default:\n        return \"application/octet-stream\";\n    }\n  };\n\n  return {\n    // Available reports and templates\n    availableReports,\n    customReports,\n    recentReports,\n    preferences,\n\n    // Actions\n    generateReport: generateReportMutation.mutate,\n    createCustomReport: createCustomReportMutation.mutate,\n    scheduleReport: scheduleReportMutation.mutate,\n    exportReport: exportReportMutation.mutate,\n    exportRawData: exportRawDataMutation.mutate,\n\n    // Loading states\n    isGenerating: generateReportMutation.isPending,\n    isCreatingCustom: createCustomReportMutation.isPending,\n    isScheduling: scheduleReportMutation.isPending,\n    isExporting:\n      exportReportMutation.isPending || exportRawDataMutation.isPending,\n\n    // Results\n    lastGeneratedReport: generateReportMutation.data,\n    lastExport: exportReportMutation.data || exportRawDataMutation.data,\n\n    // Computed properties\n    totalReports: recentReports.length,\n    hasScheduledReports: false, // Would check actual scheduled reports\n    lastReportDate:\n      recentReports.length > 0 ? recentReports[0].generatedAt : null,\n    hasCustomReports: customReports.length > 0,\n\n    // Errors\n    error:\n      generateReportMutation.error ||\n      createCustomReportMutation.error ||\n      scheduleReportMutation.error ||\n      exportReportMutation.error ||\n      exportRawDataMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useRuleEditor.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useRuleEditor' has too many lines (172). Maximum allowed is 150.",
        "line": 75,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Rule Editor Hook\n *\n * Extracts rule management logic from RuleEditor component.\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface Rule {\n  id: string;\n  title: string;\n  description: string;\n  enabled: boolean;\n  conditions: Condition[];\n  actions: RuleAction[];\n}\n\nexport interface Condition {\n  type: string;\n  value: unknown;\n}\n\nexport interface RuleAction {\n  type: string;\n  value: unknown;\n}\n\nexport interface CreateRuleInput {\n  title: string;\n  description?: string;\n}\n\nexport interface UpdateRuleInput {\n  title?: string;\n  description?: string;\n  enabled?: boolean;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  message: string;\n}\n\nexport interface UseRuleEditorReturn {\n  rules: Rule[];\n  currentRule: Rule | null;\n  isLoading: boolean;\n  createRule: (rule: CreateRuleInput) => Promise<Rule>;\n  updateRule: (id: string, updates: UpdateRuleInput) => Promise<Rule>;\n  deleteRule: (id: string) => Promise<void>;\n  toggleRule: (id: string, enabled: boolean) => Promise<void>;\n  setCurrentRule: (rule: Rule | null) => void;\n  resetEditor: () => void;\n  validateRule: (rule: Rule) => ValidationResult;\n  isRuleValid: boolean;\n  validationErrors: string[];\n  testRule: (\n    rule: Rule,\n    testData: Record<string, unknown>,\n  ) => Promise<TestResult>;\n  isTesting: boolean;\n  addCondition: (condition: Condition) => void;\n  removeCondition: (index: number) => void;\n  updateCondition: (index: number, condition: Condition) => void;\n  addAction: (action: RuleAction) => void;\n  removeAction: (index: number) => void;\n  updateAction: (index: number, action: RuleAction) => void;\n}\n\nexport function useRuleEditor(): UseRuleEditorReturn {\n  const [rules, setRules] = useState<Rule[]>([]);\n  const [currentRule, setCurrentRule] = useState<Rule | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isTesting, setIsTesting] = useState(false);\n  const [validationErrors, setValidationErrors] = useState<string[]>([]);\n\n  const createRule = useCallback(\n    async (rule: CreateRuleInput): Promise<Rule> => {\n      const newRule: Rule = {\n        id: `rule-${Date.now()}`,\n        title: rule.title,\n        description: rule.description || \"\",\n        enabled: true,\n        conditions: [],\n        actions: [],\n      };\n      setRules((prev) => [...prev, newRule]);\n      return newRule;\n    },\n    [],\n  );\n\n  const updateRule = useCallback(\n    async (id: string, updates: UpdateRuleInput): Promise<Rule> => {\n      let updatedRule: Rule | null = null;\n      setRules((prev) =>\n        prev.map((r) => {\n          if (r.id === id) {\n            updatedRule = { ...r, ...updates };\n            return updatedRule;\n          }\n          return r;\n        }),\n      );\n      if (!updatedRule) throw new Error(\"Rule not found\");\n      return updatedRule;\n    },\n    [],\n  );\n\n  const deleteRule = useCallback(async (id: string): Promise<void> => {\n    setRules((prev) => prev.filter((r) => r.id !== id));\n  }, []);\n\n  const toggleRule = useCallback(\n    async (id: string, enabled: boolean): Promise<void> => {\n      await updateRule(id, { enabled });\n    },\n    [updateRule],\n  );\n\n  const resetEditor = useCallback(() => {\n    setCurrentRule(null);\n    setValidationErrors([]);\n  }, []);\n\n  const validateRule = useCallback((rule: Rule): ValidationResult => {\n    const errors: string[] = [];\n    if (!rule.title) errors.push(\"Title is required\");\n    if (rule.conditions.length === 0)\n      errors.push(\"At least one condition is required\");\n    if (rule.actions.length === 0)\n      errors.push(\"At least one action is required\");\n    setValidationErrors(errors);\n    return { valid: errors.length === 0, errors };\n  }, []);\n\n  const testRule = useCallback(\n    async (\n      _rule: Rule,\n      _testData: Record<string, unknown>,\n    ): Promise<TestResult> => {\n      setIsTesting(true);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        return { passed: true, message: \"Rule test passed\" };\n      } finally {\n        setIsTesting(false);\n      }\n    },\n    [],\n  );\n\n  const addCondition = useCallback(\n    (condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: [...currentRule.conditions, condition],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeCondition = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateCondition = useCallback(\n    (index: number, condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.map((c, i) =>\n            i === index ? condition : c,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const addAction = useCallback(\n    (action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: [...currentRule.actions, action],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeAction = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateAction = useCallback(\n    (index: number, action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.map((a, i) =>\n            i === index ? action : a,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    rules,\n    currentRule,\n    isLoading,\n    createRule,\n    updateRule,\n    deleteRule,\n    toggleRule,\n    setCurrentRule,\n    resetEditor,\n    validateRule,\n    isRuleValid: validationErrors.length === 0,\n    validationErrors,\n    testRule,\n    isTesting,\n    addCondition,\n    removeCondition,\n    updateCondition,\n    addAction,\n    removeAction,\n    updateAction,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSystem.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (265). Maximum allowed is 150.",
        "line": 140,
        "column": 35,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 477,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'refreshData'. Either include it or remove the dependency array.",
        "line": 438,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 441,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]",
            "fix": {
              "range": [13119, 13223],
              "text": "[keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'endAdminSession'. Either include it or remove the dependency array.",
        "line": 451,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 451,
        "endColumn": 26,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [endAdminSession, state.adminSession]",
            "fix": { "range": [13608, 13628], "text": "[endAdminSession, state.adminSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useKeyholderSystem Hook\n * Unified management interface for all keyholder functionality\n * Acts as the primary entry point for keyholder operations\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { useAuthState } from \"../../contexts\";\nimport { useKeyholderRelationships } from \"../useKeyholderRelationships\";\nimport {\n  KeyholderRelationship,\n  KeyholderPermissions as _KeyholderPermissions,\n} from \"../../types/core\";\nimport { Task } from \"../../types\";\nimport { InviteCode } from \"../../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderSystem\");\n\n// ==================== TYPES ====================\n\nexport interface KeyholderStats {\n  totalSubmissives: number;\n  activeRelationships: number;\n  totalSessions: number;\n  averageSessionDuration: number;\n  totalRewardsGiven: number;\n  totalPunishmentsGiven: number;\n  lastActivity: Date | null;\n}\n\nexport interface KeyholderStatus {\n  isActiveKeyholder: boolean;\n  hasPermissions: boolean;\n  canCreateInvites: boolean;\n  maxRelationships: number;\n  currentRelationships: number;\n}\n\nexport interface AdminSession {\n  id: string;\n  keyholderId: string;\n  relationshipId: string;\n  startTime: Date;\n  expiresAt: Date;\n  permissions: string[];\n  isActive: boolean;\n  lastActivity: Date;\n}\n\nexport interface KeyholderSystemState {\n  // Active relationships where user is keyholder\n  activeRelationships: KeyholderRelationship[];\n  // Current admin session if active\n  adminSession: AdminSession | null;\n  // Overall keyholder status and permissions\n  keyholderStatus: KeyholderStatus;\n  // Quick stats for dashboard\n  stats: KeyholderStats;\n  // Currently selected relationship for operations\n  selectedRelationship: KeyholderRelationship | null;\n  // Loading states\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n}\n\nexport interface InviteOptions {\n  expirationHours?: number;\n  maxUses?: number;\n  customNote?: string;\n}\n\nexport interface BulkOperations {\n  startSessions: (\n    relationshipIds: string[],\n    options?: { duration?: number; message?: string },\n  ) => Promise<void>;\n  stopSessions: (relationshipIds: string[], reason?: string) => Promise<void>;\n  sendMessages: (relationshipIds: string[], message: string) => Promise<void>;\n  assignTasks: (\n    relationshipIds: string[],\n    task: Omit<Task, \"id\" | \"createdAt\">,\n  ) => Promise<void>;\n}\n\nexport interface KeyholderSystemActions {\n  // Relationship management\n  createInviteCode: (options?: InviteOptions) => Promise<string | null>;\n  acceptSubmissive: (\n    inviteCode: string,\n  ) => Promise<KeyholderRelationship | null>;\n  removeSubmissive: (relationshipId: string) => Promise<void>;\n\n  // Session management\n  startAdminSession: (relationshipId: string) => Promise<AdminSession | null>;\n  endAdminSession: () => Promise<void>;\n\n  // Multi-user operations\n  switchActiveRelationship: (relationshipId: string) => void;\n  getBulkOperations: () => BulkOperations;\n\n  // Data management\n  refreshData: () => Promise<void>;\n  resetError: () => void;\n}\n\n// ==================== INITIAL STATE ====================\n\nconst initialKeyholderStatus: KeyholderStatus = {\n  isActiveKeyholder: false,\n  hasPermissions: false,\n  canCreateInvites: false,\n  maxRelationships: 5, // Default limit\n  currentRelationships: 0,\n};\n\nconst initialStats: KeyholderStats = {\n  totalSubmissives: 0,\n  activeRelationships: 0,\n  totalSessions: 0,\n  averageSessionDuration: 0,\n  totalRewardsGiven: 0,\n  totalPunishmentsGiven: 0,\n  lastActivity: null,\n};\n\nconst initialState: KeyholderSystemState = {\n  activeRelationships: [],\n  adminSession: null,\n  keyholderStatus: initialKeyholderStatus,\n  stats: initialStats,\n  selectedRelationship: null,\n  isLoading: false,\n  isInitialized: false,\n  error: null,\n};\n\n// ==================== MAIN HOOK ====================\n\nexport const useKeyholderSystem = (keyholderId?: string) => {\n  const { user } = useAuthState();\n  const keyholderRelationships = useKeyholderRelationships();\n\n  // Use provided keyholderId or fall back to current user\n  const effectiveKeyholderId = keyholderId || user?.uid;\n\n  const [state, setState] = useState<KeyholderSystemState>(initialState);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const computedValues = useMemo(() => {\n    const { activeRelationships, adminSession, keyholderStatus } = state;\n\n    return {\n      hasActiveRelationships: activeRelationships.length > 0,\n      canStartAdminSession: adminSession === null,\n      activeRelationshipCount: activeRelationships.length,\n      hasMaxRelationships:\n        keyholderStatus.currentRelationships >=\n        keyholderStatus.maxRelationships,\n      selectedRelationshipId: state.selectedRelationship?.id || null,\n    };\n  }, [state]);\n\n  // ==================== ACTIONS ====================\n\n  const refreshData = useCallback(async () => {\n    if (!effectiveKeyholderId) return;\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      logger.debug(\"Refreshing keyholder system data\", {\n        keyholderId: effectiveKeyholderId,\n      });\n\n      // Get relationships from the existing hook\n      await keyholderRelationships.loadRelationships();\n\n      const keyholderRelationshipsList =\n        keyholderRelationships.relationships.asKeyholder;\n\n      // Calculate keyholder status and stats\n      const { keyholderStatus, stats } = calculateKeyholderStatusAndStats(\n        keyholderRelationshipsList,\n        keyholderRelationships as unknown as Record<string, unknown>,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        activeRelationships: keyholderRelationshipsList,\n        keyholderStatus,\n        stats,\n        isLoading: false,\n        isInitialized: true,\n      }));\n\n      logger.info(\"Keyholder system data refreshed\", {\n        relationshipCount: keyholderRelationshipsList.length,\n        activeCount: stats.activeRelationships,\n      });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : \"Failed to refresh keyholder data\";\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      logger.error(\"Failed to refresh keyholder system data\", {\n        error: error as Error,\n      });\n    }\n  }, [effectiveKeyholderId, keyholderRelationships]);\n\n  const createInviteCode = useCallback(\n    async (options: InviteOptions = {}): Promise<string | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Creating invite code\", {\n          keyholderId: effectiveKeyholderId,\n          options,\n        });\n\n        const inviteCode = await keyholderRelationships.createInviteCode(\n          options.expirationHours,\n        );\n\n        return await handleInviteCodeCreation(inviteCode, refreshData);\n      } catch (error) {\n        return handleInviteCodeError(error, setState);\n      }\n    },\n    [effectiveKeyholderId, keyholderRelationships, refreshData],\n  );\n\n  const acceptSubmissive = useCallback(\n    async (inviteCode: string): Promise<KeyholderRelationship | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Accepting submissive\", {\n          keyholderId: effectiveKeyholderId,\n          inviteCode,\n        });\n\n        const success =\n          await keyholderRelationships.acceptInviteCode(inviteCode);\n\n        return await handleSubmissiveAcceptance(\n          success,\n          refreshData,\n          state.activeRelationships,\n        );\n      } catch (error) {\n        return handleSubmissiveAcceptanceError(error, setState);\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.activeRelationships,\n    ],\n  );\n\n  const removeSubmissive = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      if (!effectiveKeyholderId) return;\n\n      try {\n        logger.debug(\"Removing submissive\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        await keyholderRelationships.endRelationship(relationshipId);\n\n        // Refresh data to update state\n        await refreshData();\n\n        // Clear selected relationship if it was the removed one\n        if (state.selectedRelationship?.id === relationshipId) {\n          setState((prev) => ({ ...prev, selectedRelationship: null }));\n        }\n      } catch (error) {\n        logger.error(\"Failed to remove submissive\", { error: error as Error });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to remove submissive\",\n        }));\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.selectedRelationship,\n    ],\n  );\n\n  const switchActiveRelationship = useCallback(\n    (relationshipId: string) => {\n      const relationship = state.activeRelationships.find(\n        (rel) => rel.id === relationshipId,\n      );\n      if (relationship) {\n        setState((prev) => ({ ...prev, selectedRelationship: relationship }));\n        logger.debug(\"Switched active relationship\", { relationshipId });\n      }\n    },\n    [state.activeRelationships],\n  );\n\n  // Admin session management (placeholder implementation)\n  const startAdminSession = useCallback(\n    async (relationshipId: string): Promise<AdminSession | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Starting admin session\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        // TODO: Implement actual admin session creation\n        const adminSession: AdminSession = {\n          id: `admin_${Date.now()}`,\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n          startTime: new Date(),\n          expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes\n          permissions: [\"session_control\", \"task_management\", \"rewards\"], // Default permissions\n          isActive: true,\n          lastActivity: new Date(),\n        };\n\n        setState((prev) => ({ ...prev, adminSession }));\n\n        logger.info(\"Admin session started\", { sessionId: adminSession.id });\n        return adminSession;\n      } catch (error) {\n        logger.error(\"Failed to start admin session\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to start admin session\",\n        }));\n        return null;\n      }\n    },\n    [effectiveKeyholderId],\n  );\n\n  const endAdminSession = useCallback(async (): Promise<void> => {\n    if (!state.adminSession) return;\n\n    try {\n      logger.debug(\"Ending admin session\", {\n        sessionId: state.adminSession.id,\n      });\n\n      // TODO: Implement actual admin session cleanup\n      setState((prev) => ({ ...prev, adminSession: null }));\n\n      logger.info(\"Admin session ended\");\n    } catch (error) {\n      logger.error(\"Failed to end admin session\", { error: error as Error });\n      setState((prev) => ({\n        ...prev,\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to end admin session\",\n      }));\n    }\n  }, [state.adminSession]);\n\n  const getBulkOperations = useCallback((): BulkOperations => {\n    return {\n      startSessions: async (\n        relationshipIds: string[],\n        options?: { duration?: number; message?: string },\n      ) => {\n        logger.debug(\"Bulk starting sessions\", { relationshipIds, options });\n        // TODO: Implement bulk session start\n      },\n      stopSessions: async (relationshipIds: string[], reason?: string) => {\n        logger.debug(\"Bulk stopping sessions\", { relationshipIds, reason });\n        // TODO: Implement bulk session stop\n      },\n      sendMessages: async (relationshipIds: string[], message: string) => {\n        logger.debug(\"Bulk sending messages\", { relationshipIds, message });\n        // TODO: Implement bulk messaging\n      },\n      assignTasks: async (\n        relationshipIds: string[],\n        task: Omit<Task, \"id\" | \"createdAt\">,\n      ) => {\n        logger.debug(\"Bulk assigning tasks\", { relationshipIds, task });\n        // TODO: Implement bulk task assignment\n      },\n    };\n  }, []);\n\n  const resetError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  // ==================== EFFECTS ====================\n\n  // Initialize data when user changes\n  useEffect(() => {\n    if (effectiveKeyholderId && !state.isInitialized) {\n      refreshData();\n    }\n  }, [effectiveKeyholderId, state.isInitialized, refreshData]);\n\n  // Auto-refresh when relationships data changes\n  useEffect(() => {\n    if (\n      keyholderRelationships.relationships.asKeyholder.length !==\n      state.activeRelationships.length\n    ) {\n      refreshData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    keyholderRelationships.relationships.asKeyholder.length,\n    state.activeRelationships.length,\n  ]);\n\n  // Admin session auto-expiry\n  useEffect(() => {\n    if (state.adminSession && state.adminSession.expiresAt < new Date()) {\n      logger.info(\"Admin session expired, ending session\");\n      endAdminSession();\n    }\n    // endAdminSession is stable as it only depends on state.adminSession which is already in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [state.adminSession]);\n\n  // ==================== RETURN ====================\n\n  const actions: KeyholderSystemActions = {\n    createInviteCode,\n    acceptSubmissive,\n    removeSubmissive,\n    startAdminSession,\n    endAdminSession,\n    switchActiveRelationship,\n    getBulkOperations,\n    refreshData,\n    resetError,\n  };\n\n  return {\n    // State\n    ...state,\n\n    // Computed\n    ...computedValues,\n\n    // Actions\n    ...actions,\n  };\n};\n\nexport type UseKeyholderSystemReturn = ReturnType<typeof useKeyholderSystem>;\n\n// Helper functions for useKeyholderSystem\nfunction calculateKeyholderStatusAndStats(\n  keyholderRelationshipsList: KeyholderRelationship[],\n  keyholderRelationships: Record<string, unknown>,\n): { keyholderStatus: KeyholderStatus; stats: KeyholderStats } {\n  // Calculate keyholder status\n  const keyholderStatus: KeyholderStatus = {\n    isActiveKeyholder: keyholderRelationshipsList.length > 0,\n    hasPermissions: keyholderRelationshipsList.some(\n      (rel) =>\n        rel.permissions && Object.values(rel.permissions).some((perm) => perm),\n    ),\n    canCreateInvites: keyholderRelationships.canCreateInviteCode\n      ? keyholderRelationships.canCreateInviteCode()\n      : false,\n    maxRelationships: 5, // Could be user-specific in the future\n    currentRelationships: keyholderRelationshipsList.length,\n  };\n\n  // Calculate basic stats\n  const stats: KeyholderStats = {\n    totalSubmissives: keyholderRelationshipsList.length,\n    activeRelationships: keyholderRelationshipsList.filter(\n      (rel) => rel.status === \"active\",\n    ).length,\n    totalSessions: 0, // TODO: Calculate from session data\n    averageSessionDuration: 0, // TODO: Calculate from session data\n    totalRewardsGiven: 0, // TODO: Calculate from reward data\n    totalPunishmentsGiven: 0, // TODO: Calculate from punishment data\n    lastActivity: null, // TODO: Calculate from activity data\n  };\n\n  return { keyholderStatus, stats };\n}\n\nasync function handleInviteCodeCreation(\n  inviteCode: InviteCode | null,\n  refreshData: () => Promise<void>,\n): Promise<string | null> {\n  if (inviteCode) {\n    // Refresh data to update state\n    await refreshData();\n    return inviteCode.code;\n  }\n  return null;\n}\n\nfunction handleInviteCodeError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to create invite code\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to create invite code\",\n  }));\n  return null;\n}\n\nasync function handleSubmissiveAcceptance(\n  success: boolean,\n  refreshData: () => Promise<void>,\n  activeRelationships: KeyholderRelationship[],\n): Promise<KeyholderRelationship | null> {\n  if (success) {\n    // Refresh data to get the new relationship\n    await refreshData();\n\n    // Return the newest relationship (should be the one just created)\n    const newestRelationship = activeRelationships.sort(\n      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),\n    )[0];\n\n    return newestRelationship || null;\n  }\n  return null;\n}\n\nfunction handleSubmissiveAcceptanceError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to accept submissive\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to accept submissive\",\n  }));\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useMultiWearer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 149,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 149,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3704, 3707], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3704, 3707], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport { onSnapshot, query, where, QuerySnapshot } from \"firebase/firestore\";\nimport {\n  MultiWearerSession,\n  Wearer,\n  KeyholderPermissions,\n  SessionData,\n} from \"../../types\";\nimport {\n  getMultiWearerCollectionRef,\n  getWearersCollectionRef,\n  createMultiWearerSession,\n  endMultiWearerSession,\n  addWearerToSession,\n  removeWearerFromSession,\n  updateWearerInSession,\n  parseWearerData,\n  parseSessionData,\n} from \"./multiWearerHelpers\";\nimport { logger } from \"../../utils/logging\";\n\ninterface UseMultiWearerProps {\n  keyholderUserId: string;\n  isAuthReady: boolean;\n}\n\ninterface UseMultiWearerReturn {\n  session: MultiWearerSession | null;\n  wearers: Wearer[];\n  isLoading: boolean;\n  error: string | null;\n  createSession: () => Promise<void>;\n  endSession: () => Promise<void>;\n  addWearer: (wearerData: Omit<Wearer, \"id\">) => Promise<void>;\n  removeWearer: (wearerId: string) => Promise<void>;\n  updateWearer: (wearerId: string, updates: Partial<Wearer>) => Promise<void>;\n  updateWearerPermissions: (\n    wearerId: string,\n    permissions: Partial<KeyholderPermissions>,\n  ) => Promise<void>;\n  updateWearerSession: (\n    wearerId: string,\n    sessionData: Partial<SessionData>,\n  ) => Promise<void>;\n  activateWearer: (wearerId: string) => Promise<void>;\n  deactivateWearer: (wearerId: string) => Promise<void>;\n}\n\nexport function useMultiWearer({\n  keyholderUserId,\n  isAuthReady,\n}: UseMultiWearerProps): UseMultiWearerReturn {\n  const [session, setSession] = useState<MultiWearerSession | null>(null);\n  const [wearers, setWearers] = useState<Wearer[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Set up real-time listener for multi-wearer session\n  useEffect(() => {\n    return setupMultiWearerListener({\n      isAuthReady,\n      keyholderUserId,\n      setSession,\n      setWearers,\n      setError,\n      setIsLoading,\n    });\n  }, [isAuthReady, keyholderUserId]);\n\n  const { createSession, endSession } = useSessionManagement(\n    keyholderUserId,\n    session,\n    setError,\n  );\n\n  const { addWearer, removeWearer, updateWearer } = useWearerManagement(\n    keyholderUserId,\n    session,\n    setError,\n  );\n\n  const {\n    updateWearerPermissions,\n    updateWearerSession,\n    activateWearer,\n    deactivateWearer,\n  } = useWearerOperations(wearers, updateWearer);\n\n  return {\n    session,\n    wearers,\n    isLoading,\n    error,\n    createSession,\n    endSession,\n    addWearer,\n    removeWearer,\n    updateWearer,\n    updateWearerPermissions,\n    updateWearerSession,\n    activateWearer,\n    deactivateWearer,\n  };\n}\n\n// Hook to setup multi-wearer listener\nfunction setupMultiWearerListener(params: {\n  isAuthReady: boolean;\n  keyholderUserId: string;\n  setSession: (\n    value:\n      | MultiWearerSession\n      | null\n      | ((prev: MultiWearerSession | null) => MultiWearerSession | null),\n  ) => void;\n  setWearers: (value: Wearer[]) => void;\n  setError: (value: string | null) => void;\n  setIsLoading: (value: boolean) => void;\n}) {\n  const {\n    isAuthReady,\n    keyholderUserId,\n    setSession,\n    setWearers,\n    setError,\n    setIsLoading,\n  } = params;\n\n  if (!isAuthReady || !keyholderUserId) {\n    setIsLoading(false);\n    setSession(null);\n    setWearers([]);\n    return () => {};\n  }\n\n  const multiWearerCollectionRef = getMultiWearerCollectionRef();\n  const q = query(\n    multiWearerCollectionRef,\n    where(\"keyholderUserId\", \"==\", keyholderUserId),\n    where(\"isActive\", \"==\", true),\n  );\n\n  setIsLoading(true);\n\n  const unsubscribe = onSnapshot(\n    q,\n    (querySnapshot) =>\n      handleSessionSnapshot(\n        querySnapshot as any,\n        setSession,\n        setWearers,\n        setError,\n        setIsLoading,\n      ),\n    (err) => handleSnapshotError(err, setError, setIsLoading),\n  );\n\n  return () => unsubscribe();\n}\n\n// Helper to handle session snapshot\nfunction handleSessionSnapshot(\n  querySnapshot: QuerySnapshot,\n  setSession: (\n    value:\n      | MultiWearerSession\n      | null\n      | ((prev: MultiWearerSession | null) => MultiWearerSession | null),\n  ) => void,\n  setWearers: (value: Wearer[]) => void,\n  setError: (value: string | null) => void,\n  setIsLoading: (value: boolean) => void,\n) {\n  try {\n    if (!querySnapshot.empty) {\n      const docSnapshot = querySnapshot.docs[0];\n      const sessionData = parseSessionData(docSnapshot);\n      setSession({ ...sessionData, wearers: [] });\n\n      // Set up listener for wearers\n      const wearersCollectionRef = getWearersCollectionRef(docSnapshot.id);\n      const wearersUnsubscribe = onSnapshot(\n        wearersCollectionRef,\n        (wearersSnapshot) => {\n          const wearersData: Wearer[] =\n            wearersSnapshot.docs.map(parseWearerData);\n          setWearers(wearersData);\n          setSession((prev) =>\n            prev ? { ...prev, wearers: wearersData } : null,\n          );\n        },\n      );\n\n      return () => wearersUnsubscribe();\n    } else {\n      setSession(null);\n      setWearers([]);\n    }\n    setError(null);\n  } catch (err) {\n    logger.error(\"Error processing multi-wearer session data\", err);\n    setError(\n      err instanceof Error ? err.message : \"Failed to process session data\",\n    );\n  } finally {\n    setIsLoading(false);\n  }\n}\n\n// Helper to handle snapshot errors\nfunction handleSnapshotError(\n  err: Error,\n  setError: (value: string | null) => void,\n  setIsLoading: (value: boolean) => void,\n) {\n  logger.error(\"Error listening to multi-wearer session\", err);\n  setError(\n    err instanceof Error ? err.message : \"Failed to listen to session changes\",\n  );\n  setIsLoading(false);\n}\n\n// Hook for session management\nfunction useSessionManagement(\n  keyholderUserId: string,\n  session: MultiWearerSession | null,\n  setError: (value: string | null) => void,\n) {\n  const createSession = useCallback(async () => {\n    try {\n      setError(null);\n      if (!keyholderUserId) {\n        throw new Error(\"Keyholder user ID is required\");\n      }\n      await createMultiWearerSession(keyholderUserId);\n    } catch (err) {\n      logger.error(\"Error creating multi-wearer session\", err);\n      setError(err instanceof Error ? err.message : \"Failed to create session\");\n      throw err;\n    }\n  }, [keyholderUserId, setError]);\n\n  const endSession = useCallback(async () => {\n    try {\n      setError(null);\n      if (!session) return;\n      await endMultiWearerSession(keyholderUserId);\n    } catch (err) {\n      logger.error(\"Error ending multi-wearer session\", err);\n      setError(err instanceof Error ? err.message : \"Failed to end session\");\n      throw err;\n    }\n  }, [session, keyholderUserId, setError]);\n\n  return { createSession, endSession };\n}\n\n// Hook for wearer management\nfunction useWearerManagement(\n  keyholderUserId: string,\n  session: MultiWearerSession | null,\n  setError: (value: string | null) => void,\n) {\n  const addWearer = useCallback(\n    async (wearerData: Omit<Wearer, \"id\">) => {\n      try {\n        setError(null);\n        if (!session) {\n          throw new Error(\"No active session to add wearer to\");\n        }\n        await addWearerToSession(keyholderUserId, wearerData);\n      } catch (err) {\n        logger.error(\"Error adding wearer\", err);\n        setError(err instanceof Error ? err.message : \"Failed to add wearer\");\n        throw err;\n      }\n    },\n    [session, keyholderUserId, setError],\n  );\n\n  const removeWearer = useCallback(\n    async (wearerId: string) => {\n      try {\n        setError(null);\n        if (!session) return;\n        await removeWearerFromSession(keyholderUserId, wearerId);\n      } catch (err) {\n        logger.error(\"Error removing wearer\", err);\n        setError(\n          err instanceof Error ? err.message : \"Failed to remove wearer\",\n        );\n        throw err;\n      }\n    },\n    [session, keyholderUserId, setError],\n  );\n\n  const updateWearer = useCallback(\n    async (wearerId: string, updates: Partial<Wearer>) => {\n      try {\n        setError(null);\n        if (!session) return;\n        await updateWearerInSession(keyholderUserId, wearerId, updates);\n      } catch (err) {\n        logger.error(\"Error updating wearer\", err);\n        setError(\n          err instanceof Error ? err.message : \"Failed to update wearer\",\n        );\n        throw err;\n      }\n    },\n    [session, keyholderUserId, setError],\n  );\n\n  return { addWearer, removeWearer, updateWearer };\n}\n\n// Hook for wearer operations\nfunction useWearerOperations(\n  wearers: Wearer[],\n  updateWearer: (wearerId: string, updates: Partial<Wearer>) => Promise<void>,\n) {\n  const updateWearerPermissions = useCallback(\n    async (wearerId: string, permissions: Partial<KeyholderPermissions>) => {\n      const wearer = wearers.find((w) => w.id === wearerId);\n      if (!wearer) return;\n\n      const updatedPermissions = {\n        ...wearer.keyholderPermissions,\n        ...permissions,\n      };\n      await updateWearer(wearerId, {\n        keyholderPermissions: updatedPermissions,\n      });\n    },\n    [wearers, updateWearer],\n  );\n\n  const updateWearerSession = useCallback(\n    async (wearerId: string, sessionData: Partial<SessionData>) => {\n      const wearer = wearers.find((w) => w.id === wearerId);\n      if (!wearer) return;\n\n      const updatedSessionData = { ...wearer.sessionData, ...sessionData };\n      await updateWearer(wearerId, { sessionData: updatedSessionData });\n    },\n    [wearers, updateWearer],\n  );\n\n  const activateWearer = useCallback(\n    async (wearerId: string) => {\n      await updateWearer(wearerId, { isActive: true });\n    },\n    [updateWearer],\n  );\n\n  const deactivateWearer = useCallback(\n    async (wearerId: string) => {\n      await updateWearer(wearerId, { isActive: false });\n    },\n    [updateWearer],\n  );\n\n  return {\n    updateWearerPermissions,\n    updateWearerSession,\n    activateWearer,\n    deactivateWearer,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useSessionControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useHapticFeedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/usePullToRefresh.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useTouchGestures.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useViewport.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'updateSafeAreaInsets' and 'updateViewport'. Either include them or remove the dependency array.",
        "line": 124,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 124,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [updateSafeAreaInsets, updateViewport]",
            "fix": { "range": [3158, 3160], "text": "[updateSafeAreaInsets, updateViewport]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileAchievements.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Timestamp' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 14,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 14,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useProfileAchievements Hook\n * Handles achievement filtering and display logic for profiles\n */\n\nimport { useMemo } from \"react\";\nimport { useAchievements } from \"../useAchievements\";\nimport {\n  AchievementCategory,\n  DBUserAchievement,\n  DBAchievement,\n} from \"../../types\";\nimport { getTypeStyles } from \"@/utils/achievements/profile\";\nimport { Timestamp } from \"firebase/firestore\";\n\n// Helper function for achievement type mapping\nconst getAchievementType = (\n  category: AchievementCategory,\n): \"milestone\" | \"streak\" | \"goal\" => {\n  switch (category) {\n    case AchievementCategory.SESSION_MILESTONES:\n    case AchievementCategory.CONSISTENCY_BADGES:\n      return \"milestone\";\n    case AchievementCategory.STREAK_ACHIEVEMENTS:\n      return \"streak\";\n    case AchievementCategory.GOAL_BASED:\n    case AchievementCategory.TASK_COMPLETION:\n      return \"goal\";\n    default:\n      return \"milestone\";\n  }\n};\n\nexport interface ProfileBadge {\n  id: string;\n  name: string;\n  description: string;\n  earnedDate: Date;\n  icon: string;\n}\n\nexport interface ProfileAchievement {\n  id: string;\n  title: string;\n  date: Date;\n  type: \"milestone\" | \"streak\" | \"goal\";\n  icon: string;\n}\n\nexport const useProfileAchievements = (\n  userId: string,\n  isOwnProfile: boolean,\n) => {\n  const { visibleAchievements, allAchievements, isLoading } =\n    useAchievements(userId);\n\n  // Process badges\n  const badges: ProfileBadge[] = useMemo(() => {\n    const achievementsToShow = isOwnProfile\n      ? allAchievements.filter((a: DBAchievement) => {\n          const userAchievement = visibleAchievements.find(\n            (ua: DBUserAchievement) => ua.achievementId === a.id,\n          );\n          return userAchievement !== undefined;\n        })\n      : visibleAchievements;\n\n    return (achievementsToShow as DBUserAchievement[])\n      .map((userAchievement: DBUserAchievement) => {\n        const achievement = allAchievements.find(\n          (a: DBAchievement) => a.id === userAchievement.achievementId,\n        );\n        return achievement\n          ? {\n              id: achievement.id,\n              name: achievement.name,\n              description: achievement.description,\n              earnedDate: userAchievement.earnedAt.toDate(),\n              icon: achievement.icon,\n            }\n          : null;\n      })\n      .filter(\n        (item: ProfileBadge | null): item is ProfileBadge => item !== null,\n      );\n  }, [visibleAchievements, allAchievements, isOwnProfile]);\n\n  // Process recent achievements\n  const recentAchievements: ProfileAchievement[] = useMemo(() => {\n    return visibleAchievements\n      .sort(\n        (a: DBUserAchievement, b: DBUserAchievement) =>\n          b.earnedAt.toDate().getTime() - a.earnedAt.toDate().getTime(),\n      )\n      .slice(0, 5)\n      .map((userAchievement: DBUserAchievement) => {\n        const achievement = allAchievements.find(\n          (a: DBAchievement) => a.id === userAchievement.achievementId,\n        );\n        return achievement\n          ? {\n              id: achievement.id,\n              title: achievement.name,\n              date: userAchievement.earnedAt.toDate(),\n              type: getAchievementType(achievement.category),\n              icon: achievement.icon,\n            }\n          : null;\n      })\n      .filter(\n        (item: ProfileAchievement | null): item is ProfileAchievement =>\n          item !== null,\n      );\n  }, [visibleAchievements, allAchievements]);\n\n  return {\n    badges,\n    recentAchievements,\n    isLoading,\n    getTypeStyles,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfilePrivacy.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileSharing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/usePublicProfile.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/notification-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/presence-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/realtime-sync-operations.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 298,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 298,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7649, 7652], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7649, 7652], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 301,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 301,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7734, 7737], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7734, 7737], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 304,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 304,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7825, 7828], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7825, 7828], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Realtime sync operation helper functions\n */\nimport React from \"react\";\nimport {\n  RealtimeSyncState,\n  ConnectionStatus,\n  SyncChannel,\n  ChannelType,\n  RealtimeUpdate,\n  Subscription,\n} from \"../../types/realtime\";\nimport {\n  createWebSocketUrl,\n  createSyncChannel,\n  sendWebSocketMessage,\n  updateSyncMetrics,\n  shouldAttemptReconnection,\n  createSubscription,\n  notifySubscribers as _notifySubscribers,\n} from \"./realtimeSyncHelpers\";\n\n// Helper to create sendMessage function\nconst createSendMessage = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n) => {\n  return (message: RealtimeUpdate | Record<string, unknown>) => {\n    sendWebSocketMessage(wsRef.current, message, () => {\n      setSyncState((prev) => ({\n        ...prev,\n        syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageSent\"),\n      }));\n    });\n  };\n};\n\n// Config interface for connection setup\ninterface ConnectConfig {\n  wsRef: React.MutableRefObject<WebSocket | null>;\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>;\n  connectionStartTimeRef: React.MutableRefObject<Date | null>;\n  reconnectAttemptsRef: React.MutableRefObject<number>;\n  maxReconnectAttempts: number;\n  userId: string;\n  handleMessage: (message: Record<string, unknown>) => void;\n  startHeartbeat: () => void;\n  stopHeartbeat: () => void;\n  attemptReconnect: () => void;\n}\n\n// Helper to create the connect function\nconst createConnectFunction = (config: ConnectConfig) => {\n  const {\n    wsRef,\n    setSyncState,\n    connectionStartTimeRef,\n    reconnectAttemptsRef,\n    maxReconnectAttempts,\n    userId,\n    handleMessage,\n    startHeartbeat,\n    stopHeartbeat,\n    attemptReconnect,\n  } = config;\n  return () => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTING,\n    }));\n\n    try {\n      const wsUrl = createWebSocketUrl(userId);\n      wsRef.current = new WebSocket(wsUrl);\n      connectionStartTimeRef.current = new Date();\n\n      setupWebSocketHandlers({\n        ws: wsRef.current,\n        setSyncState,\n        reconnectAttemptsRef,\n        maxReconnectAttempts,\n        handleMessage,\n        startHeartbeat,\n        stopHeartbeat,\n        attemptReconnect,\n      });\n    } catch {\n      setSyncState((prev) => ({\n        ...prev,\n        connectionStatus: ConnectionStatus.ERROR,\n      }));\n    }\n  };\n};\n\n// Config interface for connection control\ninterface ConnectionControlConfig {\n  wsRef: React.MutableRefObject<WebSocket | null>;\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>;\n  reconnectAttemptsRef: React.MutableRefObject<number>;\n  reconnectTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>;\n  maxReconnectAttempts: number;\n  reconnectInterval: number;\n  stopHeartbeat: () => void;\n  connect: () => void;\n}\n\n// Helper to create connection control functions\nconst createConnectionControlFunctions = (config: ConnectionControlConfig) => {\n  const {\n    wsRef,\n    setSyncState,\n    reconnectAttemptsRef,\n    reconnectTimeoutRef,\n    maxReconnectAttempts,\n    reconnectInterval,\n    stopHeartbeat,\n    connect,\n  } = config;\n  const attemptReconnect = () => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      return;\n    }\n\n    reconnectAttemptsRef.current++;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.RECONNECTING,\n    }));\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, reconnectInterval);\n  };\n\n  const disconnect = () => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Intentional disconnect\");\n      wsRef.current = null;\n    }\n\n    stopHeartbeat();\n\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n  };\n\n  return { attemptReconnect, disconnect };\n};\n\n// Config interface for WebSocket handlers\ninterface WebSocketHandlersConfig {\n  ws: WebSocket;\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>;\n  reconnectAttemptsRef: React.MutableRefObject<number>;\n  maxReconnectAttempts: number;\n  handleMessage: (message: Record<string, unknown>) => void;\n  startHeartbeat: () => void;\n  stopHeartbeat: () => void;\n  attemptReconnect: () => void;\n}\n\n// Helper to setup WebSocket event handlers\nconst setupWebSocketHandlers = (config: WebSocketHandlersConfig) => {\n  const {\n    ws,\n    setSyncState,\n    reconnectAttemptsRef,\n    maxReconnectAttempts,\n    handleMessage,\n    startHeartbeat,\n    stopHeartbeat,\n    attemptReconnect,\n  } = config;\n  ws.onopen = () => {\n    // WebSocket connected\n    reconnectAttemptsRef.current = 0;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTED,\n    }));\n\n    // Start heartbeat\n    startHeartbeat();\n\n    // Rejoin previous channels\n    // Implementation would go here\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      handleMessage(message);\n    } catch {\n      // Failed to parse WebSocket message\n    }\n  };\n\n  ws.onclose = (event) => {\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.DISCONNECTED,\n    }));\n\n    stopHeartbeat();\n\n    if (\n      shouldAttemptReconnection(\n        event,\n        reconnectAttemptsRef.current,\n        maxReconnectAttempts,\n      )\n    ) {\n      attemptReconnect();\n    }\n  };\n\n  ws.onerror = (_error) => {\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.ERROR,\n      syncMetrics: updateSyncMetrics(prev.syncMetrics, \"error\"),\n    }));\n  };\n};\n\n// Helper to create message handlers\nconst createMessageHandlers = (\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n) => {\n  const handleChannelJoined = (message: { channel: SyncChannel }) => {\n    const channel: SyncChannel = message.channel;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: [\n        ...prev.activeChannels.filter((c) => c.id !== channel.id),\n        channel,\n      ],\n    }));\n  };\n\n  const handleChannelLeft = (message: { channelId: string }) => {\n    const channelId = message.channelId;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: prev.activeChannels.filter((c) => c.id !== channelId),\n    }));\n  };\n\n  const handleRealtimeUpdate = (message: { update: RealtimeUpdate }) => {\n    const update: RealtimeUpdate = message.update;\n\n    // Update local data\n    setSyncState((prev) => ({\n      ...prev,\n      realtimeData: {\n        ...prev.realtimeData,\n        [update.type]: update.data,\n      },\n    }));\n\n    // Notify subscribers - using object instead of Map\n    const subscriptionKeys = Object.keys(subscriptionsRef.current);\n    for (let i = 0; i < subscriptionKeys.length; i++) {\n      const key = subscriptionKeys[i];\n      const subscription = subscriptionsRef.current[key];\n      if (subscription.dataType === update.type && subscription.isActive) {\n        try {\n          subscription.callback(update);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    }\n  };\n\n  const handleMessage = (message: Record<string, unknown>) => {\n    setSyncState((prev) => ({\n      ...prev,\n      syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageReceived\"),\n    }));\n\n    switch (message.type) {\n      case \"channel_joined\":\n        handleChannelJoined(message as any);\n        break;\n      case \"channel_left\":\n        handleChannelLeft(message as any);\n        break;\n      case \"realtime_update\":\n        handleRealtimeUpdate(message as any);\n        break;\n      case \"heartbeat_ack\":\n        // Heartbeat acknowledged\n        break;\n      default:\n      // Unknown message type\n    }\n  };\n\n  return { handleMessage };\n};\n\n// Helper to create heartbeat functions\nconst createHeartbeatFunctions = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  heartbeatTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  heartbeatInterval: number,\n  sendMessage: (message: RealtimeUpdate | Record<string, unknown>) => void,\n) => {\n  const startHeartbeat = () => {\n    const sendHeartbeat = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({ type: \"heartbeat\", timestamp: new Date().toISOString() });\n        heartbeatTimeoutRef.current = setTimeout(\n          sendHeartbeat,\n          heartbeatInterval,\n        );\n      }\n    };\n\n    heartbeatTimeoutRef.current = setTimeout(sendHeartbeat, heartbeatInterval);\n  };\n\n  const stopHeartbeat = () => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n  };\n\n  return { startHeartbeat, stopHeartbeat };\n};\n\n// Config interface for WebSocket functions\nexport interface WebSocketFunctionsConfig {\n  userId: string;\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>;\n  wsRef: React.MutableRefObject<WebSocket | null>;\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>;\n  reconnectAttemptsRef: React.MutableRefObject<number>;\n  reconnectTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>;\n  heartbeatTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>;\n  connectionStartTimeRef: React.MutableRefObject<Date | null>;\n  maxReconnectAttempts: number;\n  reconnectInterval: number;\n  heartbeatInterval: number;\n}\n\n// Helper function to create WebSocket connection functions\nexport const createWebSocketFunctions = (config: WebSocketFunctionsConfig) => {\n  const {\n    userId,\n    setSyncState,\n    wsRef,\n    subscriptionsRef,\n    reconnectAttemptsRef,\n    reconnectTimeoutRef,\n    heartbeatTimeoutRef,\n    connectionStartTimeRef,\n    maxReconnectAttempts,\n    reconnectInterval,\n    heartbeatInterval,\n  } = config;\n  const sendMessage = createSendMessage(wsRef, setSyncState);\n\n  const { startHeartbeat, stopHeartbeat } = createHeartbeatFunctions(\n    wsRef,\n    heartbeatTimeoutRef,\n    heartbeatInterval,\n    sendMessage,\n  );\n\n  const { handleMessage } = createMessageHandlers(\n    setSyncState,\n    subscriptionsRef,\n  );\n\n  let connect: () => void;\n\n  const { attemptReconnect, disconnect } = createConnectionControlFunctions({\n    wsRef,\n    setSyncState,\n    reconnectAttemptsRef,\n    reconnectTimeoutRef,\n    maxReconnectAttempts,\n    reconnectInterval,\n    stopHeartbeat,\n    connect: () => connect(),\n  });\n\n  connect = createConnectFunction({\n    wsRef,\n    setSyncState,\n    connectionStartTimeRef,\n    reconnectAttemptsRef,\n    maxReconnectAttempts,\n    userId,\n    handleMessage,\n    startHeartbeat,\n    stopHeartbeat,\n    attemptReconnect,\n  });\n\n  return {\n    connect,\n    disconnect,\n    sendMessage,\n    startHeartbeat,\n    stopHeartbeat,\n  };\n};\n\n// Helper function to create channel management functions\nexport const createChannelFunctions = (\n  userId: string,\n  sendMessage: (message: RealtimeUpdate | Record<string, unknown>) => void,\n) => {\n  const joinChannel = async (channelId: string): Promise<void> => {\n    sendMessage({\n      type: \"join_channel\",\n      channelId,\n      userId,\n    });\n  };\n\n  const leaveChannel = async (channelId: string): Promise<void> => {\n    sendMessage({\n      type: \"leave_channel\",\n      channelId,\n      userId,\n    });\n  };\n\n  const createChannel = async (\n    type: ChannelType,\n    participants: string[],\n  ): Promise<SyncChannel> => {\n    const channel = createSyncChannel(type, userId, participants);\n\n    sendMessage({\n      type: \"create_channel\",\n      channel,\n      userId,\n    });\n\n    return channel;\n  };\n\n  return {\n    joinChannel,\n    leaveChannel,\n    createChannel,\n  };\n};\n\n// Helper function to create subscription functions\nexport const createRealtimeSubscriptionFunctions = (\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n) => {\n  const subscribeToUpdates = (\n    dataType: string,\n    callback: (update: RealtimeUpdate) => void,\n  ): Subscription => {\n    const subscription = createSubscription(dataType, callback);\n    subscriptionsRef.current[subscription.id] = subscription;\n\n    // Return unsubscribe function\n    return {\n      ...subscription,\n      unsubscribe: () => {\n        const sub = subscriptionsRef.current[subscription.id];\n        if (sub) {\n          sub.isActive = false;\n          delete subscriptionsRef.current[subscription.id];\n        }\n      },\n    } as Subscription & { unsubscribe: () => void };\n  };\n\n  const publishUpdate = async (_update: RealtimeUpdate): Promise<void> => {\n    // Implementation would send the update via WebSocket\n  };\n\n  return {\n    subscribeToUpdates,\n    publishUpdate,\n  };\n};\n\n// Helper function to create relationship sync functions\nexport const createRelationshipSyncFunctions = (\n  joinChannel: (channelId: string) => Promise<void>,\n) => {\n  const syncWithKeyholder = async (relationshipId: string): Promise<void> => {\n    const channelId = `relationship_${relationshipId}`;\n    await joinChannel(channelId);\n  };\n\n  const syncSessionData = async (sessionId: string): Promise<void> => {\n    const channelId = `session_${sessionId}`;\n    await joinChannel(channelId);\n  };\n\n  return {\n    syncWithKeyholder,\n    syncSessionData,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useLiveTimerComposed.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerControl.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (201). Maximum allowed is 150.",
        "line": 30,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 256,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerSubscriptions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerSync.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'updateIntervalRef' and 'updateTimerProgress'. Either include them or remove the dependency array.",
        "line": 137,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 137,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncInterval, updateIntervalRef, updateTimerProgress]",
            "fix": {
              "range": [3932, 3946],
              "text": "[syncInterval, updateIntervalRef, updateTimerProgress]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'syncActiveTimers' and 'syncIntervalRef'. Either include them or remove the dependency array.",
        "line": 154,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 154,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncActiveTimers, syncInterval, syncIntervalRef]",
            "fix": {
              "range": [4417, 4431],
              "text": "[syncActiveTimers, syncInterval, syncIntervalRef]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useNotifications.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/usePresence.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'activityTimeoutRef', 'lastActivityRef', and 'setAway'. Either include them or remove the dependency array.",
        "line": 101,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 101,
        "endColumn": 58,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]",
            "fix": {
              "range": [2580, 2632],
              "text": "[autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setAway', 'setOffline', and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 167,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 167,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setAway, setOffline, setOnline]",
            "fix": { "range": [4547, 4549], "text": "[setAway, setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setOffline' and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 184,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 184,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setOffline, setOnline]",
            "fix": { "range": [5024, 5026], "text": "[setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useRealtimeSync-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useRealtimeSync.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (248). Maximum allowed is 150.",
        "line": 40,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 363,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 40,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 363,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'stopHeartbeat'. Either include it or remove the dependency array.",
        "line": 86,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 86,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [stopHeartbeat]",
            "fix": { "range": [2505, 2507], "text": "[stopHeartbeat]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sendMessage'. Either include it or remove the dependency array.",
        "line": 125,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 125,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [heartbeatInterval, sendMessage]",
            "fix": { "range": [3669, 3688], "text": "[heartbeatInterval, sendMessage]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'handleChannelJoined', 'handleChannelLeft', and 'handleRealtimeUpdate'. Either include them or remove the dependency array.",
        "line": 178,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 178,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]",
            "fix": {
              "range": [5119, 5121],
              "text": "[handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'syncState.activeChannels'. Either include it or remove the dependency array.",
        "line": 245,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 253,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, startHeartbeat, stopHeartbeat, attemptReconnect, sendMessage, handleMessage, syncState.activeChannels, maxReconnectAttempts]",
            "fix": {
              "range": [6946, 7086],
              "text": "[userId, startHeartbeat, stopHeartbeat, attemptReconnect, sendMessage, handleMessage, syncState.activeChannels, maxReconnectAttempts]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/task-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipEventOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipInvites.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 94,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 94,
        "endColumn": 34,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipList.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadRelationships'. Either include it or remove the dependency array.",
        "line": 85,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 85,
        "endColumn": 14,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadRelationships, userId]",
            "fix": { "range": [2522, 2530], "text": "[loadRelationships, userId]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipPermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTaskOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useAuditLog.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/usePermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useSecuritySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/PauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/SessionGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useCooldownState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalComputedValues.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalInitialization.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievements', 'loadActiveGoals', 'loadGoalHistory', 'loadGoalTemplates', 'loadKeyholderGoals', and 'loadProgress'. Either include them or remove the dependency array. If 'loadActiveGoals' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 69,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 69,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]",
            "fix": {
              "range": [1881, 1905],
              "text": "[userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updateActiveGoalProgress'. Either include it or remove the dependency array. If 'updateActiveGoalProgress' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 79,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 79,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [updateActiveGoalProgress]",
            "fix": { "range": [2212, 2214], "text": "[updateActiveGoalProgress]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalMutations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalProgress.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalTemplates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useKeyholderGoalManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseDurationTracking.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updatePauseDuration'. Either include it or remove the dependency array. If 'updatePauseDuration' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 27,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 27,
        "endColumn": 56,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]",
            "fix": {
              "range": [808, 858],
              "text": "[pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseResume.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (332). Maximum allowed is 150.",
        "line": 61,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 474,
        "endColumn": 2
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'cooldownState.isInCooldown' and 'pauseStatus.isPaused'. Either include them or remove the dependency array.",
        "line": 229,
        "column": 5,
        "nodeType": "ArrayExpression",
        "endLine": 229,
        "endColumn": 38,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [canPause, cooldownState.isInCooldown, pauseStatus.isPaused, sessionId, startPause]",
            "fix": {
              "range": [7103, 7136],
              "text": "[canPause, cooldownState.isInCooldown, pauseStatus.isPaused, sessionId, startPause]"
            }
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (29). Maximum allowed is 25.",
        "line": 61,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 474,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sessionId'. Either include it or remove the dependency array.",
        "line": 150,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 150,
        "endColumn": 61,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]",
            "fix": {
              "range": [4705, 4760],
              "text": "[keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeKeyholderOverrides', 'loadCooldownState', 'loadPauseAnalytics', 'loadPauseHistory', and 'loadPauseState'. Either include them or remove the dependency array.",
        "line": 195,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 195,
        "endColumn": 33,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]",
            "fix": {
              "range": [5926, 5953],
              "text": "[sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Pause/Resume System Hook (Refactored)\n * Provides advanced pause/resume functionality with keyholder overrides,\n * intelligent cooldown management, and comprehensive analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { PauseCooldownService } from \"../../services/PauseCooldownService\";\nimport { useSharedTimer } from \"../useSharedTimer\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type {\n  PauseStatus as _PauseStatus,\n  CooldownState as _CooldownState,\n  KeyholderOverrideCapabilities,\n  PauseHistoryEntry as _PauseHistoryEntry,\n  PauseAnalytics,\n  PauseReason,\n  PauseRequestStatus,\n  OverrideRequestStatus,\n  PausePattern,\n  CooldownAnalytics,\n} from \"../../types/pauseResume\";\nimport {\n  calculatePauseFrequency,\n  calculateCooldownDuration,\n  calculatePauseAnalytics,\n  analyzePausePatterns,\n  calculateCooldownEffectiveness,\n} from \"../../utils/pauseAnalytics\";\nimport {\n  calculatePauseDuration,\n  updatePauseHistoryOnResume,\n  updatePauseStatusOnResume,\n  createKeyholderOverrides,\n} from \"../../utils/pauseResumeHelpers\";\nimport { usePauseState } from \"./usePauseState\";\nimport { useCooldownState } from \"./useCooldownState\";\nimport { usePauseDurationTracking } from \"./usePauseDurationTracking\";\n\nconst logger = serviceLogger(\"usePauseResume\");\n\nconst createInitialKeyholderOverrides = (): KeyholderOverrideCapabilities => ({\n  canOverrideCooldown: false,\n  canForcePause: false,\n  canForceResume: false,\n  canModifyCooldownDuration: false,\n  requiresReason: true,\n});\n\nconst createInitialPauseAnalytics = (): PauseAnalytics => ({\n  totalPauses: 0,\n  averagePauseDuration: 0,\n  pauseFrequency: 0,\n  emergencyPauseCount: 0,\n  keyholderInitiatedCount: 0,\n  cooldownViolations: 0,\n  patterns: [],\n});\n\n// Complex pause/resume logic with cooldown management and analytics\n// eslint-disable-next-line max-statements\nexport const usePauseResume = (sessionId: string, relationshipId?: string) => {\n  // Use shared timer for cooldown countdown\n  const currentTime = useSharedTimer();\n\n  // Use sub-hooks for state management\n  const {\n    pauseStatus,\n    pauseHistory,\n    setPauseStatus,\n    setPauseHistory,\n    startPause,\n    updatePauseDuration,\n  } = usePauseState(sessionId);\n\n  const { cooldownState, startCooldown, clearCooldown } = useCooldownState();\n\n  const [keyholderOverrides, setKeyholderOverrides] = useState(\n    createInitialKeyholderOverrides,\n  );\n  const [pauseAnalytics, setPauseAnalytics] = useState(\n    createInitialPauseAnalytics,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track pause duration\n  usePauseDurationTracking(pauseStatus, updatePauseDuration);\n\n  // Computed values\n  const canPause = useMemo(() => {\n    const result = !pauseStatus.isPaused && !cooldownState.isInCooldown;\n    logger.debug(\"usePauseResume canPause calculation\", {\n      sessionId,\n      isPaused: pauseStatus.isPaused,\n      isInCooldown: cooldownState.isInCooldown,\n      canPause: result,\n    });\n    return result;\n  }, [sessionId, pauseStatus.isPaused, cooldownState.isInCooldown]);\n\n  const canResume = useMemo(() => pauseStatus.isPaused, [pauseStatus.isPaused]);\n\n  const timeUntilNextPause = useMemo(() => {\n    if (!cooldownState.nextPauseAvailable) return 0;\n    return Math.max(\n      0,\n      Math.floor(\n        (cooldownState.nextPauseAvailable.getTime() - currentTime.getTime()) /\n          1000,\n      ),\n    );\n  }, [cooldownState.nextPauseAvailable, currentTime]);\n\n  const hasKeyholderOverride = useMemo(\n    () => keyholderOverrides.canOverrideCooldown,\n    [keyholderOverrides.canOverrideCooldown],\n  );\n\n  const pauseFrequency = useMemo(\n    () => calculatePauseFrequency(pauseHistory),\n    [pauseHistory],\n  );\n\n  // Initialize keyholder overrides\n  const initializeKeyholderOverrides = useCallback(() => {\n    if (relationshipId) {\n      setKeyholderOverrides(createKeyholderOverrides());\n    }\n  }, [relationshipId]);\n\n  // Load data functions\n  const loadPauseState = useCallback(async () => {\n    // Integration with pause state service\n  }, []);\n\n  const loadCooldownState = useCallback(async () => {\n    try {\n      const cooldownInfo = await PauseCooldownService.canUserPause(sessionId);\n      if (cooldownInfo && !cooldownInfo.canPause) {\n        startCooldown(\n          cooldownInfo.cooldownRemaining || 0,\n          keyholderOverrides.canOverrideCooldown,\n        );\n      }\n    } catch (err) {\n      logger.error(\"Failed to load cooldown state\", { error: err });\n    }\n    // sessionId is a stable prop from the component, safe to omit from deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [keyholderOverrides.canOverrideCooldown, startCooldown]);\n\n  const loadPauseHistory = useCallback(async () => {\n    // Load pause history from service\n  }, []);\n\n  const loadPauseAnalytics = useCallback(async () => {\n    try {\n      const analytics = calculatePauseAnalytics(pauseHistory);\n      setPauseAnalytics(analytics);\n    } catch (err) {\n      logger.error(\"Failed to load pause analytics\", { error: err });\n    }\n  }, [pauseHistory]);\n\n  // Initialization\n  useEffect(() => {\n    const initializePauseSystem = async () => {\n      if (!sessionId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        initializeKeyholderOverrides();\n        await Promise.all([\n          loadPauseState(),\n          loadCooldownState(),\n          loadPauseHistory(),\n          loadPauseAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize pause system\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize pause system\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializePauseSystem();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId, relationshipId]);\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason: PauseReason): Promise<void> => {\n      if (!sessionId || sessionId.trim() === \"\") {\n        const error = new Error(\"No active session to pause\");\n        logger.error(\"Pause session failed\", { error, sessionId });\n        throw error;\n      }\n\n      if (!canPause) {\n        logger.warn(\"Cannot pause: either already paused or in cooldown\", {\n          sessionId,\n          isPaused: pauseStatus.isPaused,\n          isInCooldown: cooldownState.isInCooldown,\n        });\n        return; // Just return instead of throwing\n      }\n\n      try {\n        logger.debug(\"Pausing session\", { sessionId, reason });\n\n        // Import sessionDBService dynamically to avoid circular dependencies\n        const { sessionDBService } = await import(\"../../services/database\");\n        await sessionDBService.pauseSession(sessionId, new Date());\n\n        startPause(reason);\n        logger.info(\"Session paused successfully\", { sessionId, reason });\n      } catch (err) {\n        logger.error(\"Failed to pause session\", { error: err, sessionId });\n        throw err;\n      }\n    },\n    [canPause, sessionId, startPause],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    if (!sessionId || sessionId.trim() === \"\") {\n      const error = new Error(\"No active session to resume\");\n      logger.error(\"Resume session failed\", { error, sessionId });\n      throw error;\n    }\n\n    if (!canResume) {\n      const error = new Error(\"Cannot resume: session is not paused\");\n      logger.error(\"Resume session failed\", { error, sessionId });\n      throw error;\n    }\n\n    try {\n      logger.debug(\"Resuming session\", { sessionId });\n\n      const resumeTime = new Date();\n      const duration = calculatePauseDuration(\n        pauseStatus.pauseStartTime,\n        resumeTime,\n      );\n\n      // Import sessionDBService dynamically to avoid circular dependencies\n      const { sessionDBService } = await import(\"../../services/database\");\n      await sessionDBService.resumeSession(sessionId, resumeTime);\n\n      setPauseStatus(updatePauseStatusOnResume(pauseStatus));\n      setPauseHistory((prev) =>\n        updatePauseHistoryOnResume(prev, resumeTime, duration),\n      );\n\n      const cooldownDur = calculateCooldownDuration(pauseAnalytics, duration);\n      logger.info(\"Starting cooldown after resume\", {\n        sessionId,\n        cooldownSeconds: cooldownDur,\n        pauseDuration: duration,\n      });\n      startCooldown(cooldownDur, keyholderOverrides.canOverrideCooldown);\n\n      logger.info(\"Session resumed successfully\", {\n        sessionId,\n        pauseDuration: duration,\n      });\n    } catch (err) {\n      logger.error(\"Failed to resume session\", { error: err, sessionId });\n      throw err;\n    }\n  }, [\n    canResume,\n    sessionId,\n    pauseStatus,\n    pauseAnalytics,\n    keyholderOverrides.canOverrideCooldown,\n    setPauseStatus,\n    setPauseHistory,\n    startCooldown,\n  ]);\n\n  // Emergency pause\n  const requestEmergencyPause = useCallback(\n    async (reason: string): Promise<PauseRequestStatus> => {\n      try {\n        logger.debug(\"Requesting emergency pause\", { sessionId, reason });\n\n        if (cooldownState.isInCooldown) {\n          logger.warn(\"Emergency pause bypassing cooldown\", { sessionId });\n        }\n\n        await pauseSession(\"emergency\");\n\n        return {\n          approved: true,\n          reason: \"Emergency pause approved automatically\",\n          requestId: `emergency_${Date.now()}`,\n          approvedBy: \"emergency_protocol\",\n          approvedAt: new Date(),\n        };\n      } catch (err) {\n        logger.error(\"Failed to request emergency pause\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `emergency_${Date.now()}`,\n        };\n      }\n    },\n    [sessionId, cooldownState.isInCooldown, pauseSession],\n  );\n\n  // Request cooldown override\n  const requestCooldownOverride = useCallback(\n    async (justification: string): Promise<OverrideRequestStatus> => {\n      if (!relationshipId) {\n        return {\n          approved: false,\n          reason: \"Cooldown override requires keyholder relationship\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n\n      try {\n        logger.debug(\"Requesting cooldown override\", {\n          sessionId,\n          justification,\n        });\n\n        return {\n          approved: false,\n          reason: \"Override request sent to keyholder\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      } catch (err) {\n        logger.error(\"Failed to request cooldown override\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n    },\n    [sessionId, relationshipId],\n  );\n\n  // Keyholder force pause\n  const keyholderForcePause = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForcePause) {\n        throw new Error(\"Keyholder does not have force pause permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing pause\", { sessionId, reason });\n        startPause(\"keyholder_request\", \"keyholder\");\n        logger.info(\"Keyholder force pause successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force pause\", { error: err });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForcePause, sessionId, startPause],\n  );\n\n  // Keyholder force resume\n  const keyholderForceResume = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForceResume) {\n        throw new Error(\"Keyholder does not have force resume permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing resume\", { sessionId, reason });\n        await resumeSession();\n        logger.info(\"Keyholder force resume successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force resume\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForceResume, sessionId, resumeSession],\n  );\n\n  // Keyholder override cooldown\n  const keyholderOverrideCooldown = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canOverrideCooldown) {\n        throw new Error(\n          \"Keyholder does not have cooldown override permissions\",\n        );\n      }\n\n      try {\n        logger.debug(\"Keyholder overriding cooldown\", { sessionId, reason });\n        clearCooldown();\n        logger.info(\"Keyholder cooldown override successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder cooldown override\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canOverrideCooldown, sessionId, clearCooldown],\n  );\n\n  // Analytics\n  const getPausePatterns = useCallback((): PausePattern[] => {\n    return analyzePausePatterns(pauseHistory);\n  }, [pauseHistory]);\n\n  const getCooldownEffectiveness = useCallback((): CooldownAnalytics => {\n    return {\n      effectiveness: calculateCooldownEffectiveness(\n        pauseHistory,\n        cooldownState,\n      ),\n      averageCooldownDuration: cooldownState.adaptiveDuration,\n      overrideFrequency: 0,\n      adaptiveAdjustments: 0,\n    };\n  }, [pauseHistory, cooldownState]);\n\n  return {\n    // Enhanced state\n    pauseStatus,\n    cooldownState,\n    keyholderOverrides,\n    pauseAnalytics,\n\n    // Basic actions\n    pauseSession,\n    resumeSession,\n\n    // Enhanced actions\n    requestEmergencyPause,\n    requestCooldownOverride,\n\n    // Keyholder actions\n    keyholderForcePause,\n    keyholderForceResume,\n    keyholderOverrideCooldown,\n\n    // Analytics\n    getPausePatterns,\n    getCooldownEffectiveness,\n\n    // Computed values\n    canPause,\n    canResume,\n    timeUntilNextPause,\n    hasKeyholderOverride,\n    pauseFrequency,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSession.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (367). Maximum allowed is 150.",
        "line": 135,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 615,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'sessionId' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 349,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 349,
        "endColumn": 24
      },
      {
        "ruleId": "max-lines",
        "severity": 2,
        "message": "File has too many lines (523). Maximum allowed is 500.",
        "line": 652,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 684,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (31). Maximum allowed is 25.",
        "line": 135,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 615,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAnalytics', 'loadCurrentSession', 'loadGoals', and 'loadHistory'. Either include them or remove the dependency array.",
        "line": 278,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 278,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]",
            "fix": {
              "range": [7818, 7842],
              "text": "[userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadCurrentSession'. Either include it or remove the dependency array.",
        "line": 573,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 573,
        "endColumn": 39,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, currentSession?.endTime, loadCurrentSession]",
            "fix": {
              "range": [16826, 16859],
              "text": "[userId, currentSession?.endTime, loadCurrentSession]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Session Management Hook\n * Provides comprehensive session management with keyholder integration,\n * goal tracking, and advanced analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { DBSession, DBGoal } from \"../../types/database\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { KeyholderRelationshipService } from \"../../services/KeyholderRelationshipService\";\nimport { sessionDBService } from \"../../services/database/SessionDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSession\");\n\n// ==================== INTERFACES ====================\n\nexport interface SessionGoals {\n  personal: DBGoal[];\n  keyholderAssigned: DBGoal[];\n  active: DBGoal[];\n}\n\nexport interface SessionContext {\n  userId: string;\n  relationshipId?: string;\n  sessionType: \"self_managed\" | \"keyholder_managed\" | \"collaborative\";\n  permissions: SessionPermission[];\n}\n\nexport interface KeyholderInfo {\n  id: string;\n  name: string;\n  lastSeen: Date;\n}\n\nexport interface KeyholderSessionControls {\n  canModify: boolean;\n  canOverride: boolean;\n  activeKeyholder: KeyholderInfo;\n  controlHistory: ControlAction[];\n}\n\nexport interface SessionAnalytics {\n  averageSessionLength: number;\n  completionRate: number;\n  goalAchievementRate: number;\n  totalSessions: number;\n  consistencyScore: number;\n}\n\nexport interface SessionInsights {\n  predictedDuration: number;\n  optimalGoalDuration: number;\n  completionProbability: number;\n  riskFactors: string[];\n  recommendations: string[];\n}\n\nexport interface PredictiveAnalytics {\n  nextSessionPrediction: {\n    suggestedDuration: number;\n    successProbability: number;\n    recommendedGoals: string[];\n  };\n  weeklyTrend: {\n    direction: \"improving\" | \"declining\" | \"stable\";\n    confidence: number;\n  };\n}\n\nexport interface SessionHistoryEntry {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  goals: DBGoal[];\n  completedGoals: string[];\n  notes?: string;\n  rating?: number;\n}\n\nexport interface EnhancedSessionState {\n  currentSession: DBSession | null;\n  sessionContext: SessionContext;\n  keyholderControls: KeyholderSessionControls | null;\n  goals: SessionGoals;\n  history: SessionHistoryEntry[];\n  analytics: SessionAnalytics;\n}\n\nexport type SessionPermission =\n  | \"start_session\"\n  | \"end_session\"\n  | \"modify_goals\"\n  | \"pause_session\"\n  | \"self_modify\"\n  | \"override_restrictions\";\n\nexport interface ControlAction {\n  id: string;\n  action: string;\n  timestamp: Date;\n  reason?: string;\n  performedBy: \"keyholder\" | \"submissive\" | \"system\";\n}\n\nexport interface SessionModifications {\n  goalDuration?: number;\n  goals?: Partial<DBGoal>[];\n  notes?: string;\n  endReason?: string;\n}\n\nexport interface ModificationRequest {\n  id: string;\n  type: \"goal_change\" | \"early_end\" | \"time_extension\";\n  requestedBy: string;\n  reason: string;\n  details: Record<string, unknown>;\n  status: \"pending\" | \"approved\" | \"rejected\";\n  createdAt: Date;\n}\n\nexport interface ApprovalStatus {\n  approved: boolean;\n  reason?: string;\n  approvedBy?: string;\n  approvedAt?: Date;\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session management hook with analytics, goals, and keyholder controls\n// eslint-disable-next-line max-statements\nexport const useSession = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [goals, setGoals] = useState<SessionGoals>({\n    personal: [],\n    keyholderAssigned: [],\n    active: [],\n  });\n  const [_history, setHistory] = useState<SessionHistoryEntry[]>([]);\n  const [keyholderControls, setKeyholderControls] =\n    useState<KeyholderSessionControls | null>(null);\n  const [analytics, setAnalytics] = useState<SessionAnalytics>({\n    averageSessionLength: 0,\n    completionRate: 0,\n    goalAchievementRate: 0,\n    totalSessions: 0,\n    consistencyScore: 0,\n  });\n  const [relationship, setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [currentTime, setCurrentTime] = useState(new Date());\n\n  // Update current time every second for live duration calculation\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCurrentTime(new Date());\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const sessionContext = useMemo((): SessionContext => {\n    if (!userId) {\n      return {\n        userId: \"\",\n        sessionType: \"self_managed\",\n        permissions: [],\n      };\n    }\n\n    return {\n      userId,\n      relationshipId,\n      sessionType: relationshipId\n        ? keyholderControls?.canModify\n          ? \"keyholder_managed\"\n          : \"collaborative\"\n        : \"self_managed\",\n      permissions: derivePermissions(relationship, keyholderControls),\n    };\n  }, [userId, relationshipId, keyholderControls, relationship]);\n\n  const isActive = useMemo(\n    () => currentSession?.endTime == null && currentSession != null,\n    [currentSession],\n  );\n\n  const duration = useMemo(\n    () => (currentSession ? calculateDuration(currentSession, currentTime) : 0),\n    [currentSession, currentTime],\n  );\n\n  const goalProgress = useMemo(\n    () => calculateGoalProgress(currentSession, goals),\n    [currentSession, goals],\n  );\n\n  const isUnderKeyholderControl = useMemo(\n    () => !!relationshipId && !!keyholderControls,\n    [relationshipId, keyholderControls],\n  );\n\n  const canSelfModify = useMemo(\n    () =>\n      !keyholderControls?.canModify ||\n      sessionContext.permissions.includes(\"self_modify\"),\n    [keyholderControls, sessionContext.permissions],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSession = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship if provided\n        if (relationshipId) {\n          const relationships =\n            await KeyholderRelationshipService.getUserRelationships(userId);\n          const activeRelationship =\n            relationships.asSubmissive.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            ) ||\n            relationships.asKeyholder.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            );\n\n          setRelationship(activeRelationship || null);\n\n          if (activeRelationship) {\n            setKeyholderControls({\n              canModify:\n                activeRelationship.permissions.canLockSessions || false,\n              canOverride:\n                activeRelationship.permissions.canUnlockSessions || false,\n              activeKeyholder: {\n                id: activeRelationship.keyholderUserId,\n                name: \"Keyholder\", // Would get from user profile\n                lastSeen: new Date(),\n              },\n              controlHistory: [],\n            });\n          }\n        }\n\n        // Load current session, goals, history, and analytics\n        await Promise.all([\n          loadCurrentSession(),\n          loadGoals(),\n          loadHistory(),\n          loadAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSession();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadCurrentSession = useCallback(async () => {\n    if (!userId) return;\n\n    try {\n      const session = await sessionDBService.getCurrentSession(userId);\n      setCurrentSession(session || null);\n      logger.info(\"Loaded current session\", {\n        userId,\n        sessionId: session?.id,\n        hasSession: !!session,\n      });\n    } catch (error) {\n      logger.error(\"Failed to load current session\", {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n        userId,\n      });\n      setCurrentSession(null);\n    }\n  }, [userId]);\n\n  const loadGoals = useCallback(async () => {\n    // This would integrate with your existing goals service\n    setGoals({\n      personal: [],\n      keyholderAssigned: [],\n      active: [],\n    });\n  }, []); // userId and relationshipId are passed but not used in mock\n\n  const loadHistory = useCallback(async () => {\n    // This would integrate with your existing history service\n    setHistory([]);\n  }, []); // userId is passed but not used in mock\n\n  const loadAnalytics = useCallback(async () => {\n    // This would integrate with your existing analytics service\n    setAnalytics({\n      averageSessionLength: 0,\n      completionRate: 0,\n      goalAchievementRate: 0,\n      totalSessions: 0,\n      consistencyScore: 0,\n    });\n  }, []); // userId is passed but not used in mock\n\n  // ==================== SESSION LIFECYCLE ====================\n\n  const startSession = useCallback(\n    async (sessionGoals?: SessionGoals): Promise<DBSession> => {\n      if (!userId) throw new Error(\"User ID required to start session\");\n\n      try {\n        logger.debug(\"Starting new session\", {\n          userId,\n          hasGoals: !!sessionGoals,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"start_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to start session\");\n        }\n\n        // Save session to database\n        const sessionId = await sessionDBService.startSession(userId, {\n          isHardcoreMode: false,\n          keyholderApprovalRequired:\n            sessionContext.sessionType === \"keyholder_managed\",\n        });\n\n        // Load the newly created session\n        const newSession = await sessionDBService.getCurrentSession(userId);\n        if (!newSession) {\n          throw new Error(\"Failed to load newly created session\");\n        }\n\n        // Add goals if provided\n        if (sessionGoals) {\n          await setGoals(sessionGoals);\n        }\n\n        setCurrentSession(newSession);\n        logger.info(\"Session started successfully\", {\n          sessionId: newSession.id,\n        });\n\n        return newSession;\n      } catch (error) {\n        logger.error(\"Failed to start session\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionContext],\n  );\n\n  const stopSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to stop\");\n\n      try {\n        logger.debug(\"Stopping session\", {\n          sessionId: currentSession.id,\n          reason,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"end_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to end session\");\n        }\n\n        const endTime = new Date();\n\n        // End session in database\n        await sessionDBService.endSession(currentSession.id, endTime, reason);\n\n        // Update local session with endTime (don't set to null - we need it for off-time tracking)\n        setCurrentSession({\n          ...currentSession,\n          endTime,\n          isPaused: false,\n        });\n\n        await loadHistory(); // Refresh history\n        await loadAnalytics(); // Refresh analytics\n\n        logger.info(\"Session stopped successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to stop session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, sessionContext, loadHistory, loadAnalytics],\n  );\n\n  // ==================== ENHANCED CONTROLS ====================\n\n  const modifySession = useCallback(\n    async (modifications: SessionModifications): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to modify\");\n\n      if (!canSelfModify) {\n        throw new Error(\"Session modification requires keyholder approval\");\n      }\n\n      try {\n        logger.debug(\"Modifying session\", {\n          sessionId: currentSession.id,\n          modifications,\n        });\n\n        // Update session in database\n        await sessionDBService.update(currentSession.id, {\n          ...modifications,\n          lastModified: new Date(),\n        });\n\n        // Reload the session\n        const updatedSession = await sessionDBService.get(currentSession.id);\n        setCurrentSession(updatedSession || null);\n\n        logger.info(\"Session modified successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to modify session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, canSelfModify],\n  );\n\n  const setSessionGoals = useCallback(\n    async (sessionGoals: SessionGoals): Promise<void> => {\n      if (!sessionContext.permissions.includes(\"modify_goals\")) {\n        throw new Error(\"Goal modification requires appropriate permissions\");\n      }\n\n      try {\n        logger.debug(\"Setting session goals\", {\n          userId,\n          goalCount: sessionGoals.active.length,\n        });\n        setGoals(sessionGoals);\n        logger.info(\"Session goals updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to set session goals\", { error });\n        throw error;\n      }\n    },\n    [sessionContext.permissions, userId],\n  );\n\n  const requestModification = useCallback(\n    async (request: ModificationRequest): Promise<void> => {\n      if (!relationshipId)\n        throw new Error(\"Modification requests require active relationship\");\n\n      try {\n        logger.debug(\"Creating modification request\", {\n          requestId: request.id,\n          type: request.type,\n        });\n        // This would integrate with your notification/request system\n        logger.info(\"Modification request created successfully\", {\n          requestId: request.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to create modification request\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const requestKeyholderApproval = useCallback(\n    async (action: string): Promise<ApprovalStatus> => {\n      if (!keyholderControls) {\n        return { approved: true }; // Auto-approve if no keyholder control\n      }\n\n      try {\n        logger.debug(\"Requesting keyholder approval\", {\n          action,\n          keyholderId: keyholderControls.activeKeyholder.id,\n        });\n\n        // This would integrate with your keyholder notification system\n        // For now, return pending status\n        return {\n          approved: false,\n          reason: \"Approval request sent to keyholder\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to request keyholder approval\", { error });\n        throw error;\n      }\n    },\n    [keyholderControls],\n  );\n\n  // ==================== ANALYTICS AND INSIGHTS ====================\n\n  const getSessionInsights = useCallback((): SessionInsights => {\n    return {\n      predictedDuration: analytics.averageSessionLength,\n      optimalGoalDuration: analytics.averageSessionLength * 1.2,\n      completionProbability: analytics.completionRate,\n      riskFactors: [],\n      recommendations: [],\n    };\n  }, [analytics]);\n\n  const getPredictiveAnalytics = useCallback((): PredictiveAnalytics => {\n    return {\n      nextSessionPrediction: {\n        suggestedDuration: analytics.averageSessionLength,\n        successProbability: analytics.completionRate,\n        recommendedGoals: [\"Duration Goal\", \"Consistency Goal\"],\n      },\n      weeklyTrend: {\n        direction: \"stable\",\n        confidence: 0.8,\n      },\n    };\n  }, [analytics]);\n\n  // ==================== SESSION POLLING ====================\n\n  // Poll for session updates every 5 seconds (only if session is active)\n  useEffect(() => {\n    if (!userId) return;\n\n    // Don't poll if session has ended - we want to keep the ended session for off-time tracking\n    if (currentSession?.endTime) return;\n\n    const intervalId = setInterval(() => {\n      loadCurrentSession();\n    }, 5000);\n\n    return () => clearInterval(intervalId);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, currentSession?.endTime]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Enhanced state\n    session: currentSession,\n    context: sessionContext,\n    keyholderControls,\n    goals,\n    analytics,\n\n    // Session lifecycle\n    startSession,\n    stopSession,\n\n    // Enhanced controls\n    modifySession,\n    setGoals: setSessionGoals,\n    requestModification,\n\n    // Keyholder integration\n    requestKeyholderApproval,\n\n    // Analytics and insights\n    getSessionInsights,\n    getPredictiveAnalytics,\n\n    // Computed values\n    isActive,\n    duration,\n    goalProgress,\n    isUnderKeyholderControl,\n    canSelfModify,\n\n    // Loading states\n    isLoading,\n    error,\n\n    // Utility\n    refreshSession: loadCurrentSession,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction derivePermissions(\n  relationship: KeyholderRelationship | null,\n  controls: KeyholderSessionControls | null,\n): SessionPermission[] {\n  const permissions: SessionPermission[] = [];\n\n  if (!relationship || !controls) {\n    // Self-managed session - all permissions\n    return [\n      \"start_session\",\n      \"end_session\",\n      \"modify_goals\",\n      \"pause_session\",\n      \"self_modify\",\n    ];\n  }\n\n  // Keyholder-managed permissions\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"start_session\");\n  if (relationship.permissions.canUnlockSessions)\n    permissions.push(\"end_session\");\n  if (relationship.permissions.canEditGoals) permissions.push(\"modify_goals\");\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"pause_session\");\n  // Add basic self-modify permission for submissives\n  permissions.push(\"self_modify\");\n  if (controls.canOverride) permissions.push(\"override_restrictions\");\n\n  return permissions;\n}\n\nfunction calculateDuration(session: DBSession, currentTime: Date): number {\n  if (!session.startTime) return 0;\n\n  // Calculate effective time (excluding pauses)\n  const endTime = session.endTime || currentTime;\n  const totalElapsedMs = endTime.getTime() - session.startTime.getTime();\n  const totalElapsedSeconds = Math.floor(totalElapsedMs / 1000);\n\n  // Subtract accumulated pause time\n  let effectiveSeconds =\n    totalElapsedSeconds - (session.accumulatedPauseTime || 0);\n\n  // If currently paused, also subtract current pause duration\n  if (session.isPaused && session.pauseStartTime && !session.endTime) {\n    const currentPauseMs =\n      currentTime.getTime() - session.pauseStartTime.getTime();\n    const currentPauseSeconds = Math.floor(currentPauseMs / 1000);\n    effectiveSeconds -= currentPauseSeconds;\n  }\n\n  return Math.max(0, effectiveSeconds);\n}\n\nfunction calculateGoalProgress(\n  session: DBSession | null,\n  goals: SessionGoals | null | undefined,\n): number {\n  if (!session || !goals || !goals.active || goals.active.length === 0)\n    return 0;\n\n  const completedGoals = goals.active.filter((goal) => goal.isCompleted).length;\n  return Math.floor((completedGoals / goals.active.length) * 100);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionActions.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 1,
        "message": "'DBSession' is not defined.",
        "line": 245,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 245,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 246,
        "column": 10,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 246,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6543, 6546], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6543, 6546], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Actions Hook\n * Provides session control operations (start, end, pause, resume, lock, unlock)\n * Extracts session action logic from ActionButtons component\n */\nimport { useState, useCallback, useMemo } from \"react\";\nimport { useSession } from \"./useSession\";\nimport { usePauseResume } from \"./usePauseResume\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type { DBGoal } from \"../../types/database\";\n\nconst logger = serviceLogger(\"useSessionActions\");\n\n/**\n * Helper function to handle session start\n */\nasync function handleStartSession(\n  canStart: boolean,\n  userId: string,\n  config: SessionConfig | undefined,\n  actions: {\n    startSessionCore: (config: {\n      goalDuration?: number;\n      isHardcoreMode: boolean;\n      keyholderApprovalRequired: boolean;\n      notes?: string;\n    }) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setIsStarting: (value: boolean) => void;\n    setError: (error: Error | null) => void;\n    onSessionStarted?: () => void;\n  },\n): Promise<void> {\n  if (!canStart) {\n    const err = new Error(\"Cannot start session\");\n    actions.handleError(err, \"Start session\");\n    return;\n  }\n\n  actions.setIsStarting(true);\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Starting session\", { userId, config });\n\n    await actions.startSessionCore({\n      goalDuration: config?.goalDuration,\n      isHardcoreMode: config?.isHardcoreMode || false,\n      keyholderApprovalRequired: config?.keyholderApprovalRequired || false,\n      notes: config?.notes,\n    });\n\n    logger.info(\"Session started successfully\", { userId });\n    actions.onSessionStarted?.();\n  } catch (err) {\n    actions.handleError(err, \"Start session\");\n    throw err;\n  } finally {\n    actions.setIsStarting(false);\n  }\n}\n\n/**\n * Helper function to handle session end\n */\nasync function handleEndSession(\n  canEnd: boolean,\n  userId: string,\n  reason: string | undefined,\n  actions: {\n    stopSessionCore: (reason: string) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setIsEnding: (value: boolean) => void;\n    setError: (error: Error | null) => void;\n    onSessionEnded?: () => void;\n  },\n): Promise<void> {\n  if (!canEnd) {\n    const err = new Error(\"Cannot end session\");\n    actions.handleError(err, \"End session\");\n    return;\n  }\n\n  actions.setIsEnding(true);\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Ending session\", { userId, reason });\n\n    await actions.stopSessionCore(reason || \"User ended session\");\n\n    logger.info(\"Session ended successfully\", { userId });\n    actions.onSessionEnded?.();\n  } catch (err) {\n    actions.handleError(err, \"End session\");\n    throw err;\n  } finally {\n    actions.setIsEnding(false);\n  }\n}\n\n/**\n * Helper function to handle session pause\n */\nasync function handlePauseSession(\n  canPause: boolean,\n  userId: string,\n  reason: string | undefined,\n  actions: {\n    pauseSessionCore: (reason: string) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setError: (error: Error | null) => void;\n    onSessionPaused?: () => void;\n  },\n): Promise<void> {\n  if (!canPause) {\n    const err = new Error(\"Cannot pause session\");\n    actions.handleError(err, \"Pause session\");\n    return;\n  }\n\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Pausing session\", { userId, reason });\n\n    await actions.pauseSessionCore(reason || \"bathroom\");\n\n    logger.info(\"Session paused successfully\", { userId });\n    actions.onSessionPaused?.();\n  } catch (err) {\n    actions.handleError(err, \"Pause session\");\n    throw err;\n  }\n}\n\n/**\n * Helper function to handle session resume\n */\nasync function handleResumeSession(\n  canResume: boolean,\n  userId: string,\n  actions: {\n    resumeSessionCore: () => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setError: (error: Error | null) => void;\n    onSessionResumed?: () => void;\n  },\n): Promise<void> {\n  if (!canResume) {\n    const err = new Error(\"Cannot resume session\");\n    actions.handleError(err, \"Resume session\");\n    return;\n  }\n\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Resuming session\", { userId });\n\n    await actions.resumeSessionCore();\n\n    logger.info(\"Session resumed successfully\", { userId });\n    actions.onSessionResumed?.();\n  } catch (err) {\n    actions.handleError(err, \"Resume session\");\n    throw err;\n  }\n}\n\n/**\n * Helper hook to calculate session action permissions\n */\nfunction useSessionPermissions(params: {\n  isActive: boolean;\n  canSelfModify: boolean;\n  isStarting: boolean;\n  isEnding: boolean;\n  isPaused: boolean;\n  pauseStatus: { canResume: boolean };\n  cooldownState: { isInCooldown: boolean };\n}) {\n  const canStart = useMemo(() => {\n    return !params.isActive && params.canSelfModify && !params.isStarting;\n  }, [params.isActive, params.canSelfModify, params.isStarting]);\n\n  const canEnd = useMemo(() => {\n    return params.isActive && params.canSelfModify && !params.isEnding;\n  }, [params.isActive, params.canSelfModify, params.isEnding]);\n\n  const canPause = useMemo(() => {\n    const result =\n      params.isActive && !params.isPaused && !params.cooldownState.isInCooldown;\n    logger.debug(\"Calculating canPause\", {\n      isActive: params.isActive,\n      isPaused: params.isPaused,\n      isInCooldown: params.cooldownState.isInCooldown,\n      canPause: result,\n    });\n    return result;\n  }, [params.isActive, params.isPaused, params.cooldownState.isInCooldown]);\n\n  const canResume = useMemo(() => {\n    return params.isActive && params.isPaused && params.pauseStatus.canResume;\n  }, [params.isActive, params.isPaused, params.pauseStatus.canResume]);\n\n  return { canStart, canEnd, canPause, canResume };\n}\n\nexport interface SessionConfig {\n  goalDuration?: number;\n  isHardcoreMode?: boolean;\n  keyholderApprovalRequired?: boolean;\n  goals?: DBGoal[];\n  notes?: string;\n}\n\nexport interface UseSessionActionsReturn {\n  // Actions\n  startSession: (config?: SessionConfig) => Promise<void>;\n  endSession: (reason?: string) => Promise<void>;\n  pauseSession: (reason?: string) => Promise<void>;\n  resumeSession: () => Promise<void>;\n\n  // State\n  isStarting: boolean;\n  isEnding: boolean;\n  isPausing: boolean;\n  isResuming: boolean;\n\n  // Permissions\n  canStart: boolean;\n  canEnd: boolean;\n  canPause: boolean;\n  canResume: boolean;\n\n  // Error handling\n  error: Error | null;\n  clearError: () => void;\n\n  // Current session info\n  isActive: boolean;\n  isPaused: boolean;\n  sessionId: string | null;\n  session: DBSession | null;\n  goals: any; // TODO: Type this properly\n  duration: number;\n\n  // Pause/cooldown info\n  timeUntilNextPause: number;\n  cooldownRemaining: number;\n}\n\nexport interface UseSessionActionsOptions {\n  userId: string;\n  onSessionStarted?: () => void;\n  onSessionEnded?: () => void;\n  onSessionPaused?: () => void;\n  onSessionResumed?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport function useSessionActions({\n  userId,\n  onSessionStarted,\n  onSessionEnded,\n  onSessionPaused,\n  onSessionResumed,\n  onError,\n}: UseSessionActionsOptions): UseSessionActionsReturn {\n  const [isStarting, setIsStarting] = useState(false);\n  const [isEnding, setIsEnding] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Use existing session management hooks\n  const {\n    session,\n    isActive,\n    startSession: startSessionCore,\n    stopSession: stopSessionCore,\n    canSelfModify,\n    refreshSession,\n    duration: sessionDuration,\n  } = useSession(userId);\n\n  const {\n    pauseStatus,\n    cooldownState,\n    pauseSession: pauseSessionCore,\n    resumeSession: resumeSessionCore,\n    timeUntilNextPause,\n  } = usePauseResume(session?.id || \"\", undefined);\n  const isPaused = pauseStatus.isPaused;\n  const isPausing = pauseStatus.pauseCount > 0 && pauseStatus.isPaused;\n  const isResuming = false;\n\n  logger.debug(\"Session state for permissions\", {\n    isActive,\n    canSelfModify,\n    isPaused,\n    sessionId: session?.id,\n    cooldownIsInCooldown: cooldownState.isInCooldown,\n    pauseStatusIsPaused: pauseStatus.isPaused,\n  });\n\n  const { canStart, canEnd, canPause, canResume } = useSessionPermissions({\n    isActive,\n    canSelfModify,\n    isStarting,\n    isEnding,\n    isPaused,\n    pauseStatus,\n    cooldownState,\n  });\n\n  const clearError = useCallback(() => setError(null), []);\n\n  // Handle errors internally\n  const handleError = useCallback(\n    (err: unknown, context: string) => {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      logger.error(`${context} failed`, {\n        error,\n        errorMessage: error.message,\n        errorStack: error.stack,\n        userId,\n      });\n      onError?.(error);\n      return error;\n    },\n    [userId, onError],\n  );\n\n  const startSession = useCallback(\n    async (config?: SessionConfig): Promise<void> => {\n      await handleStartSession(canStart, userId, config, {\n        startSessionCore,\n        handleError,\n        setIsStarting,\n        setError,\n        onSessionStarted,\n      });\n    },\n    [canStart, userId, startSessionCore, handleError, onSessionStarted],\n  );\n\n  const endSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      await handleEndSession(canEnd, userId, reason, {\n        stopSessionCore,\n        handleError,\n        setIsEnding,\n        setError,\n        onSessionEnded,\n      });\n    },\n    [canEnd, userId, stopSessionCore, handleError, onSessionEnded],\n  );\n\n  const pauseSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      await handlePauseSession(canPause, userId, reason, {\n        pauseSessionCore,\n        handleError,\n        setError,\n        onSessionPaused,\n      });\n      // Immediately refresh session to update UI\n      await refreshSession();\n    },\n    [\n      canPause,\n      userId,\n      pauseSessionCore,\n      handleError,\n      onSessionPaused,\n      refreshSession,\n    ],\n  );\n\n  const resumeSession = useCallback(async (): Promise<void> => {\n    await handleResumeSession(canResume, userId, {\n      resumeSessionCore,\n      handleError,\n      setError,\n      onSessionResumed,\n    });\n    // Immediately refresh session to update UI\n    await refreshSession();\n  }, [\n    canResume,\n    userId,\n    resumeSessionCore,\n    handleError,\n    onSessionResumed,\n    refreshSession,\n  ]);\n\n  return {\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n    isStarting,\n    isEnding,\n    isPausing,\n    isResuming,\n    canStart,\n    canEnd,\n    canPause,\n    canResume,\n    error,\n    clearError,\n    isActive,\n    isPaused,\n    sessionId: session?.id || null,\n    session,\n    goals: null, // TODO: Add goals from useSession\n    duration: sessionDuration,\n    timeUntilNextPause,\n    cooldownRemaining: timeUntilNextPause,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistory.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (351). Maximum allowed is 150.",
        "line": 54,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 494,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (30). Maximum allowed is 25.",
        "line": 54,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 494,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'calculateInsights', 'calculateTrends', 'loadPrivacySettings', and 'loadSessions'. Either include them or remove the dependency array.",
        "line": 178,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 185,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]",
            "fix": {
              "range": [5565, 5741],
              "text": "[userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session History Management Hook\n * Provides comprehensive session history with privacy controls,\n * data visualization support, and keyholder access management\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  createEmptyTrendData,\n  calculateOverallCompletionRate,\n  calculateLongestStreak,\n  calculatePauseFrequency,\n  calculateImprovementTrend,\n  calculateConsistencyScore,\n  calculateSessionLengthTrend,\n  calculateGoalCompletionTrend,\n  calculateConsistencyTrend,\n  calculatePauseFrequencyTrend,\n  calculateOverallProgressTrend,\n} from \"../../utils/sessionHistoryHelpers\";\nimport {\n  getSessionsByDateRange as getSessionsByDateRangeUtil,\n  getSessionsByGoal as getSessionsByGoalUtil,\n  searchSessions as searchSessionsUtil,\n  getKeyholderView as getKeyholderViewUtil,\n  getPerformanceTrends as getPerformanceTrendsUtil,\n  getGoalProgressHistory as getGoalProgressHistoryUtil,\n  getComparisonMetrics as getComparisonMetricsUtil,\n} from \"../../utils/session-history-helpers\";\nimport type {\n  HistoricalSession,\n  HistoryPrivacySettings,\n  KeyholderHistoryAccess,\n  HistoryInsights,\n  HistoryTrends,\n  HistorySearchQuery,\n  PersonalDataExport,\n  KeyholderHistoryView,\n  PerformanceTrends,\n  GoalProgressHistory,\n  ComparisonMetrics,\n} from \"./types/sessionHistory\";\n\n// Re-export types for backward compatibility\nexport type * from \"./types/sessionHistory\";\n\nconst logger = serviceLogger(\"useSessionHistory\");\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session history management with privacy controls and analytics\n// eslint-disable-next-line max-statements\nexport const useSessionHistory = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessions, setSessions] = useState<HistoricalSession[]>([]);\n  const [privacySettings, setPrivacySettings] =\n    useState<HistoryPrivacySettings>({\n      shareWithKeyholder: false,\n      shareDuration: true,\n      shareGoals: true,\n      sharePauses: false,\n      shareNotes: false,\n      shareRatings: false,\n      retentionPeriod: 365, // 1 year\n      allowExport: true,\n      anonymizeOldData: false,\n    });\n  const [keyholderAccess, setKeyholderAccess] =\n    useState<KeyholderHistoryAccess>({\n      hasAccess: false,\n      accessLevel: \"summary\",\n      canViewRatings: false,\n      canViewNotes: false,\n      canViewPauses: false,\n    });\n  const [insights, setInsights] = useState<HistoryInsights>({\n    totalSessions: 0,\n    totalEffectiveTime: 0,\n    averageSessionLength: 0,\n    longestSession: {} as HistoricalSession,\n    shortestSession: {} as HistoricalSession,\n    mostRecentSession: {} as HistoricalSession,\n    goalCompletionRate: 0,\n    pauseFrequency: 0,\n    improvementTrend: \"stable\",\n    consistencyScore: 0,\n  });\n  const [trends, setTrends] = useState<HistoryTrends>({\n    sessionLength: createEmptyTrendData(),\n    goalCompletion: createEmptyTrendData(),\n    consistency: createEmptyTrendData(),\n    pauseFrequency: createEmptyTrendData(),\n    overallProgress: createEmptyTrendData(),\n  });\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalSessions = useMemo(() => sessions.length, [sessions]);\n\n  const averageSessionLength = useMemo(\n    () =>\n      sessions.length > 0\n        ? sessions.reduce(\n            (sum, session) => sum + session.effectiveDuration,\n            0,\n          ) / sessions.length\n        : 0,\n    [sessions],\n  );\n\n  const goalCompletionRate = useMemo(\n    () => calculateOverallCompletionRate(sessions),\n    [sessions],\n  );\n\n  const longestStreak = useMemo(\n    () => calculateLongestStreak(sessions),\n    [sessions],\n  );\n\n  const hasPrivacyRestrictions = useMemo(\n    () => !privacySettings.shareWithKeyholder,\n    [privacySettings.shareWithKeyholder],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeHistory = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // Set keyholder access based on relationship permissions\n          setKeyholderAccess({\n            hasAccess: privacySettings.shareWithKeyholder,\n            accessLevel: privacySettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: privacySettings.shareRatings,\n            canViewNotes: privacySettings.shareNotes,\n            canViewPauses: privacySettings.sharePauses,\n          });\n        }\n\n        // Load historical data\n        await Promise.all([\n          loadSessions(),\n          loadPrivacySettings(),\n          calculateInsights(),\n          calculateTrends(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session history\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize session history\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeHistory();\n    // Store actions and stable callbacks should not be in dependency arrays\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    userId,\n    relationshipId,\n    privacySettings.shareWithKeyholder,\n    privacySettings.shareRatings,\n    privacySettings.shareNotes,\n    privacySettings.sharePauses,\n  ]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessions = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Load sessions with privacy filtering applied\n      const allSessions: HistoricalSession[] = [];\n\n      // Apply retention policy\n      const retentionDate = new Date();\n      retentionDate.setDate(\n        retentionDate.getDate() - privacySettings.retentionPeriod,\n      );\n\n      const filteredSessions = allSessions.filter(\n        (session) => session.startTime >= retentionDate,\n      );\n\n      setSessions(filteredSessions);\n    } catch (error) {\n      logger.error(\"Failed to load sessions\", { error });\n    }\n  }, [privacySettings.retentionPeriod]);\n\n  const loadPrivacySettings = useCallback(async () => {\n    try {\n      // Load user's privacy preferences from database\n      // For now, use defaults\n    } catch (error) {\n      logger.error(\"Failed to load privacy settings\", { error });\n    }\n  }, []);\n\n  const calculateInsights = useCallback(async () => {\n    try {\n      if (sessions.length === 0) return;\n\n      const totalEffectiveTime = sessions.reduce(\n        (sum, s) => sum + s.effectiveDuration,\n        0,\n      );\n      const sortedByDuration = [...sessions].sort(\n        (a, b) => b.effectiveDuration - a.effectiveDuration,\n      );\n      const sortedByDate = [...sessions].sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n\n      const newInsights: HistoryInsights = {\n        totalSessions: sessions.length,\n        totalEffectiveTime,\n        averageSessionLength: totalEffectiveTime / sessions.length,\n        longestSession: sortedByDuration[0],\n        shortestSession: sortedByDuration[sortedByDuration.length - 1],\n        mostRecentSession: sortedByDate[0],\n        goalCompletionRate: calculateOverallCompletionRate(sessions),\n        pauseFrequency: calculatePauseFrequency(sessions),\n        improvementTrend: calculateImprovementTrend(sessions),\n        consistencyScore: calculateConsistencyScore(sessions),\n      };\n\n      setInsights(newInsights);\n    } catch (error) {\n      logger.error(\"Failed to calculate insights\", { error });\n    }\n  }, [sessions]);\n\n  const calculateTrends = useCallback(async () => {\n    try {\n      const newTrends: HistoryTrends = {\n        sessionLength: calculateSessionLengthTrend(sessions),\n        goalCompletion: calculateGoalCompletionTrend(sessions),\n        consistency: calculateConsistencyTrend(sessions),\n        pauseFrequency: calculatePauseFrequencyTrend(sessions),\n        overallProgress: calculateOverallProgressTrend(sessions),\n      };\n\n      setTrends(newTrends);\n    } catch (error) {\n      logger.error(\"Failed to calculate trends\", { error });\n    }\n  }, [sessions]);\n\n  // ==================== DATA RETRIEVAL ====================\n\n  const getSessionsByDateRange = useCallback(\n    (start: Date, end: Date): HistoricalSession[] =>\n      getSessionsByDateRangeUtil(sessions, start, end),\n    [sessions],\n  );\n\n  const getSessionsByGoal = useCallback(\n    (goalType: string): HistoricalSession[] =>\n      getSessionsByGoalUtil(sessions, goalType),\n    [sessions],\n  );\n\n  const searchSessions = useCallback(\n    (query: HistorySearchQuery): HistoricalSession[] =>\n      searchSessionsUtil(sessions, query),\n    [sessions],\n  );\n\n  // ==================== PRIVACY MANAGEMENT ====================\n\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<HistoryPrivacySettings>): Promise<void> => {\n      try {\n        logger.debug(\"Updating privacy settings\", { settings });\n\n        const updatedSettings = { ...privacySettings, ...settings };\n        setPrivacySettings(updatedSettings);\n\n        // Update keyholder access based on new settings\n        if (relationshipId) {\n          setKeyholderAccess((prev) => ({\n            ...prev,\n            hasAccess: updatedSettings.shareWithKeyholder,\n            accessLevel: updatedSettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: updatedSettings.shareRatings,\n            canViewNotes: updatedSettings.shareNotes,\n            canViewPauses: updatedSettings.sharePauses,\n          }));\n        }\n\n        // Reload sessions if retention period changed\n        if (\n          settings.retentionPeriod &&\n          settings.retentionPeriod !== privacySettings.retentionPeriod\n        ) {\n          await loadSessions();\n        }\n\n        logger.info(\"Privacy settings updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update privacy settings\", { error });\n        throw error;\n      }\n    },\n    [privacySettings, relationshipId, loadSessions],\n  );\n\n  const exportPersonalData =\n    useCallback(async (): Promise<PersonalDataExport> => {\n      try {\n        logger.debug(\"Exporting personal data\", { userId });\n\n        const exportData: PersonalDataExport = {\n          exportId: `export_${Date.now()}`,\n          generatedAt: new Date(),\n          format: \"json\",\n          data: {\n            sessions,\n            goals: sessions.flatMap((s) => s.goals),\n            settings: privacySettings,\n            analytics: insights,\n          },\n          fileSize: 0, // Would be calculated\n          downloadUrl: \"\", // Would be generated\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n        logger.info(\"Personal data export created\", {\n          exportId: exportData.exportId,\n        });\n        return exportData;\n      } catch (error) {\n        logger.error(\"Failed to export personal data\", { error });\n        throw error;\n      }\n    }, [sessions, privacySettings, insights, userId]);\n\n  const deleteHistoricalData = useCallback(\n    async (before: Date): Promise<void> => {\n      try {\n        logger.debug(\"Deleting historical data\", { before, userId });\n\n        const sessionsToKeep = sessions.filter(\n          (session) => session.startTime >= before,\n        );\n        const deletedCount = sessions.length - sessionsToKeep.length;\n\n        setSessions(sessionsToKeep);\n\n        // Recalculate insights and trends\n        await Promise.all([calculateInsights(), calculateTrends()]);\n\n        logger.info(\"Historical data deleted\", { deletedCount });\n      } catch (error) {\n        logger.error(\"Failed to delete historical data\", { error });\n        throw error;\n      }\n    },\n    [sessions, calculateInsights, calculateTrends, userId],\n  );\n\n  // ==================== KEYHOLDER ACCESS ====================\n\n  const getKeyholderView = useCallback(\n    (): KeyholderHistoryView =>\n      getKeyholderViewUtil(\n        sessions,\n        keyholderAccess,\n        privacySettings,\n        averageSessionLength,\n        goalCompletionRate,\n      ),\n    [\n      keyholderAccess,\n      sessions,\n      privacySettings,\n      averageSessionLength,\n      goalCompletionRate,\n    ],\n  );\n\n  const shareHistoryWithKeyholder = useCallback(\n    async (sessionIds: string[]): Promise<void> => {\n      try {\n        logger.debug(\"Sharing specific sessions with keyholder\", {\n          sessionIds,\n        });\n\n        // This would create a special sharing link or send specific data\n        // For now, just log the action\n        logger.info(\"History shared with keyholder\", {\n          sessionCount: sessionIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to share history with keyholder\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getPerformanceTrends = useCallback(\n    (): PerformanceTrends =>\n      getPerformanceTrendsUtil(\n        averageSessionLength,\n        trends,\n        goalCompletionRate,\n        insights.consistencyScore,\n        longestStreak,\n      ),\n    [\n      averageSessionLength,\n      trends,\n      goalCompletionRate,\n      insights.consistencyScore,\n      longestStreak,\n    ],\n  );\n\n  const getGoalProgressHistory = useCallback(\n    (): GoalProgressHistory[] => getGoalProgressHistoryUtil(sessions),\n    [sessions],\n  );\n\n  const getComparisonMetrics = useCallback(\n    (): ComparisonMetrics => getComparisonMetricsUtil(sessions),\n    [sessions],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // History data\n    sessions,\n    insights,\n    trends,\n    privacySettings,\n\n    // Data retrieval\n    getSessionsByDateRange,\n    getSessionsByGoal,\n    searchSessions,\n\n    // Privacy management\n    updatePrivacySettings,\n    exportPersonalData,\n    deleteHistoricalData,\n\n    // Keyholder access\n    getKeyholderView,\n    shareHistoryWithKeyholder,\n\n    // Analytics\n    getPerformanceTrends,\n    getGoalProgressHistory,\n    getComparisonMetrics,\n\n    // Computed values\n    totalSessions,\n    averageSessionLength,\n    goalCompletionRate,\n    longestStreak,\n    hasPrivacyRestrictions,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistoryQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/stats/useLifetimeStats.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [910, 913], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [910, 913], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 17. Maximum allowed is 15.",
        "line": 106,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 164,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Lifetime Stats Hook\n * Calculates cumulative stats across all user sessions\n */\nimport { useState, useEffect, useMemo, useCallback } from \"react\";\nimport { sessionDBService } from \"../../services/database/SessionDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport { useSharedTimer } from \"../useSharedTimer\";\n\nconst logger = serviceLogger(\"useLifetimeStats\");\n\nexport interface LifetimeStats {\n  totalChastityTime: number; // Total effective locked time across all sessions\n  totalCageOffTime: number; // Total pause time + time between sessions\n  totalSessions: number;\n  isLoading: boolean;\n  refresh: () => Promise<void>; // Manual refresh function\n}\n\n/**\n * Hook to calculate lifetime stats across all sessions\n * Updates in real-time as sessions change\n */\nexport function useLifetimeStats(userId: string | undefined): LifetimeStats {\n  const [sessions, setSessions] = useState<any[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Use shared timer for perfect synchronization with other timer hooks\n  const currentTime = useSharedTimer();\n\n  // Manual refresh function\n  const refresh = useCallback(async () => {\n    if (!userId) return;\n\n    try {\n      const allSessions = await sessionDBService.getSessionHistory(\n        userId,\n        1000,\n      );\n      setSessions(allSessions);\n      logger.debug(\"Refreshed sessions for lifetime stats\", {\n        count: allSessions.length,\n      });\n    } catch (error) {\n      logger.error(\"Failed to refresh sessions for lifetime stats\", {\n        error: error as Error,\n      });\n    }\n  }, [userId]);\n\n  // Load all sessions for the user\n  useEffect(() => {\n    if (!userId) {\n      setSessions([]);\n      setIsLoading(false);\n      return;\n    }\n\n    let mounted = true;\n\n    const loadSessions = async () => {\n      try {\n        setIsLoading(true);\n        const allSessions = await sessionDBService.getSessionHistory(\n          userId,\n          1000,\n        ); // Get all sessions\n        if (mounted) {\n          setSessions(allSessions);\n          logger.debug(\"Loaded sessions for lifetime stats\", {\n            count: allSessions.length,\n          });\n        }\n      } catch (error) {\n        logger.error(\"Failed to load sessions for lifetime stats\", {\n          error: error as Error,\n        });\n      } finally {\n        if (mounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    loadSessions();\n\n    return () => {\n      mounted = false;\n    };\n  }, [userId]);\n\n  // Calculate lifetime stats\n  const stats = useMemo((): LifetimeStats => {\n    if (!userId || sessions.length === 0) {\n      return {\n        totalChastityTime: 0,\n        totalCageOffTime: 0,\n        totalSessions: 0,\n        isLoading,\n      };\n    }\n\n    let totalChastityTime = 0;\n    let totalCageOffTime = 0;\n\n    sessions.forEach((session, index) => {\n      // Calculate effective chastity time (total time - pauses)\n      const startTime = session.startTime;\n      const endTime = session.endTime || currentTime;\n\n      if (startTime) {\n        const sessionDuration = Math.floor(\n          (endTime.getTime() - startTime.getTime()) / 1000,\n        );\n        const effectiveTime = Math.max(\n          0,\n          sessionDuration - (session.accumulatedPauseTime || 0),\n        );\n\n        // If session is currently paused, subtract current pause duration\n        if (session.isPaused && session.pauseStartTime && !session.endTime) {\n          const currentPauseDuration = Math.floor(\n            (currentTime.getTime() - session.pauseStartTime.getTime()) / 1000,\n          );\n          totalChastityTime += Math.max(\n            0,\n            effectiveTime - currentPauseDuration,\n          );\n        } else {\n          totalChastityTime += effectiveTime;\n        }\n\n        // Add accumulated pause time to cage-off time\n        totalCageOffTime += session.accumulatedPauseTime || 0;\n\n        // If currently paused, add current pause duration\n        if (session.isPaused && session.pauseStartTime && !session.endTime) {\n          const currentPauseDuration = Math.floor(\n            (currentTime.getTime() - session.pauseStartTime.getTime()) / 1000,\n          );\n          totalCageOffTime += currentPauseDuration;\n        }\n      }\n\n      // Calculate time between this session and the next one (cage off time)\n      if (session.endTime && index > 0) {\n        const nextSession = sessions[index - 1]; // Sessions are sorted newest first\n        if (nextSession && nextSession.startTime) {\n          const timeBetween = Math.floor(\n            (nextSession.startTime.getTime() - session.endTime.getTime()) /\n              1000,\n          );\n          totalCageOffTime += Math.max(0, timeBetween);\n        }\n      }\n\n      // If this is the most recent session and it has ended, add time since end\n      if (index === 0 && session.endTime) {\n        const timeSinceEnd = Math.floor(\n          (currentTime.getTime() - session.endTime.getTime()) / 1000,\n        );\n        totalCageOffTime += Math.max(0, timeSinceEnd);\n      }\n    });\n\n    return {\n      totalChastityTime,\n      totalCageOffTime,\n      totalSessions: sessions.length,\n      isLoading,\n      refresh,\n    };\n  }, [sessions, currentTime, userId, isLoading, refresh]);\n\n  return stats;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useHealthCheck.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (271). Maximum allowed is 150.",
        "line": 79,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 425,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useHealthCheck Hook - System Health Monitoring\n *\n * Monitor overall system health, service availability, and provide early warning\n * for potential issues.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { HealthCheckStorageService } from \"../../services/healthCheckStorage\";\n\n// Health status enum\nexport enum HealthStatus {\n  HEALTHY = \"healthy\",\n  WARNING = \"warning\",\n  CRITICAL = \"critical\",\n  UNKNOWN = \"unknown\",\n}\n\n// Service status\nexport interface ServiceStatus {\n  name: string;\n  status: HealthStatus;\n  responseTime: number;\n  lastChecked: Date;\n  error?: string;\n  uptime: number;\n}\n\n// System metrics\nexport interface SystemMetrics {\n  memoryUsage: number;\n  cpuUsage: number;\n  storageUsage: number;\n  networkLatency: number;\n  errorRate: number;\n  activeConnections: number;\n}\n\n// Health check result\nexport interface HealthCheckResult {\n  overall: HealthStatus;\n  services: ServiceStatus[];\n  metrics: SystemMetrics;\n  alerts: HealthAlert[];\n  lastUpdated: Date;\n  checkDuration: number;\n}\n\n// Health alert\nexport interface HealthAlert {\n  id: string;\n  type: \"warning\" | \"error\" | \"info\";\n  message: string;\n  service?: string;\n  timestamp: Date;\n  acknowledged: boolean;\n}\n\n// Health check configuration\ninterface HealthCheckConfig {\n  checkInterval: number;\n  timeout: number;\n  retryAttempts: number;\n  services: string[];\n}\n\nconst DEFAULT_CONFIG: HealthCheckConfig = {\n  checkInterval: 30000, // 30 seconds\n  timeout: 5000, // 5 seconds\n  retryAttempts: 3,\n  services: [\"firebase\", \"storage\", \"network\"],\n};\n\n/**\n * System Health Check Hook\n */\nexport const useHealthCheck = (config: Partial<HealthCheckConfig> = {}) => {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const [alerts, setAlerts] = useState<HealthAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Check service health\n  const checkServiceHealth = useCallback(\n    async (serviceName: string): Promise<ServiceStatus> => {\n      const startTime = Date.now();\n      let status: HealthStatus = HealthStatus.UNKNOWN;\n      let error: string | undefined;\n      let responseTime = 0;\n\n      try {\n        switch (serviceName) {\n          case \"firebase\":\n            // Check Firebase connectivity\n            status = await checkFirebaseHealth();\n            break;\n          case \"storage\":\n            status = await checkStorageHealth();\n            break;\n          case \"network\":\n            status = await checkNetworkHealth();\n            break;\n          default:\n            status = HealthStatus.UNKNOWN;\n        }\n\n        responseTime = Date.now() - startTime;\n      } catch (err) {\n        status = HealthStatus.CRITICAL;\n        error = err instanceof Error ? err.message : \"Unknown error\";\n        responseTime = Date.now() - startTime;\n        logger.error(`Health check failed for ${serviceName}`, { error: err });\n      }\n\n      return {\n        name: serviceName,\n        status,\n        responseTime,\n        lastChecked: new Date(),\n        error,\n        uptime: calculateUptime(serviceName),\n      };\n    },\n    [],\n  );\n\n  // Check Firebase health\n  const checkFirebaseHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Simple connectivity test - try to access Firebase\n      if (\n        typeof window !== \"undefined\" &&\n        (window as Window & { firebase?: unknown }).firebase\n      ) {\n        return HealthStatus.HEALTHY;\n      }\n      return HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check storage health\n  const checkStorageHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Test localStorage availability using the service\n      const isHealthy = HealthCheckStorageService.testLocalStorage();\n      return isHealthy ? HealthStatus.HEALTHY : HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check network health\n  const checkNetworkHealth = async (): Promise<HealthStatus> => {\n    if (!navigator.onLine) {\n      return HealthStatus.CRITICAL;\n    }\n\n    try {\n      const startTime = Date.now();\n      const response = await fetch(\"/favicon.ico\", {\n        method: \"HEAD\",\n        cache: \"no-cache\",\n      });\n      const responseTime = Date.now() - startTime;\n\n      if (response.ok && responseTime < 2000) {\n        return HealthStatus.HEALTHY;\n      } else if (response.ok && responseTime < 5000) {\n        return HealthStatus.WARNING;\n      }\n      return HealthStatus.CRITICAL;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Calculate service uptime (simplified)\n  const calculateUptime = (_serviceName: string): number => {\n    // In a real implementation, this would track actual uptime\n    // For now, return a mock value\n    return Math.random() * 100;\n  };\n\n  // Get system metrics\n  const getSystemMetrics = useCallback(async (): Promise<SystemMetrics> => {\n    const metrics: SystemMetrics = {\n      memoryUsage: 0,\n      cpuUsage: 0,\n      storageUsage: 0,\n      networkLatency: 0,\n      errorRate: 0,\n      activeConnections: 1,\n    };\n\n    try {\n      // Memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: { usedJSHeapSize: number; totalJSHeapSize: number };\n          }\n        ).memory;\n        if (memory) {\n          metrics.memoryUsage =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Storage usage\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        if (estimate.usage && estimate.quota) {\n          metrics.storageUsage = (estimate.usage / estimate.quota) * 100;\n        }\n      }\n\n      // Network latency (simplified)\n      const startTime = Date.now();\n      await fetch(\"/favicon.ico\", { method: \"HEAD\", cache: \"no-cache\" });\n      metrics.networkLatency = Date.now() - startTime;\n    } catch (error) {\n      logger.warn(\"Failed to get some system metrics\", error);\n    }\n\n    return metrics;\n  }, []);\n\n  // Determine overall health status\n  const calculateOverallHealth = useCallback(\n    (services: ServiceStatus[]): HealthStatus => {\n      const statuses = services.map((s) => s.status);\n\n      if (statuses.includes(HealthStatus.CRITICAL)) {\n        return HealthStatus.CRITICAL;\n      }\n\n      if (statuses.includes(HealthStatus.WARNING)) {\n        return HealthStatus.WARNING;\n      }\n\n      if (statuses.every((s) => s === HealthStatus.HEALTHY)) {\n        return HealthStatus.HEALTHY;\n      }\n\n      return HealthStatus.UNKNOWN;\n    },\n    [],\n  );\n\n  // Generate alerts based on health status\n  const generateAlerts = useCallback(\n    (services: ServiceStatus[], metrics: SystemMetrics): HealthAlert[] => {\n      const newAlerts: HealthAlert[] = [];\n\n      // Service alerts\n      services.forEach((service) => {\n        if (service.status === HealthStatus.CRITICAL) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"error\",\n            message: `Service ${service.name} is critical: ${service.error || \"Unknown error\"}`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        } else if (service.status === HealthStatus.WARNING) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"warning\",\n            message: `Service ${service.name} is experiencing issues`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        }\n      });\n\n      // Metrics alerts\n      if (metrics.memoryUsage > 90) {\n        newAlerts.push({\n          id: `memory-${Date.now()}`,\n          type: \"warning\",\n          message: `High memory usage: ${metrics.memoryUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.storageUsage > 90) {\n        newAlerts.push({\n          id: `storage-${Date.now()}`,\n          type: \"warning\",\n          message: `High storage usage: ${metrics.storageUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.networkLatency > 5000) {\n        newAlerts.push({\n          id: `network-${Date.now()}`,\n          type: \"warning\",\n          message: `High network latency: ${metrics.networkLatency}ms`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      return newAlerts;\n    },\n    [],\n  );\n\n  // Main health check query\n  const {\n    data: healthStatus,\n    isLoading,\n    error,\n    refetch,\n  } = useQuery<HealthCheckResult>({\n    queryKey: [\"system\", \"health\"],\n    queryFn: async () => {\n      const startTime = Date.now();\n\n      // Check all services\n      const serviceChecks = await Promise.all(\n        fullConfig.services.map((service) => checkServiceHealth(service)),\n      );\n\n      // Get system metrics\n      const metrics = await getSystemMetrics();\n\n      // Calculate overall health\n      const overall = calculateOverallHealth(serviceChecks);\n\n      // Generate alerts\n      const newAlerts = generateAlerts(serviceChecks, metrics);\n\n      const result: HealthCheckResult = {\n        overall,\n        services: serviceChecks,\n        metrics,\n        alerts: newAlerts,\n        lastUpdated: new Date(),\n        checkDuration: Date.now() - startTime,\n      };\n\n      // Update alerts state\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n\n      return result;\n    },\n    refetchInterval: isMonitoring ? fullConfig.checkInterval : false,\n    retry: fullConfig.retryAttempts,\n    staleTime: fullConfig.checkInterval / 2,\n  });\n\n  // Acknowledge alert\n  const acknowledgeAlert = useCallback((alertId: string) => {\n    setAlerts((prev) =>\n      prev.map((alert) =>\n        alert.id === alertId ? { ...alert, acknowledged: true } : alert,\n      ),\n    );\n    logger.info(\"Health alert acknowledged\", { alertId });\n  }, []);\n\n  // Clear acknowledged alerts\n  const clearAcknowledgedAlerts = useCallback(() => {\n    setAlerts((prev) => prev.filter((alert) => !alert.acknowledged));\n    logger.info(\"Acknowledged alerts cleared\");\n  }, []);\n\n  // Start/stop monitoring\n  const toggleMonitoring = useCallback((enabled: boolean) => {\n    setIsMonitoring(enabled);\n    logger.info(`Health monitoring ${enabled ? \"started\" : \"stopped\"}`);\n  }, []);\n\n  // Force health check\n  const forceCheck = useCallback(() => {\n    refetch();\n    logger.info(\"Manual health check triggered\");\n  }, [refetch]);\n\n  return {\n    // Health status\n    healthStatus,\n    isLoading,\n    error,\n\n    // Alerts\n    alerts: alerts.filter((alert) => !alert.acknowledged),\n    acknowledgedAlerts: alerts.filter((alert) => alert.acknowledged),\n    allAlerts: alerts,\n\n    // Controls\n    acknowledgeAlert,\n    clearAcknowledgedAlerts,\n    toggleMonitoring,\n    forceCheck,\n\n    // State\n    isMonitoring,\n\n    // Computed properties\n    isHealthy: healthStatus?.overall === HealthStatus.HEALTHY,\n    hasWarnings: healthStatus?.overall === HealthStatus.WARNING,\n    isCritical: healthStatus?.overall === HealthStatus.CRITICAL,\n    hasUnacknowledgedAlerts: alerts.some((alert) => !alert.acknowledged),\n    uptime:\n      healthStatus?.services.reduce((acc, service) => acc + service.uptime, 0) /\n      (healthStatus?.services.length || 1),\n    averageResponseTime:\n      healthStatus?.services.reduce(\n        (acc, service) => acc + service.responseTime,\n        0,\n      ) / (healthStatus?.services.length || 1),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useMigration.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (282). Maximum allowed is 150.",
        "line": 94,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 450,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useMigration Hook - Data Migration Management\n *\n * Handle data migrations, schema updates, and legacy data conversion with\n * progress tracking and rollback capabilities.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { MigrationStorageService } from \"../../services/migrationStorage\";\n\n// Migration status\nexport enum MigrationStatus {\n  PENDING = \"pending\",\n  RUNNING = \"running\",\n  COMPLETED = \"completed\",\n  FAILED = \"failed\",\n  ROLLED_BACK = \"rolled_back\",\n}\n\n// Migration definition\nexport interface Migration {\n  id: string;\n  version: string;\n  name: string;\n  description: string;\n  status: MigrationStatus;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  progress: number;\n  error?: string;\n  rollbackAvailable: boolean;\n}\n\n// Migration batch\nexport interface MigrationBatch {\n  id: string;\n  migrations: Migration[];\n  status: MigrationStatus;\n  totalProgress: number;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\n// Migration result\nexport interface MigrationResult {\n  success: boolean;\n  migrationsRun: number;\n  errors: string[];\n  warnings: string[];\n  duration: number;\n}\n\n// Migration state\nexport interface MigrationState {\n  migrations: Migration[];\n  lastRun: Date | null;\n  currentVersion: string;\n}\n\n// Sample migrations (in a real app, these would be defined elsewhere)\nconst AVAILABLE_MIGRATIONS: Omit<\n  Migration,\n  \"status\" | \"progress\" | \"createdAt\"\n>[] = [\n  {\n    id: \"v4.0.0-theme-system\",\n    version: \"4.0.0\",\n    name: \"Theme System Migration\",\n    description: \"Migrate existing theme preferences to new theme system\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-enhanced-goals\",\n    version: \"4.0.0\",\n    name: \"Enhanced Goals Migration\",\n    description: \"Convert legacy goals to enhanced goal format\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-gamification\",\n    version: \"4.0.0\",\n    name: \"Gamification System Migration\",\n    description: \"Initialize gamification data from existing achievements\",\n    rollbackAvailable: false,\n  },\n];\n\n/**\n * Data Migration Hook\n */\nexport const useMigration = () => {\n  const queryClient = useQueryClient();\n  const [isRunning, setIsRunning] = useState(false);\n\n  // Get migration state\n  const { data: migrationState } = useQuery<MigrationState>({\n    queryKey: [\"migration\", \"state\"],\n    queryFn: (): MigrationState => {\n      const stored = MigrationStorageService.getMigrationState();\n      if (stored) {\n        return stored;\n      }\n\n      // Initialize migration state\n      const initialMigrations: Migration[] = AVAILABLE_MIGRATIONS.map(\n        (migration) => ({\n          ...migration,\n          status: MigrationStatus.PENDING,\n          progress: 0,\n          createdAt: new Date(),\n        }),\n      );\n\n      return {\n        migrations: initialMigrations,\n        lastRun: null,\n        currentVersion: \"3.0.0\",\n      };\n    },\n    staleTime: Infinity,\n  });\n\n  // Get pending migrations\n  const pendingMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.PENDING,\n    ) || [];\n\n  // Get completed migrations\n  const completedMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.COMPLETED,\n    ) || [];\n\n  // Create backup before migration\n  const createBackup = useCallback(\n    async (migrationId: string) => {\n      try {\n        const backup = {\n          id: `backup-${migrationId}-${Date.now()}`,\n          migrationId,\n          timestamp: new Date(),\n          data: {\n            // Backup all localStorage via service\n            localStorage: MigrationStorageService.getAllLocalStorage(),\n            version: migrationState?.currentVersion,\n          },\n        };\n\n        const existingBackups =\n          MigrationStorageService.getMigrationBackups<typeof backup>();\n\n        const updatedBackups = [...existingBackups, backup];\n        MigrationStorageService.setMigrationBackups(updatedBackups);\n\n        logger.info(\"Migration backup created\", {\n          migrationId,\n          backupId: backup.id,\n        });\n        return backup.id;\n      } catch (error) {\n        logger.error(\"Failed to create migration backup\", {\n          migrationId,\n          error,\n        });\n        throw error;\n      }\n    },\n    [migrationState],\n  );\n\n  // Migration implementations\n  const migrateThemeSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(25);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      // Convert old theme settings\n      const oldTheme = MigrationStorageService.getLegacyItem(\"theme\");\n      if (oldTheme) {\n        MigrationStorageService.setLegacyItem(\n          \"chastity-theme-current\",\n          JSON.stringify(\n            oldTheme === \"dark\" ? \"default-dark\" : \"default-light\",\n          ),\n        );\n      }\n\n      onProgress(75);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateEnhancedGoals = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(30);\n      await new Promise((resolve) => setTimeout(resolve, 300));\n\n      // Convert legacy goals (simplified)\n      const legacyGoals =\n        MigrationStorageService.getLegacyItem(\"personal-goals\");\n      if (legacyGoals) {\n        // Transform format here\n        onProgress(70);\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      }\n\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateGamificationSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(20);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n\n      // Initialize gamification data\n      onProgress(60);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n      onProgress(100);\n    },\n    [],\n  );\n\n  // Execute migration logic\n  const executeMigrationLogic = useCallback(\n    async (migrationId: string, onProgress: (progress: number) => void) => {\n      switch (migrationId) {\n        case \"v4.0.0-theme-system\":\n          await migrateThemeSystem(onProgress);\n          break;\n        case \"v4.0.0-enhanced-goals\":\n          await migrateEnhancedGoals(onProgress);\n          break;\n        case \"v4.0.0-gamification\":\n          await migrateGamificationSystem(onProgress);\n          break;\n        default:\n          throw new Error(`Unknown migration: ${migrationId}`);\n      }\n    },\n    [migrateThemeSystem, migrateEnhancedGoals, migrateGamificationSystem],\n  );\n\n  // Execute single migration\n  const executeMigration = useCallback(\n    async (migration: Migration): Promise<void> => {\n      logger.info(\"Starting migration\", { migrationId: migration.id });\n\n      // Update migration status\n      const updatedMigrations = migrationState.migrations.map((m: Migration) =>\n        m.id === migration.id\n          ? {\n              ...m,\n              status: MigrationStatus.RUNNING,\n              startedAt: new Date(),\n              progress: 0,\n            }\n          : m,\n      );\n\n      const newState = { ...migrationState, migrations: updatedMigrations };\n      MigrationStorageService.setMigrationState(newState);\n      queryClient.setQueryData([\"migration\", \"state\"], newState);\n\n      try {\n        // Create backup if rollback is available\n        if (migration.rollbackAvailable) {\n          await createBackup(migration.id);\n        }\n\n        // Execute migration logic based on ID\n        await executeMigrationLogic(migration.id, (progress: number) => {\n          // Update progress\n          const progressUpdatedMigrations = migrationState.migrations.map(\n            (m: Migration) => (m.id === migration.id ? { ...m, progress } : m),\n          );\n\n          const progressState = {\n            ...migrationState,\n            migrations: progressUpdatedMigrations,\n          };\n          MigrationStorageService.setMigrationState(progressState);\n          queryClient.setQueryData([\"migration\", \"state\"], progressState);\n        });\n\n        // Mark as completed\n        const completedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.COMPLETED,\n                  completedAt: new Date(),\n                  progress: 100,\n                }\n              : m,\n        );\n\n        const completedState = {\n          ...migrationState,\n          migrations: completedMigrations,\n        };\n        MigrationStorageService.setMigrationState(completedState);\n        queryClient.setQueryData([\"migration\", \"state\"], completedState);\n\n        logger.info(\"Migration completed\", { migrationId: migration.id });\n      } catch (error) {\n        // Mark as failed\n        const failedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.FAILED,\n                  error:\n                    error instanceof Error ? error.message : \"Unknown error\",\n                }\n              : m,\n        );\n\n        const failedState = { ...migrationState, migrations: failedMigrations };\n        MigrationStorageService.setMigrationState(failedState);\n        queryClient.setQueryData([\"migration\", \"state\"], failedState);\n\n        logger.error(\"Migration failed\", { migrationId: migration.id, error });\n        throw error;\n      }\n    },\n    [migrationState, queryClient, createBackup, executeMigrationLogic],\n  );\n\n  // Run migrations mutation\n  const runMigrationsMutation = useMutation({\n    mutationFn: async (migrationIds?: string[]) => {\n      setIsRunning(true);\n      const startTime = Date.now();\n      const result: MigrationResult = {\n        success: true,\n        migrationsRun: 0,\n        errors: [],\n        warnings: [],\n        duration: 0,\n      };\n\n      try {\n        const migrationsToRun = migrationIds\n          ? migrationState.migrations.filter((m: Migration) =>\n              migrationIds.includes(m.id),\n            )\n          : pendingMigrations;\n\n        for (const migration of migrationsToRun) {\n          try {\n            await executeMigration(migration);\n            result.migrationsRun++;\n          } catch (error) {\n            result.success = false;\n            result.errors.push(\n              `${migration.name}: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n            );\n          }\n        }\n\n        result.duration = Date.now() - startTime;\n        return result;\n      } finally {\n        setIsRunning(false);\n      }\n    },\n  });\n\n  // Rollback migration mutation\n  const rollbackMigrationMutation = useMutation({\n    mutationFn: async (migrationId: string) => {\n      const migration = migrationState.migrations.find(\n        (m: Migration) => m.id === migrationId,\n      );\n      if (!migration) throw new Error(\"Migration not found\");\n      if (!migration.rollbackAvailable)\n        throw new Error(\"Rollback not available for this migration\");\n\n      logger.info(\"Rolling back migration\", { migrationId });\n\n      // Find and restore backup\n      const backups = MigrationStorageService.getMigrationBackups<{\n        migrationId: string;\n        data: { localStorage: Record<string, string> };\n      }>();\n      const backup = backups.find((b) => b.migrationId === migrationId);\n\n      if (!backup) throw new Error(\"Backup not found\");\n\n      // Restore data from backup\n      Object.entries(backup.data.localStorage).forEach(([key, value]) => {\n        MigrationStorageService.setLegacyItem(key, value);\n      });\n\n      // Update migration status\n      const rolledBackMigrations = migrationState.migrations.map(\n        (m: Migration) =>\n          m.id === migrationId\n            ? { ...m, status: MigrationStatus.ROLLED_BACK }\n            : m,\n      );\n\n      const rolledBackState = {\n        ...migrationState,\n        migrations: rolledBackMigrations,\n      };\n      MigrationStorageService.setMigrationState(rolledBackState);\n      queryClient.setQueryData([\"migration\", \"state\"], rolledBackState);\n\n      logger.info(\"Migration rolled back\", { migrationId });\n    },\n  });\n\n  return {\n    // Migration state\n    migrations: migrationState?.migrations || [],\n    pendingMigrations,\n    completedMigrations,\n    isRunning,\n\n    // Actions\n    runMigrations: runMigrationsMutation.mutate,\n    rollbackMigration: rollbackMigrationMutation.mutate,\n\n    // Status\n    hasPendingMigrations: pendingMigrations.length > 0,\n    hasFailedMigrations:\n      migrationState?.migrations?.some(\n        (m: Migration) => m.status === MigrationStatus.FAILED,\n      ) || false,\n\n    // Loading states\n    isRunningMigrations: runMigrationsMutation.isPending,\n    isRollingBack: rollbackMigrationMutation.isPending,\n\n    // Results\n    lastResult: runMigrationsMutation.data,\n    error: runMigrationsMutation.error || rollbackMigrationMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useOfflineStatus.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (280). Maximum allowed is 150.",
        "line": 64,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 407,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'addNetworkEvent', 'getNetworkInfo', and 'getNetworkQuality'. Either include them or remove the dependency array.",
        "line": 377,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 377,
        "endColumn": 75,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]",
            "fix": {
              "range": [10924, 10993],
              "text": "[handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useOfflineStatus Hook - Network Status Monitoring\n *\n * Monitor network connectivity and provide offline capabilities with intelligent\n * sync when connection is restored.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Network quality enum\nexport enum NetworkQuality {\n  EXCELLENT = \"excellent\",\n  GOOD = \"good\",\n  FAIR = \"fair\",\n  POOR = \"poor\",\n  OFFLINE = \"offline\",\n}\n\n// Connection type\nexport enum ConnectionType {\n  WIFI = \"wifi\",\n  CELLULAR = \"cellular\",\n  ETHERNET = \"ethernet\",\n  BLUETOOTH = \"bluetooth\",\n  UNKNOWN = \"unknown\",\n}\n\n// Offline status interface\nexport interface OfflineStatus {\n  isOnline: boolean;\n  isOffline: boolean;\n  networkQuality: NetworkQuality;\n  connectionType: ConnectionType;\n  downlink: number;\n  rtt: number;\n  effectiveType: string;\n  lastOnline: Date | null;\n  offlineDuration: number;\n  hasPendingSync: boolean;\n  syncQueueSize: number;\n}\n\n// Offline capabilities\nexport interface OfflineCapabilities {\n  canReadCache: boolean;\n  canWriteCache: boolean;\n  canQueueOperations: boolean;\n  estimatedStorageUsage: number;\n  maxStorageLimit: number;\n}\n\n// Network event\nexport interface NetworkEvent {\n  type: \"online\" | \"offline\" | \"quality-change\";\n  timestamp: Date;\n  details?: Record<string, string | number | boolean>;\n}\n\n/**\n * Network Status Hook\n */\nexport const useOfflineStatus = () => {\n  const queryClient = useQueryClient();\n  const [networkEvents, setNetworkEvents] = useState<NetworkEvent[]>([]);\n  const [syncQueue, setSyncQueue] = useState<Record<string, unknown>[]>([]);\n  const [lastOnline, setLastOnline] = useState<Date | null>(null);\n\n  // Get network information if available\n  const getNetworkInfo = useCallback(() => {\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n\n    return {\n      downlink: connection?.downlink || 0,\n      rtt: connection?.rtt || 0,\n      effectiveType: connection?.effectiveType || \"unknown\",\n      type: connection?.type || ConnectionType.UNKNOWN,\n    };\n  }, []);\n\n  // Determine network quality\n  const getNetworkQuality = useCallback(\n    (downlink: number, rtt: number): NetworkQuality => {\n      if (!navigator.onLine) return NetworkQuality.OFFLINE;\n\n      if (downlink >= 10 && rtt < 100) return NetworkQuality.EXCELLENT;\n      if (downlink >= 5 && rtt < 200) return NetworkQuality.GOOD;\n      if (downlink >= 1.5 && rtt < 500) return NetworkQuality.FAIR;\n      return NetworkQuality.POOR;\n    },\n    [],\n  );\n\n  // Current offline status query\n  const { data: offlineStatus } = useQuery<OfflineStatus>({\n    queryKey: [\"network\", \"status\"],\n    queryFn: (): OfflineStatus => {\n      const networkInfo = getNetworkInfo();\n      const quality = getNetworkQuality(networkInfo.downlink, networkInfo.rtt);\n      const now = new Date();\n\n      const offlineDuration =\n        lastOnline && !navigator.onLine\n          ? now.getTime() - lastOnline.getTime()\n          : 0;\n\n      return {\n        isOnline: navigator.onLine,\n        isOffline: !navigator.onLine,\n        networkQuality: quality,\n        connectionType: networkInfo.type,\n        downlink: networkInfo.downlink,\n        rtt: networkInfo.rtt,\n        effectiveType: networkInfo.effectiveType,\n        lastOnline,\n        offlineDuration,\n        hasPendingSync: syncQueue.length > 0,\n        syncQueueSize: syncQueue.length,\n      };\n    },\n    refetchInterval: 5000, // Check every 5 seconds\n    staleTime: 1000,\n  });\n\n  // Offline capabilities query\n  const { data: capabilities } = useQuery<OfflineCapabilities>({\n    queryKey: [\"network\", \"capabilities\"],\n    queryFn: async () => {\n      let storageUsage = 0;\n      let storageLimit = 0;\n\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        try {\n          const estimate = await navigator.storage.estimate();\n          storageUsage = estimate.usage || 0;\n          storageLimit = estimate.quota || 0;\n        } catch (error) {\n          logger.warn(\"Could not estimate storage\", error);\n        }\n      }\n\n      return {\n        canReadCache: \"caches\" in window,\n        canWriteCache: \"caches\" in window && navigator.onLine,\n        canQueueOperations: true,\n        estimatedStorageUsage: storageUsage,\n        maxStorageLimit: storageLimit,\n      };\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Add network event\n  const addNetworkEvent = useCallback(\n    (\n      type: NetworkEvent[\"type\"],\n      details?: Record<string, string | number | boolean>,\n    ) => {\n      const event: NetworkEvent = {\n        type,\n        timestamp: new Date(),\n        details,\n      };\n\n      setNetworkEvents((prev) => [...prev.slice(-49), event]); // Keep last 50 events\n      logger.info(`Network event: ${type}`, details);\n    },\n    [],\n  );\n\n  // Handle online event\n  const handleOnline = useCallback(() => {\n    setLastOnline(new Date());\n    addNetworkEvent(\"online\", {\n      wasOffline: !navigator.onLine,\n      syncQueueSize: syncQueue.length,\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n\n    // Process sync queue when back online\n    if (syncQueue.length > 0) {\n      processSyncQueue();\n    }\n  }, [syncQueue, addNetworkEvent, queryClient, processSyncQueue]);\n\n  // Handle offline event\n  const handleOffline = useCallback(() => {\n    addNetworkEvent(\"offline\", {\n      lastOnline: lastOnline?.toISOString(),\n      networkInfo: getNetworkInfo(),\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n  }, [lastOnline, addNetworkEvent, getNetworkInfo, queryClient]);\n\n  // Process sync queue\n  const processSyncQueue = useCallback(async () => {\n    if (!navigator.onLine || syncQueue.length === 0) return;\n\n    logger.info(\"Processing sync queue\", { queueSize: syncQueue.length });\n\n    const processedItems: Record<string, unknown>[] = [];\n\n    for (const item of syncQueue) {\n      try {\n        // Here you would implement actual sync logic\n        // For now, we'll just simulate processing\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        processedItems.push(item);\n        logger.debug(\"Sync item processed\", { item });\n      } catch (error) {\n        logger.error(\"Failed to sync item\", { item, error });\n        break; // Stop processing on error\n      }\n    }\n\n    // Remove processed items from queue\n    setSyncQueue((prev) =>\n      prev.filter((item) => !processedItems.includes(item)),\n    );\n\n    if (processedItems.length > 0) {\n      queryClient.invalidateQueries({ queryKey: [\"network\"] });\n      logger.info(\"Sync queue processed\", {\n        processedCount: processedItems.length,\n        remainingCount: syncQueue.length - processedItems.length,\n      });\n    }\n  }, [syncQueue, queryClient]);\n\n  // Add item to sync queue\n  const queueForSync = useCallback((item: Record<string, unknown>) => {\n    setSyncQueue((prev) => [...prev, { ...item, queuedAt: new Date() }]);\n    logger.debug(\"Item queued for sync\", { item });\n  }, []);\n\n  // Clear sync queue\n  const clearSyncQueue = useCallback(() => {\n    setSyncQueue([]);\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n    logger.info(\"Sync queue cleared\");\n  }, [queryClient]);\n\n  // Retry sync\n  const retrySync = useCallback(() => {\n    if (navigator.onLine) {\n      processSyncQueue();\n    } else {\n      logger.warn(\"Cannot retry sync while offline\");\n    }\n  }, [processSyncQueue]);\n\n  // Monitor connection changes\n  useEffect(() => {\n    const handleConnectionChange = () => {\n      const networkInfo = getNetworkInfo();\n      const newQuality = getNetworkQuality(\n        networkInfo.downlink,\n        networkInfo.rtt,\n      );\n\n      if (offlineStatus && newQuality !== offlineStatus?.networkQuality) {\n        addNetworkEvent(\"quality-change\", {\n          oldQuality: offlineStatus?.networkQuality,\n          newQuality,\n          networkInfo,\n        });\n      }\n\n      queryClient.invalidateQueries({ queryKey: [\"network\", \"status\"] });\n    };\n\n    // Listen for online/offline events\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes if supported\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n    if (connection) {\n      connection.addEventListener(\"change\", handleConnectionChange);\n    }\n\n    // Set initial online status\n    if (navigator.onLine && !lastOnline) {\n      setLastOnline(new Date());\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      if (connection) {\n        connection.removeEventListener(\"change\", handleConnectionChange);\n      }\n    };\n    // addNetworkEvent, getNetworkInfo, getNetworkQuality are stable (no/stable deps)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline]);\n\n  return {\n    // Status\n    ...offlineStatus,\n    capabilities,\n\n    // Events\n    networkEvents,\n\n    // Sync management\n    queueForSync,\n    clearSyncQueue,\n    retrySync,\n    processSyncQueue,\n\n    // Computed properties\n    connectionStrength: offlineStatus?.networkQuality ?? NetworkQuality.OFFLINE,\n    canPerformOperations: offlineStatus?.isOnline ?? false,\n    needsSync: (offlineStatus?.syncQueueSize ?? 0) > 0,\n\n    // Helper methods\n    isGoodConnection:\n      offlineStatus?.networkQuality === NetworkQuality.EXCELLENT ||\n      offlineStatus?.networkQuality === NetworkQuality.GOOD,\n    isPoorConnection: offlineStatus?.networkQuality === NetworkQuality.POOR,\n    hasRecentEvents:\n      networkEvents.filter((e) => Date.now() - e.timestamp.getTime() < 60000)\n        .length > 0,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/usePerformance.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (248). Maximum allowed is 150.",
        "line": 78,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 382,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * usePerformance Hook - Performance Monitoring\n *\n * Monitor application performance metrics, identify bottlenecks, and provide\n * optimization recommendations.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Performance metric types\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  lcp: number; // Largest Contentful Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout Shift\n\n  // Loading performance\n  domContentLoaded: number;\n  loadComplete: number;\n  firstPaint: number;\n  firstContentfulPaint: number;\n\n  // Memory usage\n  memoryUsed: number;\n  memoryTotal: number;\n  memoryUsagePercent: number;\n\n  // Network\n  networkType: string;\n  effectiveType: string;\n  downlink: number;\n  rtt: number;\n\n  // Custom metrics\n  componentRenderTime: number;\n  apiResponseTime: number;\n\n  timestamp: Date;\n}\n\n// Performance alert\nexport interface PerformanceAlert {\n  id: string;\n  type: \"warning\" | \"critical\";\n  metric: keyof PerformanceMetrics;\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: Date;\n}\n\n// Performance recommendation\nexport interface PerformanceRecommendation {\n  id: string;\n  category: \"loading\" | \"runtime\" | \"memory\" | \"network\";\n  priority: \"low\" | \"medium\" | \"high\";\n  title: string;\n  description: string;\n  impact: string;\n  effort: string;\n}\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  lcp: { good: 2500, poor: 4000 },\n  fid: { good: 100, poor: 300 },\n  cls: { good: 0.1, poor: 0.25 },\n  memoryUsagePercent: { good: 70, poor: 90 },\n  loadComplete: { good: 3000, poor: 6000 },\n  apiResponseTime: { good: 500, poor: 2000 },\n};\n\n/**\n * Performance Monitoring Hook\n */\nexport const usePerformance = () => {\n  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Get current performance metrics\n  const { data: metrics, isLoading } = useQuery<PerformanceMetrics>({\n    queryKey: [\"performance\", \"metrics\"],\n    queryFn: async () => {\n      const perfMetrics: PerformanceMetrics = {\n        lcp: 0,\n        fid: 0,\n        cls: 0,\n        domContentLoaded: 0,\n        loadComplete: 0,\n        firstPaint: 0,\n        firstContentfulPaint: 0,\n        memoryUsed: 0,\n        memoryTotal: 0,\n        memoryUsagePercent: 0,\n        networkType: \"unknown\",\n        effectiveType: \"unknown\",\n        downlink: 0,\n        rtt: 0,\n        componentRenderTime: 0,\n        apiResponseTime: 0,\n        timestamp: new Date(),\n      };\n\n      // Get performance timing\n      if (performance.timing) {\n        const timing = performance.timing;\n        perfMetrics.domContentLoaded =\n          timing.domContentLoadedEventEnd - timing.navigationStart;\n        perfMetrics.loadComplete = timing.loadEventEnd - timing.navigationStart;\n      }\n\n      // Get paint timing\n      const paintEntries = performance.getEntriesByType(\"paint\");\n      paintEntries.forEach((entry) => {\n        if (entry.name === \"first-paint\") {\n          perfMetrics.firstPaint = entry.startTime;\n        } else if (entry.name === \"first-contentful-paint\") {\n          perfMetrics.firstContentfulPaint = entry.startTime;\n        }\n      });\n\n      // Get memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: {\n              usedJSHeapSize: number;\n              totalJSHeapSize: number;\n            };\n          }\n        ).memory;\n        if (memory) {\n          perfMetrics.memoryUsed = memory.usedJSHeapSize;\n          perfMetrics.memoryTotal = memory.totalJSHeapSize;\n          perfMetrics.memoryUsagePercent =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Get network information\n      const nav = navigator as Navigator & {\n        connection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        mozConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        webkitConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n      };\n      const connection =\n        nav.connection || nav.mozConnection || nav.webkitConnection;\n      if (connection) {\n        perfMetrics.networkType = connection.type || \"unknown\";\n        perfMetrics.effectiveType = connection.effectiveType || \"unknown\";\n        perfMetrics.downlink = connection.downlink || 0;\n        perfMetrics.rtt = connection.rtt || 0;\n      }\n\n      return perfMetrics;\n    },\n    refetchInterval: isMonitoring ? 10000 : false, // Every 10 seconds\n    staleTime: 5000,\n  });\n\n  // Generate performance recommendations\n  const { data: recommendations = [] } = useQuery<PerformanceRecommendation[]>({\n    queryKey: [\"performance\", \"recommendations\", metrics],\n    queryFn: () => {\n      if (!metrics) return [];\n\n      const recs: PerformanceRecommendation[] = [];\n\n      // Loading performance recommendations\n      if (metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.poor) {\n        recs.push({\n          id: \"slow-loading\",\n          category: \"loading\",\n          priority: \"high\",\n          title: \"Slow Page Loading\",\n          description: \"Page load time exceeds recommended thresholds\",\n          impact: \"High - affects user experience and engagement\",\n          effort: \"Medium - requires code splitting and optimization\",\n        });\n      }\n\n      // Memory usage recommendations\n      if (\n        metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.poor\n      ) {\n        recs.push({\n          id: \"high-memory\",\n          category: \"memory\",\n          priority: \"high\",\n          title: \"High Memory Usage\",\n          description: \"Application is using excessive memory\",\n          impact: \"High - can cause crashes and slowdowns\",\n          effort: \"High - requires memory leak investigation\",\n        });\n      }\n\n      // Network recommendations\n      if (metrics.rtt > 500) {\n        recs.push({\n          id: \"high-latency\",\n          category: \"network\",\n          priority: \"medium\",\n          title: \"High Network Latency\",\n          description: \"Network requests are slow\",\n          impact: \"Medium - affects data loading\",\n          effort: \"Low - implement caching strategies\",\n        });\n      }\n\n      return recs;\n    },\n    enabled: Boolean(metrics),\n    staleTime: 60000, // 1 minute\n  });\n\n  // Check for performance issues and generate alerts\n  const checkPerformanceAlerts = useCallback(\n    (currentMetrics: PerformanceMetrics) => {\n      const newAlerts: PerformanceAlert[] = [];\n\n      // Check each threshold\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          newAlerts.push({\n            id: `${key}-critical-${Date.now()}`,\n            type: \"critical\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.poor,\n            message: `${key.toUpperCase()} is critically high: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        } else if (value > thresholds.good) {\n          newAlerts.push({\n            id: `${key}-warning-${Date.now()}`,\n            type: \"warning\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.good,\n            message: `${key.toUpperCase()} exceeds good threshold: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        }\n      });\n\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n    },\n    [],\n  );\n\n  // Monitor performance changes\n  useEffect(() => {\n    if (metrics && isMonitoring) {\n      checkPerformanceAlerts(metrics);\n    }\n  }, [metrics, isMonitoring, checkPerformanceAlerts]);\n\n  // Measure component render time\n  const measureRenderTime = useCallback(\n    (componentName: string, renderFn: () => void) => {\n      const startTime = performance.now();\n      renderFn();\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      logger.debug(\n        `Component ${componentName} render time: ${renderTime.toFixed(2)}ms`,\n      );\n      return renderTime;\n    },\n    [],\n  );\n\n  // Measure API response time\n  const measureApiTime = useCallback(\n    async <T>(apiCall: () => Promise<T>): Promise<T> => {\n      const startTime = performance.now();\n      try {\n        const result = await apiCall();\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.debug(`API response time: ${responseTime.toFixed(2)}ms`);\n        return { result, responseTime };\n      } catch (error) {\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.warn(`API error after ${responseTime.toFixed(2)}ms`, error);\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // Clear old alerts\n  const clearOldAlerts = useCallback(() => {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    setAlerts((prev) => prev.filter((alert) => alert.timestamp > oneHourAgo));\n  }, []);\n\n  // Performance score calculation\n  const performanceScore = useCallback(\n    (currentMetrics: PerformanceMetrics): number => {\n      if (!currentMetrics) return 0;\n\n      let score = 100;\n\n      // Deduct points for poor metrics\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          score -= 30;\n        } else if (value > thresholds.good) {\n          score -= 15;\n        }\n      });\n\n      return Math.max(0, score);\n    },\n    [],\n  );\n\n  return {\n    // Current metrics\n    metrics,\n    isLoading,\n\n    // Performance insights\n    performanceScore: metrics ? performanceScore(metrics) : 0,\n    recommendations,\n    alerts,\n\n    // Controls\n    isMonitoring,\n    setIsMonitoring,\n    clearOldAlerts,\n\n    // Measurement tools\n    measureRenderTime,\n    measureApiTime,\n\n    // Computed properties\n    isPerformant: metrics ? performanceScore(metrics) > 80 : false,\n    hasIssues: alerts.length > 0,\n    criticalIssues: alerts.filter((a) => a.type === \"critical\").length,\n    warningIssues: alerts.filter((a) => a.type === \"warning\").length,\n\n    // Quick checks\n    isSlowLoading: metrics?.loadComplete\n      ? metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.good\n      : false,\n    isHighMemory: metrics?.memoryUsagePercent\n      ? metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.good\n      : false,\n    isSlowNetwork: metrics?.rtt ? metrics.rtt > 500 : false,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useCountdownTimer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskAssignment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskCRUD.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useEmergencyUnlockModal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/usePauseResumeControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useTrackerStats.ts",
    "messages": [
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 17. Maximum allowed is 15.",
        "line": 69,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 148,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useSessionTimer } from \"../useSessionTimer\";\nimport type { DBSession } from \"../../types/database\";\n\nexport interface UseTrackerStatsProps {\n  currentSession?: DBSession | null;\n  // Legacy props for backward compatibility\n  topBoxLabel?: string;\n  topBoxTime?: string;\n  mainChastityDisplayTime?: number;\n  isPaused?: boolean;\n  livePauseDuration?: number;\n  accumulatedPauseTimeThisSession?: number;\n  isCageOn?: boolean;\n  timeCageOff?: number;\n  totalChastityTime?: number;\n  totalTimeCageOff?: number;\n}\n\nexport interface UseTrackerStatsReturn {\n  // Display data\n  displayData: {\n    effectiveTime: string;\n    isPaused: boolean;\n    currentPauseDuration: string;\n    accumulatedPause: string;\n    totalElapsed: string;\n    isActive: boolean;\n    timeCageOff: number;\n    totalPauseTime: number;\n  };\n\n  // Formatted stats\n  stats: {\n    topBoxLabel: string;\n    topBoxTimestamp: string;\n    totalElapsedFormatted: string;\n    currentSessionFormatted: string;\n    cageOffTimeFormatted: string;\n    totalChastityTimeFormatted: string;\n    totalCageOffTimeFormatted: string;\n  };\n\n  // State\n  isLoading: boolean;\n}\n\n// Helper function to format time in seconds to h:m:s\nconst formatTimeFromSeconds = (seconds: number): string => {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const remainingSeconds = seconds % 60;\n  return `${hours}h ${minutes}m ${remainingSeconds}s`;\n};\n\n// Helper function to format timestamp as HH:MM:SS MM/DD/YYYY\nconst formatTimestamp = (date: Date | null | undefined): string => {\n  if (!date) return \"\";\n\n  const hours = date.getHours().toString().padStart(2, \"0\");\n  const minutes = date.getMinutes().toString().padStart(2, \"0\");\n  const seconds = date.getSeconds().toString().padStart(2, \"0\");\n  const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n  const day = date.getDate().toString().padStart(2, \"0\");\n  const year = date.getFullYear();\n\n  return `${hours}:${minutes}:${seconds} ${month}/${day}/${year}`;\n};\n\nexport const useTrackerStats = ({\n  currentSession,\n  topBoxLabel: _topBoxLabel = \"Total Locked Time\",\n  topBoxTime,\n  mainChastityDisplayTime = 0,\n  isPaused = false,\n  livePauseDuration = 0,\n  accumulatedPauseTimeThisSession = 0,\n  isCageOn = false,\n  timeCageOff = 0,\n  totalChastityTime = 0,\n  totalTimeCageOff = 0,\n}: UseTrackerStatsProps): UseTrackerStatsReturn => {\n  // Use the session timer hook for real-time updates when session is provided\n  const timerData = useSessionTimer(currentSession);\n\n  // Use real-time data if session is provided, otherwise fall back to props\n  const displayData = currentSession\n    ? {\n        effectiveTime: timerData.effectiveTimeFormatted,\n        isPaused: timerData.isPaused,\n        currentPauseDuration: timerData.currentPauseDurationFormatted,\n        accumulatedPause: timerData.currentPauseDurationFormatted,\n        totalElapsed: timerData.totalElapsedTimeFormatted,\n        isActive: timerData.isActive,\n        timeCageOff: timerData.currentCageOffTime,\n        totalPauseTime: timerData.totalSessionPauseTime,\n      }\n    : {\n        effectiveTime: formatTimeFromSeconds(mainChastityDisplayTime),\n        isPaused,\n        currentPauseDuration: formatTimeFromSeconds(livePauseDuration),\n        accumulatedPause: formatTimeFromSeconds(\n          accumulatedPauseTimeThisSession,\n        ),\n        totalElapsed: topBoxTime || \"0s\",\n        isActive: isCageOn,\n        timeCageOff: timeCageOff,\n        totalPauseTime: 0,\n      };\n\n  // Determine top box label and timestamp based on session state\n  let topBoxLabelText = \"\";\n  let topBoxTimestampText = \"\";\n\n  if (currentSession) {\n    if (currentSession.endTime) {\n      // Session ended - show when cage was taken off\n      topBoxLabelText = \"Cage Taken Off\";\n      topBoxTimestampText = formatTimestamp(currentSession.endTime);\n    } else if (currentSession.isPaused && currentSession.pauseStartTime) {\n      // Session paused - show when pause started\n      topBoxLabelText = \"Pause Started\";\n      topBoxTimestampText = formatTimestamp(currentSession.pauseStartTime);\n    } else if (currentSession.startTime) {\n      // Session active - show when caged\n      topBoxLabelText = \"Caged At\";\n      topBoxTimestampText = formatTimestamp(currentSession.startTime);\n    }\n  }\n\n  // Format all the stats for display\n  // Note: totalChastityTime and totalTimeCageOff props should come from useLifetimeStats\n  // which already includes all sessions and real-time calculations\n  const stats = {\n    topBoxLabel: topBoxLabelText,\n    topBoxTimestamp: topBoxTimestampText,\n    totalElapsedFormatted: displayData.totalElapsed,\n    currentSessionFormatted: displayData.effectiveTime,\n    cageOffTimeFormatted: formatTimeFromSeconds(displayData.timeCageOff),\n    totalChastityTimeFormatted: formatTimeFromSeconds(totalChastityTime),\n    totalCageOffTimeFormatted: formatTimeFromSeconds(totalTimeCageOff),\n  };\n\n  return {\n    displayData,\n    stats,\n    isLoading: false, // Could be connected to actual loading states in the future\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/useTheme.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 369,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 369,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [10161, 10191],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 396,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 396,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [11075, 11105],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievementGallery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievements.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (225). Maximum allowed is 150.",
        "line": 25,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 345,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useAchievements Hook\n * React hook for managing achievements and progress\n */\n\nimport { useEffect, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService, achievementEngine } from \"../services\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  AchievementCategory,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<AchievementCategory, number>;\n  recentAchievements: DBUserAchievement[];\n}\n\nexport const useAchievements = (userId?: string) => {\n  const queryClient = useQueryClient();\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get all available achievements\n   */\n  const { data: allAchievements = [], isLoading: isLoadingAchievements } =\n    useQuery({\n      queryKey: [\"achievements\"],\n      queryFn: () => achievementDBService.getAllAchievements(),\n      enabled: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n\n  /**\n   * Get user's earned achievements\n   */\n  const { data: userAchievements = [], isLoading: isLoadingUserAchievements } =\n    useQuery({\n      queryKey: [\"achievements\", \"user\", userId],\n      queryFn: () => achievementDBService.getUserAchievements(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  const { data: visibleAchievements = [] } = useQuery({\n    queryKey: [\"achievements\", \"visible\", userId],\n    queryFn: () => achievementDBService.getUserVisibleAchievements(userId!),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's achievement progress\n   */\n  const { data: achievementProgress = [], isLoading: isLoadingProgress } =\n    useQuery({\n      queryKey: [\"achievements\", \"progress\", userId],\n      queryFn: () => achievementDBService.getUserAchievementProgress(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get unread notifications\n   */\n  const { data: unreadNotifications = [], isLoading: isLoadingNotifications } =\n    useQuery({\n      queryKey: [\"achievements\", \"notifications\", userId],\n      queryFn: () => achievementDBService.getUserUnreadNotifications(userId!),\n      enabled: Boolean(userId),\n      refetchInterval: 30 * 1000, // Check every 30 seconds\n    });\n\n  /**\n   * Get achievement statistics\n   */\n  const { data: achievementStats, isLoading: isLoadingStats } = useQuery({\n    queryKey: [\"achievements\", \"stats\", userId],\n    queryFn: async (): Promise<AchievementStats> => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const [stats, achievements] = await Promise.all([\n        achievementDBService.getUserAchievementStats(userId),\n        achievementDBService.getUserAchievements(userId),\n      ]);\n\n      // Get recent achievements (last 5)\n      const recentAchievements = achievements\n        .sort(\n          (a: DBUserAchievement, b: DBUserAchievement) =>\n            b.earnedAt.getTime() - a.earnedAt.getTime(),\n        )\n        .slice(0, 5);\n\n      return {\n        ...stats,\n        recentAchievements,\n      };\n    },\n    enabled: Boolean(userId),\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Toggle achievement visibility\n   */\n  const toggleVisibilityMutation = useMutation({\n    mutationFn: ({ achievementId }: { achievementId: string }) =>\n      achievementDBService.toggleAchievementVisibility(userId!, achievementId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"visible\", userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"user\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Mark notification as read\n   */\n  const markNotificationReadMutation = useMutation({\n    mutationFn: (notificationId: string) =>\n      achievementDBService.markNotificationRead(notificationId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"notifications\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Perform full achievement check\n   */\n  const performFullCheckMutation = useMutation({\n    mutationFn: () => achievementEngine.performFullCheck(userId!),\n    onSuccess: () => {\n      // Invalidate all achievement-related queries\n      queryClient.invalidateQueries({ queryKey: [\"achievements\"] });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  // ==================== HELPER FUNCTIONS ====================\n\n  /**\n   * Get achievement by ID\n   */\n  const getAchievementById = useCallback(\n    (achievementId: string): DBAchievement | undefined => {\n      return allAchievements.find((a: DBAchievement) => a.id === achievementId);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Check if user has specific achievement\n   */\n  const hasAchievement = useCallback(\n    (achievementId: string): boolean => {\n      return userAchievements.some(\n        (ua: DBUserAchievement) => ua.achievementId === achievementId,\n      );\n    },\n    [userAchievements],\n  );\n\n  /**\n   * Get progress for specific achievement\n   */\n  const getProgressForAchievement = useCallback(\n    (achievementId: string): DBAchievementProgress | undefined => {\n      return achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievementId,\n      );\n    },\n    [achievementProgress],\n  );\n\n  /**\n   * Get achievements by category\n   */\n  const getAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBAchievement[] => {\n      return allAchievements.filter(\n        (a: DBAchievement) => a.category === category,\n      );\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Get user's achievements by category\n   */\n  const getUserAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBUserAchievement[] => {\n      const categoryAchievementIds = allAchievements\n        .filter((a: DBAchievement) => a.category === category)\n        .map((a: DBAchievement) => a.id);\n\n      return userAchievements.filter((ua: DBUserAchievement) =>\n        categoryAchievementIds.includes(ua.achievementId),\n      );\n    },\n    [allAchievements, userAchievements],\n  );\n\n  /**\n   * Get achievements with progress information\n   */\n  const getAchievementsWithProgress = useCallback(() => {\n    return allAchievements.map((achievement: DBAchievement) => {\n      const userAchievement = userAchievements.find(\n        (ua: DBUserAchievement) => ua.achievementId === achievement.id,\n      );\n      const progress = achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievement.id,\n      );\n\n      return {\n        achievement,\n        userAchievement,\n        progress: progress\n          ? {\n              currentValue: progress.currentValue,\n              targetValue: progress.targetValue,\n              percentage: Math.min(\n                (progress.currentValue / progress.targetValue) * 100,\n                100,\n              ),\n              isCompleted: progress.isCompleted,\n            }\n          : null,\n        isEarned: Boolean(userAchievement),\n        isVisible: userAchievement?.isVisible ?? true,\n      };\n    });\n  }, [allAchievements, userAchievements, achievementProgress]);\n\n  // ==================== ACTIONS ====================\n\n  const toggleAchievementVisibility = useCallback(\n    (achievementId: string) => {\n      if (!userId) return;\n      toggleVisibilityMutation.mutate({ achievementId });\n    },\n    [userId, toggleVisibilityMutation],\n  );\n\n  const markNotificationRead = useCallback(\n    (notificationId: string) => {\n      markNotificationReadMutation.mutate(notificationId);\n    },\n    [markNotificationReadMutation],\n  );\n\n  const performFullCheck = useCallback(() => {\n    if (!userId) return;\n    performFullCheckMutation.mutate();\n  }, [userId, performFullCheckMutation]);\n\n  // ==================== EFFECTS ====================\n\n  /**\n   * Initialize achievement engine on mount\n   */\n  useEffect(() => {\n    achievementEngine.initialize().catch((error) => {\n      logger.error(\n        \"Failed to initialize achievement engine\",\n        error,\n        \"useAchievements\",\n      );\n    });\n  }, []);\n\n  // ==================== RETURN ====================\n\n  return {\n    // Data\n    allAchievements,\n    userAchievements,\n    visibleAchievements,\n    achievementProgress,\n    unreadNotifications,\n    achievementStats,\n\n    // Loading states\n    isLoading: isLoadingAchievements || isLoadingUserAchievements,\n    isLoadingProgress,\n    isLoadingNotifications,\n    isLoadingStats,\n\n    // Helper functions\n    getAchievementById,\n    hasAchievement,\n    getProgressForAchievement,\n    getAchievementsByCategory,\n    getUserAchievementsByCategory,\n    getAchievementsWithProgress,\n\n    // Actions\n    toggleAchievementVisibility,\n    markNotificationRead,\n    performFullCheck,\n\n    // Mutation states\n    isTogglingVisibility: toggleVisibilityMutation.isPending,\n    isMarkingRead: markNotificationReadMutation.isPending,\n    isPerformingCheck: performFullCheckMutation.isPending,\n  };\n};\n\n/**\n * Hook for achievement notifications (can be used globally)\n */\nexport const useAchievementNotifications = (userId?: string) => {\n  const { unreadNotifications, markNotificationRead, isLoadingNotifications } =\n    useAchievements(userId);\n\n  return {\n    notifications: unreadNotifications,\n    isLoading: isLoadingNotifications,\n    markAsRead: markNotificationRead,\n    hasUnread: unreadNotifications.length > 0,\n    unreadCount: unreadNotifications.length,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useKeyholderRelationships.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 35,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 52,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 77,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useLeaderboards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/usePauseState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRelationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRulesPage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionPersistence.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionTimer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'enabled' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 53,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 53,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'sessionId' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 59,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 59,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Timer Hook\n * Provides real-time timer updates for active chastity sessions\n */\nimport { useMemo } from \"react\";\nimport type { DBSession } from \"../types/database\";\nimport { TimerService } from \"../services/TimerService\";\nimport { useSharedTimer } from \"./useSharedTimer\";\n\nexport interface SessionTimerData {\n  // Core timer values\n  effectiveTime: number; // Time in seconds excluding pauses\n  totalElapsedTime: number; // Total time including pauses\n  currentPauseDuration: number; // Current pause duration if paused\n\n  // Formatted strings\n  effectiveTimeFormatted: string;\n  totalElapsedTimeFormatted: string;\n  currentPauseDurationFormatted: string;\n\n  // Goal-related data\n  goalProgress: number; // Percentage (0-100)\n  remainingGoalTime: number; // Seconds remaining to goal\n  remainingGoalTimeFormatted: string;\n  isGoalCompleted: boolean;\n\n  // Cage off time data\n  currentCageOffTime: number; // Current session cage off (pause time if paused)\n  currentCageOffTimeFormatted: string;\n  totalSessionPauseTime: number; // Total pause time for current session\n  totalSessionPauseTimeFormatted: string;\n\n  // State flags\n  isActive: boolean; // Session exists and not ended\n  isPaused: boolean;\n\n  // Current time reference\n  currentTime: Date;\n}\n\nexport interface UseSessionTimerOptions {\n  updateInterval?: number; // Milliseconds, default 1000\n  enabled?: boolean; // Enable/disable timer updates, default true\n}\n\n/**\n * Hook for real-time session timer with live updates\n */\nexport function useSessionTimer(\n  session: DBSession | null | undefined,\n  options: UseSessionTimerOptions = {},\n): SessionTimerData {\n  const { enabled = true } = options;\n\n  // Use shared timer for perfect synchronization across all components\n  const currentTime = useSharedTimer();\n\n  // Track session state changes manually to avoid zustand warnings\n  const sessionId = session?.id;\n\n  // Memoized calculations to prevent unnecessary recalculations\n  const timerData = useMemo((): SessionTimerData => {\n    // Default values when no session or session ended\n    const defaultData: SessionTimerData = {\n      effectiveTime: 0,\n      totalElapsedTime: 0,\n      currentPauseDuration: 0,\n      effectiveTimeFormatted: \"0s\",\n      totalElapsedTimeFormatted: \"0s\",\n      currentPauseDurationFormatted: \"0s\",\n      goalProgress: 0,\n      remainingGoalTime: 0,\n      remainingGoalTimeFormatted: \"0s\",\n      isGoalCompleted: false,\n      currentCageOffTime: 0,\n      currentCageOffTimeFormatted: \"0s\",\n      totalSessionPauseTime: 0,\n      totalSessionPauseTimeFormatted: \"0s\",\n      isActive: false,\n      isPaused: false,\n      currentTime,\n    };\n\n    if (!session) {\n      return defaultData;\n    }\n\n    // If session has ended, calculate time since end (cage off time)\n    if (session.endTime) {\n      const timeSinceEnd = Math.floor(\n        (currentTime.getTime() - session.endTime.getTime()) / 1000,\n      );\n      return {\n        ...defaultData,\n        currentCageOffTime: timeSinceEnd,\n        currentCageOffTimeFormatted: TimerService.formatDuration(timeSinceEnd),\n        isActive: false,\n        isPaused: false,\n        currentTime,\n      };\n    }\n\n    // Calculate timer values\n    const effectiveTime = TimerService.calculateEffectiveTime(\n      session,\n      currentTime,\n    );\n    const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n      session,\n      currentTime,\n    );\n    const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n      session,\n      currentTime,\n    );\n\n    // Calculate goal-related data\n    const goalProgress = TimerService.calculateGoalProgress(\n      session,\n      currentTime,\n    );\n    const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n      session,\n      currentTime,\n    );\n    const isGoalCompleted = TimerService.isGoalCompleted(session, currentTime);\n\n    // Calculate cage off time data\n    const currentCageOffTime = TimerService.calculateCurrentCageOffTime(\n      session,\n      currentTime,\n    );\n    const totalSessionPauseTime = TimerService.calculateTotalSessionPauseTime(\n      session,\n      currentTime,\n    );\n\n    return {\n      effectiveTime,\n      totalElapsedTime,\n      currentPauseDuration,\n      effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n      totalElapsedTimeFormatted: TimerService.formatDuration(totalElapsedTime),\n      currentPauseDurationFormatted:\n        TimerService.formatDuration(currentPauseDuration),\n      goalProgress,\n      remainingGoalTime,\n      remainingGoalTimeFormatted:\n        TimerService.formatDuration(remainingGoalTime),\n      isGoalCompleted,\n      currentCageOffTime,\n      currentCageOffTimeFormatted:\n        TimerService.formatDuration(currentCageOffTime),\n      totalSessionPauseTime,\n      totalSessionPauseTimeFormatted: TimerService.formatDuration(\n        totalSessionPauseTime,\n      ),\n      isActive: true,\n      isPaused: session.isPaused,\n      currentTime,\n    };\n  }, [session, currentTime]);\n\n  return timerData;\n}\n\n/**\n * Hook for getting a snapshot of timer data without live updates\n * Useful for components that don't need real-time updates\n */\nexport function useSessionTimerSnapshot(\n  session: DBSession | null | undefined,\n): SessionTimerData {\n  return useSessionTimer(session, { enabled: false });\n}\n\n/**\n * Hook for multiple sessions timer data (useful for dashboards)\n */\nexport function useMultiSessionTimer(\n  sessions: (DBSession | null | undefined)[],\n  _options: UseSessionTimerOptions = {},\n): SessionTimerData[] {\n  // Use shared timer for perfect synchronization\n  const currentTime = useSharedTimer();\n\n  // Calculate timer data for each session\n  const timerDataArray = useMemo(() => {\n    return sessions.map((session) => {\n      if (!session || session.endTime) {\n        return {\n          effectiveTime: 0,\n          totalElapsedTime: 0,\n          currentPauseDuration: 0,\n          effectiveTimeFormatted: \"0s\",\n          totalElapsedTimeFormatted: \"0s\",\n          currentPauseDurationFormatted: \"0s\",\n          goalProgress: 0,\n          remainingGoalTime: 0,\n          remainingGoalTimeFormatted: \"0s\",\n          isGoalCompleted: false,\n          currentCageOffTime: 0,\n          currentCageOffTimeFormatted: \"0s\",\n          totalSessionPauseTime: 0,\n          totalSessionPauseTimeFormatted: \"0s\",\n          isActive: false,\n          isPaused: false,\n          currentTime,\n        };\n      }\n\n      const effectiveTime = TimerService.calculateEffectiveTime(\n        session,\n        currentTime,\n      );\n      const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n        session,\n        currentTime,\n      );\n      const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n        session,\n        currentTime,\n      );\n      const goalProgress = TimerService.calculateGoalProgress(\n        session,\n        currentTime,\n      );\n      const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n        session,\n        currentTime,\n      );\n      const isGoalCompleted = TimerService.isGoalCompleted(\n        session,\n        currentTime,\n      );\n      const currentCageOffTime = TimerService.calculateCurrentCageOffTime(\n        session,\n        currentTime,\n      );\n      const totalSessionPauseTime = TimerService.calculateTotalSessionPauseTime(\n        session,\n        currentTime,\n      );\n\n      return {\n        effectiveTime,\n        totalElapsedTime,\n        currentPauseDuration,\n        effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n        totalElapsedTimeFormatted:\n          TimerService.formatDuration(totalElapsedTime),\n        currentPauseDurationFormatted:\n          TimerService.formatDuration(currentPauseDuration),\n        goalProgress,\n        remainingGoalTime,\n        remainingGoalTimeFormatted:\n          TimerService.formatDuration(remainingGoalTime),\n        isGoalCompleted,\n        currentCageOffTime,\n        currentCageOffTimeFormatted:\n          TimerService.formatDuration(currentCageOffTime),\n        totalSessionPauseTime,\n        totalSessionPauseTimeFormatted: TimerService.formatDuration(\n          totalSessionPauseTime,\n        ),\n        isActive: true,\n        isPaused: session.isPaused,\n        currentTime,\n      };\n    });\n  }, [sessions, currentTime]);\n\n  return timerDataArray;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSharedTimer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSpecialChallenges.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (195). Maximum allowed is 150.",
        "line": 27,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 267,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport { goalDBService } from \"@/services/database/GoalDBService\";\nimport type { DBGoal } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { useAchievementIntegration } from \"@/constants/challengeAchievements\";\n\nconst logger = serviceLogger(\"useSpecialChallenges\");\n\nexport interface SpecialChallengeStatus {\n  locktober: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n  noNutNovember: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n}\n\n/**\n * Hook for managing special challenge goals (Locktober, No Nut November)\n */\nexport const useSpecialChallenges = (userId: string | null) => {\n  const [challengeStatus, setChallengeStatus] =\n    useState<SpecialChallengeStatus>({\n      locktober: { available: false, active: false, completed: false },\n      noNutNovember: { available: false, active: false, completed: false },\n    });\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const { checkForChallengeAchievements } = useAchievementIntegration();\n\n  /**\n   * Check if challenges are available based on current date\n   */\n  const checkChallengeAvailability = useCallback(() => {\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth(); // 0-based\n\n    return {\n      locktober: currentMonth === 9, // October\n      noNutNovember: currentMonth === 10, // November\n    };\n  }, []);\n\n  /**\n   * Load challenge status for the user\n   */\n  const loadChallengeStatus = useCallback(async () => {\n    if (!userId) {\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const availability = checkChallengeAvailability();\n      const specialGoals = await goalDBService.getSpecialChallengeGoals(userId);\n      const currentYear = new Date().getFullYear();\n\n      // Find current year's goals\n      const locktoberGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"locktober\" &&\n          goal.challengeYear === currentYear,\n      );\n      const noNutGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"no_nut_november\" &&\n          goal.challengeYear === currentYear,\n      );\n\n      setChallengeStatus({\n        locktober: {\n          available: availability.locktober,\n          active: !!locktoberGoal && !locktoberGoal.isCompleted,\n          completed: !!locktoberGoal?.isCompleted,\n          goal: locktoberGoal,\n        },\n        noNutNovember: {\n          available: availability.noNutNovember,\n          active: !!noNutGoal && !noNutGoal.isCompleted,\n          completed: !!noNutGoal?.isCompleted,\n          goal: noNutGoal,\n        },\n      });\n\n      logger.debug(\"Loaded challenge status\", {\n        userId,\n        hasLocktober: !!locktoberGoal,\n        hasNoNut: !!noNutGoal,\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Unknown error\";\n      setError(errorMessage);\n      logger.error(\"Failed to load challenge status\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, checkChallengeAvailability]);\n\n  /**\n   * Join a special challenge\n   */\n  const joinChallenge = useCallback(\n    async (challengeType: \"locktober\" | \"no_nut_november\") => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        setError(null);\n        const goal = await goalDBService.getOrCreateChallengeGoal(\n          userId,\n          challengeType,\n        );\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"User joined challenge\", {\n          userId,\n          challengeType,\n          goalId: goal.id,\n        });\n        return goal;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to join challenge\";\n        setError(errorMessage);\n        logger.error(\"Failed to join challenge\", {\n          error: err,\n          userId,\n          challengeType,\n        });\n        throw err;\n      }\n    },\n    [userId, loadChallengeStatus],\n  );\n\n  /**\n   * Update challenge progress\n   */\n  const updateChallengeProgress = useCallback(\n    async (\n      challengeType: \"locktober\" | \"no_nut_november\",\n      progressValue: number,\n    ) => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        const challengeMap = {\n          locktober: challengeStatus.locktober,\n          no_nut_november: challengeStatus.noNutNovember,\n        };\n        const challenge =\n          challengeMap[challengeType as keyof typeof challengeMap];\n        if (!challenge.goal) {\n          throw new Error(\"Challenge goal not found\");\n        }\n\n        await goalDBService.updateGoalProgress(\n          challenge.goal.id,\n          progressValue,\n        );\n\n        // Check if challenge was completed and trigger achievements\n        const updatedGoal = await goalDBService.findById(challenge.goal.id);\n        if (updatedGoal?.isCompleted) {\n          await checkForChallengeAchievements({\n            challengeType: updatedGoal.challengeType,\n            challengeYear: updatedGoal.challengeYear,\n            isCompleted: updatedGoal.isCompleted,\n          });\n        }\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"Updated challenge progress\", {\n          userId,\n          challengeType,\n          progressValue,\n          goalId: challenge.goal.id,\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to update progress\";\n        setError(errorMessage);\n        logger.error(\"Failed to update challenge progress\", {\n          error: err,\n          userId,\n          challengeType,\n          progressValue,\n        });\n        throw err;\n      }\n    },\n    [\n      userId,\n      challengeStatus,\n      loadChallengeStatus,\n      checkForChallengeAchievements,\n    ],\n  );\n\n  /**\n   * Get progress percentage for a challenge\n   */\n  const getChallengeProgress = useCallback(\n    (challengeType: \"locktober\" | \"no_nut_november\") => {\n      const challenge = challengeStatus[challengeType];\n      if (!challenge.goal) return 0;\n\n      return Math.min(\n        100,\n        (challenge.goal.currentValue / challenge.goal.targetValue) * 100,\n      );\n    },\n    [challengeStatus],\n  );\n\n  // Load challenge status on mount and when userId changes\n  useEffect(() => {\n    loadChallengeStatus();\n  }, [userId, checkChallengeAvailability, loadChallengeStatus]);\n\n  // Refresh status every hour to check for date changes\n  useEffect(() => {\n    const interval = setInterval(\n      () => {\n        const availability = checkChallengeAvailability();\n        setChallengeStatus((prev) => ({\n          ...prev,\n          locktober: { ...prev.locktober, available: availability.locktober },\n          noNutNovember: {\n            ...prev.noNutNovember,\n            available: availability.noNutNovember,\n          },\n        }));\n      },\n      60 * 60 * 1000,\n    ); // Check every hour\n\n    return () => clearInterval(interval);\n  }, [checkChallengeAvailability]);\n\n  return {\n    challengeStatus,\n    isLoading,\n    error,\n    joinChallenge,\n    updateChallengeProgress,\n    getChallengeProgress,\n    refreshStatus: loadChallengeStatus,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSync.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useTrackerHandlers.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setCurrentSession'. Either include it or remove the dependency array. If 'setCurrentSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 77,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 77,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setCurrentSession]",
            "fix": { "range": [2443, 2445], "text": "[setCurrentSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'backupSession'. Either include it or remove the dependency array. If 'backupSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 88,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 88,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [backupSession, currentSession, isSessionInitialized]",
            "fix": {
              "range": [2846, 2884],
              "text": "[backupSession, currentSession, isSessionInitialized]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/AchievementPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/ChastityTracking.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'CooldownDisplay' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 97,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 97,
        "endColumn": 22
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (278). Maximum allowed is 150.",
        "line": 229,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 549,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 43. Maximum allowed is 15.",
        "line": 229,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 549,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'canStart' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 268,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 268,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'canEnd' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 269,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 269,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'canResume' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 271,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 271,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'sessionError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 278,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 278,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timeUntilNextPause' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 279,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 279,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9350, 9353], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9350, 9353], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handlePause' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 349,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 349,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleResume' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 350,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 350,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from \"react\";\nimport { RestoreSessionPrompt } from \"../components/tracker/RestoreSessionPrompt\";\nimport { SessionLoader } from \"../components/tracker/SessionLoader\";\nimport { SessionRecoveryModal } from \"../components/tracker/SessionRecoveryModal\";\nimport { TrackerStats } from \"../components/tracker/TrackerStats\";\nimport { ActionButtons } from \"../components/tracker/ActionButtons\";\nimport { PauseResumeButtons } from \"../components/tracker/PauseResumeButtons\";\n// TODO: CooldownTimer temporarily disabled due to service import restrictions\n// import { CooldownTimer } from \"../components/tracker/CooldownTimer\";\nimport { ReasonModals } from \"../components/tracker/ReasonModals\";\nimport { TrackerHeader } from \"../components/tracker/TrackerHeader\";\nimport { useSessionPersistence } from \"../hooks/useSessionPersistence\";\nimport { useAuth } from \"../hooks/api/useAuth\";\nimport { useTrackerHandlers } from \"../hooks/useTrackerHandlers\";\nimport { useSessionActions } from \"../hooks/session/useSessionActions\";\nimport { useLifetimeStats } from \"../hooks/stats/useLifetimeStats\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession } from \"../types/database\";\nimport type { SessionRestorationResult } from \"../services/SessionPersistenceService\";\nimport type { User } from \"../types/auth\";\n\n// Helper function to handle session restoration\nconst createSessionRestorationHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    startHeartbeat: (sessionId: string) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n  ) =>\n  (result: SessionRestorationResult) => {\n    logger.info(\"Session restoration completed\", {\n      wasRestored: result.wasRestored,\n      sessionId: result.session?.id,\n    });\n\n    if (result.session) {\n      setCurrentSession(result.session);\n      startHeartbeat(result.session.id);\n\n      // If session had validation issues but was recovered, show recovery modal\n      if (result.error && result.session) {\n        setCorruptedSession(result.session);\n        setShowSessionRecovery(true);\n      }\n    }\n  };\n\n// Helper function to handle session recovery\nconst createSessionRecoveryHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    backupSession: (session: DBSession) => Promise<void>,\n    startHeartbeat: (sessionId: string) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n  ) =>\n  async (session: DBSession) => {\n    logger.info(\"Session recovery initiated\", { sessionId: session.id });\n    try {\n      await backupSession(session);\n      setCurrentSession(session);\n      startHeartbeat(session.id);\n      setShowSessionRecovery(false);\n      setCorruptedSession(null);\n      logger.info(\"Session recovery completed\", { sessionId: session.id });\n    } catch (error) {\n      logger.error(\"Session recovery failed\", { error: error as Error });\n    }\n  };\n\n// Helper function to handle session discard\nconst createSessionDiscardHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    stopHeartbeat: () => void,\n  ) =>\n  () => {\n    setCurrentSession(null);\n    setShowSessionRecovery(false);\n    setCorruptedSession(null);\n    stopHeartbeat();\n    logger.info(\"Corrupted session discarded\");\n  };\n\n// Session Persistence Error Component\nconst SessionPersistenceError: React.FC<{ error: string }> = ({ error }) => (\n  <div className=\"mx-4 mb-4 p-3 bg-red-900/50 border border-red-500 rounded-lg\">\n    <p className=\"text-sm text-red-200\">\n      <strong>Session Error:</strong> {error}\n    </p>\n  </div>\n);\n\n// Cooldown Display Component\nconst CooldownDisplay: React.FC<{\n  pauseState: { cooldownRemaining?: number } | null;\n}> = ({ pauseState }) => {\n  if (!pauseState?.cooldownRemaining) return null;\n\n  return (\n    <div className=\"mx-4 text-center\">\n      <div className=\"text-yellow-600\">\n        Cooldown: {pauseState.cooldownRemaining}s remaining\n      </div>\n    </div>\n  );\n};\n\n// Debug Panel Component\ninterface PauseState {\n  canPause: boolean;\n  cooldownRemaining?: number;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n}\n\nconst DebugPanel: React.FC<{\n  pauseState: PauseState | null;\n  pauseStateLoading: boolean;\n  pauseStateError: string | null;\n}> = ({ pauseState, pauseStateLoading, pauseStateError }) => {\n  if (process.env.NODE_ENV !== \"development\") return null;\n\n  return (\n    <div className=\"mt-8 p-4 bg-gray-800 rounded-lg text-xs\">\n      <h4 className=\"text-yellow-400 font-bold mb-2\">Debug: Pause State</h4>\n      <pre className=\"text-gray-300\">\n        {JSON.stringify(\n          {\n            canPause: pauseState?.canPause,\n            cooldownRemaining: pauseState?.cooldownRemaining,\n            lastPauseTime: pauseState?.lastPauseTime,\n            nextPauseAvailable: pauseState?.nextPauseAvailable,\n            isLoading: pauseStateLoading,\n            error: pauseStateError,\n          },\n          null,\n          2,\n        )}\n      </pre>\n    </div>\n  );\n};\n\n// Custom hook for session state management\nconst useSessionState = () => {\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [showSessionRecovery, setShowSessionRecovery] = useState(false);\n  const [isSessionInitialized, setIsSessionInitialized] = useState(false);\n  const [corruptedSession, setCorruptedSession] = useState<DBSession | null>(\n    null,\n  );\n\n  return {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  };\n};\n\n// Custom hook for mock data (DEMO VERSION - keep for #308)\n// Real version uses useSessionActions + useSession\nconst useMockData = (user: User | null) => {\n  // Mock pause state data for now\n  const pauseState: PauseState = {\n    canPause: true,\n    cooldownRemaining: undefined,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n  };\n  const pauseStateLoading = false;\n  const pauseStateError = null;\n  const refreshPauseState = () => {};\n\n  // Mock session data - replace with real session management\n  const mockSessionData = {\n    isCageOn: true,\n    isPaused: false,\n    remainingGoalTime: 3600,\n    keyholderName: \"Keyholder\",\n    savedSubmissivesName: \"Submissive\",\n    requiredKeyholderDurationSeconds: 7200,\n    mainChastityDisplayTime: 3600,\n    topBoxLabel: \"Total Locked Time\",\n    topBoxTime: \"1d 2h 3m\",\n    livePauseDuration: 0,\n    accumulatedPauseTimeThisSession: 0,\n    timeCageOff: 0,\n    totalChastityTime: 86400,\n    totalTimeCageOff: 0,\n    showRestoreSessionPrompt: false,\n    pauseCooldownMessage: null,\n    denialCooldownActive: false,\n    hasPendingReleaseRequest: false,\n    isGoalActive: true,\n    isHardcoreGoal: false,\n    showReasonModal: false,\n    showPauseReasonModal: false,\n    useRealTimeTimer: false, // Feature flag for real-time timer\n    sessionId: \"mock-session-123\",\n    userId: user?.uid || \"mock-user-123\",\n  };\n\n  // Override pause state for demo - show that pause is available\n  const mockPauseState = {\n    canPause: true,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n    cooldownRemaining: undefined,\n  };\n\n  return {\n    pauseState,\n    pauseStateLoading,\n    pauseStateError,\n    refreshPauseState,\n    ...mockSessionData,\n    mockPauseState,\n  };\n};\n\nconst TrackerPage: React.FC = () => {\n  // Feature flag: set to true to use real session hooks, false for demo/mock\n  const USE_REAL_SESSIONS = true; // TODO: Move to env var or settings for #308\n\n  // Authentication state\n  const { user, isLoading: authLoading } = useAuth();\n\n  // Session persistence state\n  const {\n    isInitializing,\n    error: persistenceError,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n  } = useSessionPersistence({\n    userId: user?.uid,\n    autoInitialize: true,\n  });\n\n  // Session state management\n  const {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  } = useSessionState();\n\n  // Real session hooks (when USE_REAL_SESSIONS = true)\n  const {\n    startSession: startSessionCore,\n    endSession: endSessionCore,\n    pauseSession: pauseSessionCore,\n    resumeSession: resumeSessionCore,\n    isStarting,\n    isEnding,\n    canStart,\n    canEnd,\n    canPause,\n    canResume,\n    isActive,\n    isPaused,\n    sessionId,\n    session: realSession,\n    goals,\n    duration,\n    error: sessionError,\n    timeUntilNextPause,\n    cooldownRemaining,\n  } = useSessionActions({\n    userId: user?.uid || \"\",\n    onSessionStarted: () => logger.info(\"Session started\"),\n    onSessionEnded: () => logger.info(\"Session ended\"),\n    onSessionPaused: () => logger.info(\"Session paused\"),\n    onSessionResumed: () => logger.info(\"Session resumed\"),\n  });\n\n  // Lifetime stats across all sessions\n  const lifetimeStats = useLifetimeStats(user?.uid);\n  const { refresh: refreshLifetimeStats } = lifetimeStats;\n\n  // Wrap session actions to refresh lifetime stats after each action\n  const startSession = async (config?: any) => {\n    await startSessionCore(config);\n    await refreshLifetimeStats();\n  };\n\n  const endSession = async (reason?: string) => {\n    await endSessionCore(reason);\n    await refreshLifetimeStats();\n  };\n\n  const pauseSession = async (reason?: string) => {\n    await pauseSessionCore(reason);\n    await refreshLifetimeStats();\n  };\n\n  const resumeSession = async () => {\n    await resumeSessionCore();\n    await refreshLifetimeStats();\n  };\n\n  // Mock data (for demo version - keep for #308)\n  const mockData = useMockData(user);\n\n  // Data selector: choose between real and mock data\n  const trackerData = USE_REAL_SESSIONS\n    ? {\n        isCageOn: isActive,\n        isPaused,\n        sessionId: sessionId || undefined,\n        userId: user?.uid,\n        isGoalActive: goals?.active?.length > 0,\n        isHardcoreGoal: realSession?.isHardcoreMode || false,\n        requiredKeyholderDurationSeconds: 0, // TODO: Get from keyholder goals\n        hasPendingReleaseRequest: false, // TODO: Implement release requests\n        mainChastityDisplayTime: duration,\n        totalChastityTime: duration,\n      }\n    : {\n        isCageOn: mockData.isCageOn,\n        isPaused: mockData.isPaused,\n        sessionId: mockData.sessionId,\n        userId: mockData.userId,\n        isGoalActive: mockData.isGoalActive,\n        isHardcoreGoal: mockData.isHardcoreGoal,\n        requiredKeyholderDurationSeconds:\n          mockData.requiredKeyholderDurationSeconds,\n        hasPendingReleaseRequest: mockData.hasPendingReleaseRequest,\n        mainChastityDisplayTime: mockData.mainChastityDisplayTime,\n        totalChastityTime: mockData.totalChastityTime,\n      };\n\n  // Use tracker handlers hook for event handlers and effects\n  const {\n    handleSessionInitialized,\n    handleEmergencyUnlock,\n    handlePause,\n    handleResume,\n  } = useTrackerHandlers({\n    setCurrentSession,\n    setIsSessionInitialized,\n    startHeartbeat,\n    stopHeartbeat,\n    backupSession,\n    mockData: {\n      sessionId: mockData.sessionId,\n      userId: mockData.userId,\n      refreshPauseState: mockData.refreshPauseState,\n    },\n    currentSession,\n    isSessionInitialized,\n  });\n\n  // Create handlers using helper functions\n  const handleSessionRestored = createSessionRestorationHandler(\n    setCurrentSession,\n    startHeartbeat,\n    setCorruptedSession,\n    setShowSessionRecovery,\n  );\n\n  const handleRecoverSession = createSessionRecoveryHandler(\n    setCurrentSession,\n    backupSession,\n    startHeartbeat,\n    setShowSessionRecovery,\n    setCorruptedSession,\n  );\n\n  const handleDiscardSession = createSessionDiscardHandler(\n    setCurrentSession,\n    setShowSessionRecovery,\n    setCorruptedSession,\n    stopHeartbeat,\n  );\n\n  // Helper to compute TrackerStats props based on real vs mock mode\n  const getTrackerStatsProps = () => {\n    if (USE_REAL_SESSIONS) {\n      // Real session mode - use live data with lifetime stats\n      return {\n        topBoxLabel: \"Total Locked Time\",\n        timeCageOff: 0, // Current session cage off time (handled by useSessionTimer)\n        isCageOn: isActive,\n        totalChastityTime: lifetimeStats.totalChastityTime,\n        totalTimeCageOff: lifetimeStats.totalCageOffTime,\n        isPaused,\n        currentSession: realSession,\n        mainChastityDisplayTime: undefined,\n        topBoxTime: undefined,\n        livePauseDuration: undefined,\n        accumulatedPauseTimeThisSession: undefined,\n      };\n    }\n\n    // Mock mode for demo (#308)\n    const baseProps = {\n      topBoxLabel: mockData.topBoxLabel,\n      timeCageOff: mockData.timeCageOff,\n      isCageOn: mockData.isCageOn,\n      totalChastityTime: mockData.totalChastityTime,\n      totalTimeCageOff: mockData.totalTimeCageOff,\n      isPaused: mockData.isPaused,\n    };\n\n    if (mockData.useRealTimeTimer) {\n      return {\n        ...baseProps,\n        currentSession,\n        mainChastityDisplayTime: undefined,\n        topBoxTime: undefined,\n        livePauseDuration: undefined,\n        accumulatedPauseTimeThisSession: undefined,\n      };\n    }\n\n    return {\n      ...baseProps,\n      currentSession: undefined,\n      mainChastityDisplayTime: mockData.mainChastityDisplayTime,\n      topBoxTime: mockData.topBoxTime,\n      livePauseDuration: mockData.livePauseDuration,\n      accumulatedPauseTimeThisSession: mockData.accumulatedPauseTimeThisSession,\n    };\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Session Persistence Loading */}\n      {(authLoading || isInitializing) && user?.uid && (\n        <SessionLoader\n          userId={user.uid}\n          onSessionRestored={handleSessionRestored}\n          onInitialized={handleSessionInitialized}\n        />\n      )}\n\n      {/* Session Recovery Modal */}\n      {showSessionRecovery && corruptedSession && (\n        <SessionRecoveryModal\n          corruptedSession={corruptedSession}\n          onRecover={handleRecoverSession}\n          onDiscard={handleDiscardSession}\n        />\n      )}\n\n      {/* Session Persistence Error */}\n      {persistenceError && <SessionPersistenceError error={persistenceError} />}\n\n      {mockData.showRestoreSessionPrompt && (\n        <RestoreSessionPrompt onConfirm={() => {}} onDiscard={() => {}} />\n      )}\n\n      <TrackerHeader\n        remainingGoalTime={\n          USE_REAL_SESSIONS && goals?.active && goals.active.length > 0\n            ? goals.active[0].targetValue - goals.active[0].currentValue\n            : 0\n        }\n        keyholderName={\n          USE_REAL_SESSIONS &&\n          goals?.keyholderAssigned &&\n          goals.keyholderAssigned.length > 0\n            ? \"Keyholder\"\n            : \"\"\n        }\n        savedSubmissivesName=\"\"\n        requiredKeyholderDurationSeconds={\n          USE_REAL_SESSIONS &&\n          goals?.keyholderAssigned &&\n          goals.keyholderAssigned.length > 0\n            ? goals.keyholderAssigned[0].targetValue\n            : 0\n        }\n        isCageOn={USE_REAL_SESSIONS ? isActive : mockData.isCageOn}\n        denialCooldownActive={mockData.denialCooldownActive}\n        pauseCooldownMessage={mockData.pauseCooldownMessage}\n      />\n\n      <TrackerStats {...getTrackerStatsProps()} />\n\n      {/* Enhanced Pause Controls with 6-hour cooldown */}\n      {USE_REAL_SESSIONS && isActive && (\n        <>\n          <PauseResumeButtons\n            sessionId={sessionId || \"\"}\n            userId={user?.uid || \"\"}\n            isPaused={isPaused}\n            pauseState={{\n              canPause,\n              cooldownRemaining,\n              lastPauseTime: undefined,\n              nextPauseAvailable: undefined,\n            }}\n            onPause={() => pauseSession(\"bathroom\")}\n            onResume={resumeSession}\n          />\n        </>\n      )}\n\n      <ActionButtons\n        isCageOn={trackerData.isCageOn}\n        isGoalActive={trackerData.isGoalActive}\n        isHardcoreGoal={trackerData.isHardcoreGoal}\n        requiredKeyholderDurationSeconds={\n          trackerData.requiredKeyholderDurationSeconds\n        }\n        hasPendingReleaseRequest={trackerData.hasPendingReleaseRequest}\n        sessionId={trackerData.sessionId}\n        userId={trackerData.userId}\n        onStartSession={USE_REAL_SESSIONS ? () => startSession() : undefined}\n        onEndSession={\n          USE_REAL_SESSIONS ? () => endSession(\"User ended session\") : undefined\n        }\n        onBegForRelease={\n          USE_REAL_SESSIONS\n            ? () => logger.info(\"Beg for release - TODO: implement\")\n            : undefined\n        }\n        isStarting={USE_REAL_SESSIONS ? isStarting : false}\n        isEnding={USE_REAL_SESSIONS ? isEnding : false}\n        onEmergencyUnlock={handleEmergencyUnlock}\n      />\n\n      <ReasonModals\n        showReasonModal={mockData.showReasonModal}\n        showPauseReasonModal={mockData.showPauseReasonModal}\n      />\n\n      <DebugPanel\n        pauseState={mockData.pauseState}\n        pauseStateLoading={mockData.pauseStateLoading}\n        pauseStateError={mockData.pauseStateError}\n      />\n    </div>\n  );\n};\n\nexport default TrackerPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/Dashboard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SessionPersistenceDemo' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n  MobileDashboardLayout,\n  DesktopDashboardLayout,\n} from \"../components/dashboard/DashboardLayouts\";\nimport { AchievementDashboard } from \"../components/achievements\";\nimport { SessionPersistenceDemo } from \"../components/demo/SessionPersistenceDemo\";\n// TODO: DexieDemo temporarily disabled due to architectural restrictions\n// import { DexieDemo } from \"../components/common\";\nimport { sessionDBService } from \"../services/database\";\nimport { useAuthState } from \"../contexts\";\nimport { useAchievements } from \"../hooks/useAchievements\";\n\nconst Dashboard: React.FC = () => {\n  const { user } = useAuthState();\n  const [sessionDuration, setSessionDuration] = useState(\"0s\");\n  const { userAchievements } = useAchievements(user?.uid);\n\n  useEffect(() => {\n    if (user) {\n      const fetchSession = async () => {\n        const session = await sessionDBService.getCurrentSession(user.uid);\n        if (session) {\n          // This is a simplified duration calculation. A more robust solution would be needed.\n          const duration = Math.floor(\n            (new Date().getTime() - session.startTime.getTime()) / 1000,\n          );\n          setSessionDuration(`${duration}s`);\n        }\n      };\n      fetchSession();\n    }\n  }, [user]);\n\n  return (\n    <>\n      <main className=\"font-inter\">\n        {/* Dashboard title */}\n        <div className=\"text-center mb-8\">\n          <h1 className=\"text-4xl md:text-5xl font-bold text-white mb-4\">\n            ChastityOS\n          </h1>\n        </div>\n\n        {/* Mobile and Desktop Layouts */}\n        <MobileDashboardLayout sessionDuration={sessionDuration} />\n        <DesktopDashboardLayout sessionDuration={sessionDuration} />\n\n        {/* Achievement Dashboard - only show if user has achievements */}\n        {user && userAchievements && userAchievements.length > 0 && (\n          <div className=\"mt-12\">\n            <AchievementDashboard />\n          </div>\n        )}\n\n        {/* TODO: Session Persistence Demo - moved to showcase/demo section */}\n        {/* <div className=\"mt-12\">\n          <SessionPersistenceDemo />\n        </div> */}\n\n        {/* TODO: Dexie Offline Demo temporarily disabled due to architectural restrictions */}\n        {/* <div className=\"mb-8\">\n          <div className=\"glass-card\">\n            <DexieDemo />\n          </div>\n        </div> */}\n\n        {/* Enhanced Keyholder access button */}\n        <div className=\"text-center mt-8\">\n          <Link to=\"/keyholder\">\n            <button className=\"bg-tekhelet hover:bg-tekhelet-600 text-white font-bold py-3 px-8 rounded-lg transition-colors duration-200\">\n              View Keyholder Dashboard\n            </button>\n          </Link>\n        </div>\n      </main>\n    </>\n  );\n};\n\nexport default Dashboard;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/FullReportPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/LogEventPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/MobileShowcase.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/PublicProfilePage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RelationshipsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RewardsPunishmentsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RulesPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsMainPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/TasksPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ButtonVariantsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/HapticFeedbackDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/InputExamplesDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/PullToRefreshDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ShowcaseHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/SwipeableCardDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ToastDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/TouchTargetsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/EffectiveTimeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/KeyholderRelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseCooldownService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/SessionPersistenceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/TimerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/api/session-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/auth-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/cache-config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/AchievementDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/BaseDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EmergencyService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EventDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/GoalDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/KeyholderRelationshipDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/MigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/PerformanceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/RelationshipChastityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SessionDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SettingsDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/TaskDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementBadgeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementLeaderboardService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementNotificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 86,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 86,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2887, 2890], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2887, 2890], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 90,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 90,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3075, 3078], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3075, 3078], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3262, 3265], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3262, 3265], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityEventService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastitySessionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityTaskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipCoreService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipPermissionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipInviteService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipRoleService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipSearchService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatusService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipValidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/eventDraftStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/feedbackService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/firebase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/gamificationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/goalStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/healthCheckStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migration/DataMigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migrationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/reportStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/ChastityDB.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/dexie.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/AchievementDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/ConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/EventDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseListeners.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSyncCore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/OfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/RelationshipDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SessionDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SyncConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/TaskDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/UserSettingsSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/connectionStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/themeStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/formStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/keyholderStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/modalStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/navigationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/notificationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/themeStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/uiPreferencesStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test/setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/database.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/events.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/feedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/pauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/realtime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/relationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/security.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/theme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/achievements/gallery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/achievements/profile.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/auth/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/dataSyncHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/emergency/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/error-handling/handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/events/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/filtering/tasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/date.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/time.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/gamification/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goals/common.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goals/personal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goals/session.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goalsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/hash.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/string.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/iconImport.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/keyholder/multi-wearer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/logging.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/notifications/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseAnalytics.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'analytics' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 42,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 42,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'lastPauseDuration' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 43,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 43,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Pause Analytics Utility Functions\n * Helper functions for pause/resume analytics and calculations\n */\nimport type {\n  PauseHistoryEntry,\n  PauseAnalytics,\n  PausePattern,\n  CooldownState,\n} from \"../types/pauseResume\";\n\nexport function calculatePauseFrequency(history: PauseHistoryEntry[]): number {\n  if (history.length === 0) return 0;\n\n  // Calculate pauses per day over the last 7 days\n  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n  const recentPauses = history.filter(\n    (pause) => pause.startTime >= sevenDaysAgo,\n  );\n\n  return recentPauses.length / 7;\n}\n\nexport function calculateAdaptiveCooldown(\n  history: PauseHistoryEntry[],\n  analytics: PauseAnalytics,\n): number {\n  // Base cooldown of 5 minutes\n  let cooldown = 300;\n\n  // Increase based on pause frequency\n  if (analytics.pauseFrequency > 3) cooldown *= 1.5;\n  if (analytics.pauseFrequency > 5) cooldown *= 2;\n\n  // Decrease for good behavior\n  if (analytics.pauseFrequency < 1) cooldown *= 0.8;\n\n  return Math.min(3600, Math.max(60, cooldown)); // Between 1 minute and 1 hour\n}\n\nexport function calculateCooldownDuration(\n  analytics: PauseAnalytics,\n  lastPauseDuration: number,\n): number {\n  // 6 hour cooldown after any pause to prevent abuse\n  return 21600; // 6 hours = 21600 seconds\n}\n\nexport function calculatePauseAnalytics(\n  history: PauseHistoryEntry[],\n): PauseAnalytics {\n  if (history.length === 0) {\n    return {\n      totalPauses: 0,\n      averagePauseDuration: 0,\n      pauseFrequency: 0,\n      emergencyPauseCount: 0,\n      keyholderInitiatedCount: 0,\n      cooldownViolations: 0,\n      patterns: [],\n    };\n  }\n\n  const totalDuration = history.reduce((sum, pause) => sum + pause.duration, 0);\n  const emergencyPauses = history.filter((pause) => pause.wasEmergency).length;\n  const keyholderPauses = history.filter(\n    (pause) => pause.initiatedBy === \"keyholder\",\n  ).length;\n\n  return {\n    totalPauses: history.length,\n    averagePauseDuration: totalDuration / history.length,\n    pauseFrequency: calculatePauseFrequency(history),\n    emergencyPauseCount: emergencyPauses,\n    keyholderInitiatedCount: keyholderPauses,\n    cooldownViolations: 0, // Would need to track this separately\n    patterns: analyzePausePatterns(history),\n  };\n}\n\nexport function analyzePausePatterns(\n  history: PauseHistoryEntry[],\n): PausePattern[] {\n  const patterns: PausePattern[] = [];\n\n  // Analyze time-based patterns\n  const hourCounts = new Array(24).fill(0);\n  history.forEach((pause) => {\n    const hour = pause.startTime.getHours();\n    hourCounts[hour]++;\n  });\n\n  const peakHour = hourCounts.indexOf(Math.max(...hourCounts));\n  if (hourCounts[peakHour] > history.length * 0.3) {\n    patterns.push({\n      type: \"time_based\",\n      description: `High pause frequency at ${peakHour}:00`,\n      frequency: hourCounts[peakHour] / history.length,\n      severity: hourCounts[peakHour] > history.length * 0.5 ? \"high\" : \"medium\",\n    });\n  }\n\n  return patterns;\n}\n\nexport function calculateCooldownEffectiveness(\n  _history: PauseHistoryEntry[],\n  _cooldownState: CooldownState,\n): number {\n  // Simple effectiveness calculation based on pause spacing\n  // More sophisticated analysis would consider cooldown violations\n  return 75; // Placeholder - would calculate actual effectiveness\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseResumeHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/realtime/notification-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/realtime/presence.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/realtime/sync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/audit-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/security-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/session-history-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/sessionHistoryHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/settings/account.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/settings/api.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/settings/display.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/sorting/tasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/calculations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/keyholder.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/predictions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statisticsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/systemInfo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/test/utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/toastBridge.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 72,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 72,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [2678, 2732], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 92,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 92,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [3186, 3229], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 120,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 120,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [3880, 3944], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 132,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 132,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4245, 4311], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 144,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 144,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [4606, 4671], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 156,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 156,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4972, 5038], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 168,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 168,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [5330, 5393], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "info" },
            "desc": "Remove the console.info()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 180,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 180,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [5691, 5757], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 189,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 189,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [5982, 6048], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 198,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 198,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [6256, 6316], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/validation/email.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/validation/message.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/validation/role.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/validation/timer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/vite-env.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/vitest.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
