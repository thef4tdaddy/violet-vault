name: Daily Health Check

on:
  schedule:
    # Run every day at 09:00 UTC
    - cron: "0 9 * * *"
  workflow_dispatch:
    inputs:
      context:
        description: "Execution Context"
        required: true
        default: "alpha"
        type: choice
        options:
          - alpha
          - beta
          - production

permissions:
  contents: write
  issues: write

jobs:
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        branch: [develop, main]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ matrix.branch }}

      # --- Setup Environments ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Setup Go
        if: hashFiles('api/go.sum') != ''
        uses: actions/setup-go@v5
        with:
          go-version: "1.23.1"
          cache-dependency-path: api/go.sum

      - name: Setup Python
        if: hashFiles('requirements.txt', 'pyproject.toml', 'api/requirements.txt') != ''
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      # --- Install Dependencies ---
      - name: Install Node Deps
        run: npm ci --legacy-peer-deps

      - name: Security Audit
        continue-on-error: true
        id: security_audit
        run: |
          npm audit --audit-level=high > npm-audit.txt 2>&1 || true
          VULNS=$(grep -c "high" npm-audit.txt || echo "0")
          echo "vulns=$VULNS" >> $GITHUB_OUTPUT

      - name: Install Python Deps
        run: |
          python -m venv .venv
          source .venv/bin/activate
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi
          if [ -f "pyproject.toml" ]; then
            pip install .
          fi
          if [ -f "api/requirements.txt" ]; then
            pip install -r api/requirements.txt
          fi
          pip install pytest pytest-cov
          cd ..

      - name: Install Go Deps
        if: hashFiles('api/go.mod') != ''
        run: |
          cd api
          go mod download
          cd ..

      # --- Build ---
      - name: Build Frontend & Bundle Analysis
        id: build
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        run: npm run build

      # --- Tests & Coverage ---

      # 1. Frontend (Vitest)
      - name: Frontend Tests
        id: test_frontend
        continue-on-error: true
        run: |
          npm run test:coverage -- --coverage.reporter=text --coverage.reporter=json-summary > frontend-test.txt 2>&1
          exit_code=$?
          cat frontend-test.txt
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT
          if [ $exit_code -eq 0 ]; then echo "status=success" >> $GITHUB_OUTPUT; else echo "status=failure" >> $GITHUB_OUTPUT; fi

          # Extract coverage percentage if available
          if [ -f "coverage/coverage-summary.json" ]; then
            COVERAGE=$(node -e "try { const data=require('./coverage/coverage-summary.json'); console.log(data.total.lines.pct); } catch(e) { console.log('0'); }")
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          else
            echo "coverage=0" >> $GITHUB_OUTPUT
          fi

      # 2. Go Backend
      - name: Go Tests
        id: test_go
        if: hashFiles('api/**/*.go') != ''
        continue-on-error: true
        run: |
          cd api
          # Go 1.23 coverage
          go test ./... -coverprofile=coverage.out > ../go-test.txt 2>&1
          exit_code=$?

          # Extract coverage percentage
          if [ -f "coverage.out" ]; then
            COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            # Generate HTML coverage report
            go tool cover -html=coverage.out -o coverage.html
          else
            echo "coverage=0" >> $GITHUB_OUTPUT
          fi

          cd ..
          cat go-test.txt
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT
          if [ $exit_code -eq 0 ]; then echo "status=success" >> $GITHUB_OUTPUT; else echo "status=failure" >> $GITHUB_OUTPUT; fi

      # 3. Python Backend
      - name: Python Tests
        id: test_python
        if: hashFiles('api/**/*.py') != ''
        continue-on-error: true
        run: |
          set +e
          source .venv/bin/activate
          echo "üöÄ Starting Python tests..."
          # Run pytest with coverage (add JSON report) - Run from root for absolute imports
          python -m pytest api --cov=api --cov-report=term-missing --cov-report=html --cov-report=json > python-test.txt 2>&1
          exit_code=$?
          set -e

          echo "üìä Pytest exit code: $exit_code"
          cat python-test.txt

          # Extract coverage percentage from root-level coverage.json
          if [ -f "coverage.json" ]; then
            COVERAGE=$(python -c "import json; data=json.load(open('coverage.json')); print(data.get('totals', {}).get('percent_covered', 0))" 2>/dev/null || echo "0")
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è coverage.json not found"
            echo "coverage=0" >> $GITHUB_OUTPUT
          fi

          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT
          if [ $exit_code -eq 0 ]; then echo "status=success" >> $GITHUB_OUTPUT; else echo "status=failure" >> $GITHUB_OUTPUT; fi

      # --- Upload Codecov ---
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info,./api/coverage.out,./coverage.json
          flags: daily-health
          name: daily-health-check
          fail_ci_if_error: false

      # --- Prep & Upload Artifacts ---
      # --- Prep & Upload Artifacts ---
      - name: Analyze Coverage & Generate Metrics
        id: metrics
        if: always()
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ matrix.branch }}
          BUILD_OUTCOME: ${{ steps.build.outcome }}
          FE_STATUS: ${{ steps.test_frontend.outputs.status || 'skipped' }}
          GO_STATUS: ${{ steps.test_go.outputs.status || 'skipped' }}
          PY_STATUS: ${{ steps.test_python.outputs.status || 'skipped' }}
          FE_COVERAGE: ${{ steps.test_frontend.outputs.coverage || 0 }}
          GO_COVERAGE: ${{ steps.test_go.outputs.coverage || 0 }}
          PY_COVERAGE: ${{ steps.test_python.outputs.coverage || 0 }}
          VULNS: ${{ steps.security_audit.outputs.vulns || '0' }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // --- 1. Identify Lowest Test Targets ---
            const allOffenders = [];
            const cleanPath = (p) => {
                let path = p.replace('/home/runner/work/violet-vault/violet-vault/', '');
                path = path.replace(/^api\//, '');
                return path;
            };

            // Frontend
            if (fs.existsSync('coverage/coverage-summary.json')) {
               try {
                   const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
                   for (const [filepath, metrics] of Object.entries(coverage)) {
                       if (filepath === 'total' || filepath.includes('config') || filepath.includes('.d.ts')) continue;
                       if (metrics.lines.pct < 80) {
                           allOffenders.push({ file: cleanPath(filepath), pct: metrics.lines.pct, lang: 'TypeScript' });
                       }
                   }
               } catch (e) { console.error("FE parse error", e); }
            }

            // Python
            if (fs.existsSync('coverage.json')) {
               try {
                   const coverage = JSON.parse(fs.readFileSync('coverage.json', 'utf8'));
                   // Coverage.py JSON format: { "files": { "path/to/file": { "summary": { "percent_covered": 85.5 } } } }
                   const files = coverage.files || {};
                   for (const [filepath, metrics] of Object.entries(files)) {
                       const pct = metrics.summary.percent_covered;
                       if (pct < 80) {
                           allOffenders.push({ file: cleanPath(filepath), pct: pct, lang: 'Python' });
                       }
                   }
               } catch (e) { console.error("PY parse error", e); }
            }

            // Sort & Pick Top 5
            allOffenders.sort((a, b) => a.pct - b.pct);
            const top5 = allOffenders.slice(0, 5);

            // --- 2. Construct Payload ---
            const payload = {
              branch: process.env.BRANCH_NAME,
              buildStatus: process.env.BUILD_OUTCOME,
              feStatus: process.env.FE_STATUS,
              goStatus: process.env.GO_STATUS,
              pyStatus: process.env.PY_STATUS,
              feCoverage: parseFloat(process.env.FE_COVERAGE),
              goCoverage: parseFloat(process.env.GO_COVERAGE),
              pyCoverage: parseFloat(process.env.PY_COVERAGE),
              securityVulns: process.env.VULNS,
              runId: context.runId,
              lowestTargets: top5
            };

            // Write to unique file to avoid overwrite during merge-multiple download
            const filename = `report-${process.env.BRANCH_NAME.replace(/\//g, '-')}.json`; 
            fs.writeFileSync(filename, JSON.stringify(payload, null, 2));
            console.log(`Generated ${filename}`);

      - name: Upload Health Metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-metrics-${{ matrix.branch }}
          path: report-*.json
          retention-days: 1

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ matrix.branch }}
          path: |
            coverage/
            *.txt
            api/coverage.out
            api/coverage.html
            api/htmlcov/
            coverage.json
          retention-days: 7

  report:
    name: Consolidate Report
    needs: health-check
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- Stale Branch Cleanup (Singleton) ---
      - name: Stale Branch Cleanup
        id: cleanup
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üßπ Housekeeping: Stale Branch Cleanup"
          PROTECTED_REGEX="^(main|develop|feat/|archive/|dependabot/|lighthouse-reports)"
          CUTOFF_DATE=$(date -d "72 hours ago" +%s)
          DELETED_BRANCHES=""
          ALL_BRANCHES=$(git branch -r | sed 's/origin\///' | tr -d ' ' | grep -v "HEAD")

          for BRANCH in $ALL_BRANCHES; do
            if [[ $BRANCH =~ $PROTECTED_REGEX ]]; then continue; fi
            LAST_COMMIT_DATE=$(git log -1 --format=%ct "origin/$BRANCH" 2>/dev/null || echo "0")
            if [ "$LAST_COMMIT_DATE" -lt "$CUTOFF_DATE" ] && [ "$LAST_COMMIT_DATE" -ne "0" ]; then
              echo "üóëÔ∏è Deleting stale branch: $BRANCH"
              if git push origin --delete "$BRANCH" --no-verify; then
                DELETED_BRANCHES="$DELETED_BRANCHES $BRANCH"
              else
                echo "   ‚ö†Ô∏è Failed to delete $BRANCH"
              fi
            fi
          done
          echo "deleted_branches=$DELETED_BRANCHES" >> $GITHUB_OUTPUT

      # --- Download All Metrics ---
      - name: Download Metrics
        uses: actions/download-artifact@v4
        with:
          pattern: health-metrics-*
          path: metrics
          merge-multiple: true

      # --- Generate & Post Report ---
      - name: Generate Combined Report
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
          DELETED_BRANCHES: ${{ steps.cleanup.outputs.deleted_branches }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1. Read Metrics
            const metricsDir = 'metrics';
            const metrics = [];
            if (fs.existsSync(metricsDir)) {
              fs.readdirSync(metricsDir).forEach(file => {
                if (file.endsWith('.json')) {
                   try {
                     const data = JSON.parse(fs.readFileSync(path.join(metricsDir, file), 'utf8'));
                     metrics.push(data);
                   } catch (e) { console.error('Error parsing JSON', file, e); }
                }
              });
            }

            // Global Status Logic
            const dateStr = new Date().toISOString().split('T')[0];
            let allHealthy = true;
            metrics.forEach(m => {
               if (m.buildStatus !== 'success') allHealthy = false;
               if (m.feStatus === 'failure') allHealthy = false;
               if (m.goStatus === 'failure') allHealthy = false;
               if (m.pyStatus === 'failure') allHealthy = false;
            });
            const emoji = allHealthy ? '‚úÖ' : '‚ùå';

            let body = `## ${emoji} Daily Health Check: ${dateStr}\n\n`;
            body += `**Workflow Run**: [View Logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n`;


            // 2. Per-Branch Metrics Table
            body += `## üìä Branch Status\n\n`;
            metrics.forEach(m => {
               const branchEmoji = (m.buildStatus === 'success' && m.feStatus !== 'failure' && m.goStatus !== 'failure' && m.pyStatus !== 'failure') ? '‚úÖ' : '‚ùå';
               body += `### ${branchEmoji} ${m.branch}\n`;
               body += `| Suite | Coverage | Status |\n`;
               body += `|-------|----------|--------|\n`;
               body += `| Frontend | ${m.feCoverage.toFixed(1)}% | ${m.feCoverage >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} |\n`;
               body += `| Backend (Go) | ${m.goCoverage.toFixed(1)}% | ${m.goCoverage >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} |\n`;
               body += `| Backend (Python) | ${m.pyCoverage.toFixed(1)}% | ${m.pyCoverage >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} |\n`;
               body += `**Security**: ${m.securityVulns} High Vulns\n\n`;

               // Test Targets Table
               if (m.lowestTargets && m.lowestTargets.length > 0) {
                   body += `#### üéØ Lowest Test Targets (Top 5)\n`;
                   body += `| File | Lang | Coverage |\n`;
                   body += `|------|------|----------|\n`;
                   m.lowestTargets.forEach(t => {
                       body += `| \`${t.file}\` | ${t.lang} | **${t.pct.toFixed(1)}%** |\n`;
                   });
                   body += `\n`;
               }
            });

            // 3. Ecosystem Coverage (FIXED with Error Handling)
            try {
                body += `## üåê Ecosystem Coverage (Active Branches)\n\n`;
                body += `| Branch | Latest Coverage | Status |\n`;
                body += `|--------|-----------------|--------|\n`;

                const token = process.env.CODECOV_TOKEN;
                const branchesToChecks = []; // We will fill this dynamically
                
                // Always check main and develop
                if (!branchesToChecks.includes('main')) branchesToChecks.push('main');
                if (!branchesToChecks.includes('develop')) branchesToChecks.push('develop');

                // Get feat/* branches from GitHub
                const branches = await github.rest.repos.listBranches({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    protected: false,
                    per_page: 100
                });
                
                branches.data.forEach(b => {
                    if (b.name.startsWith('feat/')) branchesToChecks.push(b.name);
                });

                for (const b of branchesToChecks) {
                    try {
                        const response = await fetch(`https://api.codecov.io/api/v2/github/${context.repo.owner}/repos/${context.repo.repo}/branches/${encodeURIComponent(b)}/`, {
                            headers: { 'Authorization': `bearer ${token}` }
                        });
                        
                        if (response.status === 404) {
                            body += `| \`${b}\` | No Report | ‚ö™ |\n`;
                            continue;
                        }

                        if (!response.ok) throw new Error(`Status ${response.status}`);
                        const data = await response.json();
                        const coverage = data.head_commit?.totals?.coverage;
                        
                        if (coverage !== undefined) {
                            body += `| \`${b}\` | ${parseFloat(coverage).toFixed(1)}% | ${coverage >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} |\n`;
                        } else {
                            body += `| \`${b}\` | Processing | ‚è≥ |\n`;
                        }
                    } catch (e) {
                        console.error(`Codecov fetch failed for ${b}:`, e);
                        body += `| \`${b}\` | ${e.message} | ‚ùå |\n`;
                    }
                }
                body += `\n`;
            } catch (e) { console.error("Multi-branch fetch failed", e); }

            // 4. Infrastructure
            const deletedBranches = process.env.DELETED_BRANCHES || '';
            body += `### Infrastructure\n`;
            body += `- **Stale Branches Removed**: ${deletedBranches ? `üßπ \`${deletedBranches}\`` : '‚úÖ None'}\n`;
            body += `\n---\n*VioletVault Sentinel Health Bot*`;

            // 5. Create Issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Daily Health: ${dateStr} - ${emoji}`,
              body: body,
              labels: ['daily-health']
            });
