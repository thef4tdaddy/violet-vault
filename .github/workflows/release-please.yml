name: Release Please

on:
  # Manual trigger for immediate releases
  workflow_dispatch:
    inputs:
      force_release:
        description: "Force release even if major/minor"
        required: false
        default: false
        type: boolean

  # Hourly automated check for patch releases only (as requested in #547)
  schedule:
    - cron: "0 * * * *" # Every hour at minute 0

  # Also run on push to main and develop for immediate patch releases
  push:
    branches:
      - main
      - develop

# Prevent duplicate runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false # Don't cancel release workflows

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # Handle develop branch pre-releases separately (commit-count-based)
  develop-prerelease:
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop'
    outputs:
      release_created: ${{ steps.prerelease.outputs.release_created }}
      tag_name: ${{ steps.prerelease.outputs.tag_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Calculate pre-release version
        id: prerelease
        run: |
          # Get current package version (base version, e.g., 2.0.0)
          PACKAGE_VERSION=$(node -p "require('./package.json').version")

          # Find the last prerelease tag for this base version
          # Pattern: v2.0.0-prerelease.1, v2.0.0-prerelease.2, etc.
          LAST_PRERELEASE_TAG=$(git tag --sort=-version:refname | grep -E "^v${PACKAGE_VERSION}-prerelease\.[0-9]+$" | head -1 || echo "")

          if [ -n "$LAST_PRERELEASE_TAG" ]; then
            # Extract base version (remove existing prerelease suffix if present)
            BASE_VERSION=$(echo "$PACKAGE_VERSION" | sed 's/-prerelease.*//')
            
            # Extract prerelease number from last tag (e.g., "v2.0.0-prerelease.5" -> "5")
            LAST_PRERELEASE_NUM=$(echo "$LAST_PRERELEASE_TAG" | sed -E 's/^v[0-9]+\.[0-9]+\.[0-9]+-prerelease\.([0-9]+)$/\1/')
            NEXT_PRERELEASE_NUM=$((LAST_PRERELEASE_NUM + 1))
            PRE_RELEASE_VERSION="${BASE_VERSION}-prerelease.${NEXT_PRERELEASE_NUM}"
            
            # Count commits since last prerelease tag
            COMMIT_COUNT=$(git rev-list --count ${LAST_PRERELEASE_TAG}..HEAD 2>/dev/null || echo "0")
          else
            # No prerelease tags exist yet, start at 1
            BASE_VERSION=$(echo "$PACKAGE_VERSION" | sed 's/-prerelease.*//')
            PRE_RELEASE_VERSION="${BASE_VERSION}-prerelease.1"
            
            # Count commits since last tag (any tag) or from beginning
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              COMMIT_COUNT=$(git rev-list --count ${LAST_TAG}..HEAD 2>/dev/null || echo "0")
            else
              COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "1")
            fi
          fi

          # Check if this version already exists
          if git rev-parse "v${PRE_RELEASE_VERSION}" >/dev/null 2>&1; then
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Pre-release v${PRE_RELEASE_VERSION} already exists"
            exit 0
          fi

          # Check if we should create a release (every 10 commits or manual trigger)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] || [ "$COMMIT_COUNT" -ge 10 ] || [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "release_created=true" >> $GITHUB_OUTPUT
            echo "tag_name=v${PRE_RELEASE_VERSION}" >> $GITHUB_OUTPUT
            echo "version=${PRE_RELEASE_VERSION}" >> $GITHUB_OUTPUT
            echo "commit_count=${COMMIT_COUNT}" >> $GITHUB_OUTPUT
            echo "‚úÖ Will create pre-release: v${PRE_RELEASE_VERSION}"
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Skipping: only ${COMMIT_COUNT} commits since last release (need 10+)"
          fi

      - name: Create pre-release branch and update files
        if: steps.prerelease.outputs.release_created == 'true'
        run: |
          VERSION="${{ steps.prerelease.outputs.version }}"
          TAG_NAME="${{ steps.prerelease.outputs.tag_name }}"
          RELEASE_BRANCH="release-please--branches--develop--components--violet-vault"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create or checkout release branch
          if git show-ref --verify --quiet refs/heads/${RELEASE_BRANCH}; then
            git checkout ${RELEASE_BRANCH}
            git pull origin ${RELEASE_BRANCH} || true
          else
            git checkout -b ${RELEASE_BRANCH}
          fi

          # Update package.json version
          npm version ${VERSION} --no-git-tag-version

          # Create/update CHANGELOG.md entry
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
          fi

          # Add changelog entry
          TODAY=$(date +%Y-%m-%d)
          COMMIT_COUNT="${{ steps.prerelease.outputs.commit_count }}"
          CHANGELOG_ENTRY="## [${VERSION}] - ${TODAY}\n\n### Pre-release\n\n- Pre-release for develop branch (commit count: ${COMMIT_COUNT})\n"

          # Prepend to CHANGELOG.md
          echo -e "${CHANGELOG_ENTRY}\n$(cat CHANGELOG.md)" > CHANGELOG.md

          # Commit changes
          git add package.json CHANGELOG.md
          git commit -m "chore: release ${VERSION}" || echo "No changes to commit"

          # Push branch
          git push origin ${RELEASE_BRANCH} || echo "Branch already up to date"

      - name: Create pre-release PR
        if: steps.prerelease.outputs.release_created == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const version = '${{ steps.prerelease.outputs.version }}';
            const releaseBranch = 'release-please--branches--develop--components--violet-vault';
            const baseBranch = 'develop';

            // Check if PR already exists
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${releaseBranch}`,
              base: baseBranch,
              state: 'open'
            });

            if (existingPRs.length > 0) {
              console.log(`‚úÖ Pre-release PR already exists: #${existingPRs[0].number}`);
              return;
            }

            // Create release PR
            const prTitle = `chore: release ${version}`;
            const prBody = `## Release ${version}\n\nPre-release for develop branch.\n\nThis PR was created automatically by release-please.\n\n**Version format**: \`#.#.#-prerelease.#\` (based on commit count since last release)`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: prTitle,
                body: prBody,
                head: releaseBranch,
                base: baseBranch,
                draft: false
              });
              
              console.log(`‚úÖ Created pre-release PR: #${pr.number}`);
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not create PR: ${error.message}`);
            }

  # Regular release-please for main branch
  release-please:
    runs-on: ubuntu-latest
    if: github.ref_name == 'main'
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
    steps:
      - name: Release Please
        uses: googleapis/release-please-action@v4
        id: release
        with:
          config-file: configs/release-please-config.json
          manifest-file: .release-please-manifest.json
          target-branch: main

      - name: Release Summary
        if: steps.release.outputs.release_created
        run: |
          echo "üöÄ Release created: ${{ steps.release.outputs.tag_name }}"
          echo "üì¶ Package: violet-vault"

  # Check release type after release-please runs
  check-auto-release:
    needs: [release-please, develop-prerelease]
    runs-on: ubuntu-latest
    if: |
      (needs.release-please.outputs.release_created == 'true') ||
      (needs.develop-prerelease.outputs.release_created == 'true')
    outputs:
      should-auto-deploy: ${{ steps.check.outputs.should-auto-deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if auto-deploy should run
        id: check
        run: |
          # Get the just-created tag (from either main or develop)
          TAG_NAME="${{ needs.release-please.outputs.tag_name || needs.develop-prerelease.outputs.tag_name }}"
          echo "Checking tag: $TAG_NAME"

          # Get previous tag for comparison
          PREV_TAG=$(git tag --sort=-version:refname | grep -v "$TAG_NAME" | head -1)
          echo "Previous tag: $PREV_TAG"

          # Get commits in this release
          if [ -n "$PREV_TAG" ]; then
            COMMITS_IN_RELEASE=$(git log --oneline ${PREV_TAG}..${TAG_NAME} --format="%s")
          else
            COMMITS_IN_RELEASE=$(git log --oneline --format="%s" | head -20)
          fi

          echo "Commits in release:"
          echo "$COMMITS_IN_RELEASE"

          # Check for breaking changes or major features
          HAS_BREAKING=$(echo "$COMMITS_IN_RELEASE" | grep -i "BREAKING CHANGE\|!" || true)
          HAS_MAJOR_FEAT=$(echo "$COMMITS_IN_RELEASE" | grep -E "^feat(\([^)]*\))?!:" || true)
          HAS_FEAT=$(echo "$COMMITS_IN_RELEASE" | grep -E "^feat(\([^)]*\))?:" || true)

          # Only auto-deploy patch releases (no feat: or BREAKING CHANGE)
          if [ -z "$HAS_BREAKING" ] && [ -z "$HAS_MAJOR_FEAT" ] && [ -z "$HAS_FEAT" ]; then
            echo "should-auto-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Patch release detected - will auto-deploy"
          elif [ "${{ github.event.inputs.force_release }}" = "true" ]; then
            echo "should-auto-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Forced release - will auto-deploy"
          else
            echo "should-auto-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Major/minor release detected - manual deployment required"
            echo "::warning::This is a major/minor release. Build artifacts will be created but not deployed automatically."
          fi

  # Build and deploy when a release is created (conditionally)
  build-and-deploy:
    needs: [release-please, develop-prerelease, check-auto-release]
    runs-on: ubuntu-latest
    if: |
      (needs.release-please.outputs.release_created == 'true') ||
      (needs.develop-prerelease.outputs.release_created == 'true')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Lint
        run: npm run lint

      - name: Test
        run: npm run test:run

      - name: Build
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ needs.release-please.outputs.tag_name || needs.develop-prerelease.outputs.tag_name }}
          path: dist/

      - name: Deployment Status
        run: |
          if [ "${{ needs.check-auto-release.outputs.should-auto-deploy }}" = "true" ]; then
            echo "‚úÖ Patch release - artifacts ready for automatic deployment"
          else
            echo "‚ö†Ô∏è Major/minor release - manual deployment review required"
            echo "Build artifacts have been created and are ready for manual deployment when approved."
          fi
